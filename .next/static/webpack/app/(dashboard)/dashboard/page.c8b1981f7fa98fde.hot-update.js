"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/dashboard/page",{

/***/ "(app-pages-browser)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEmployee: () => (/* binding */ addEmployee),\n/* harmony export */   addPointTransaction: () => (/* binding */ addPointTransaction),\n/* harmony export */   broadcastTransactionEvent: () => (/* binding */ broadcastTransactionEvent),\n/* harmony export */   checkServiceStock: () => (/* binding */ checkServiceStock),\n/* harmony export */   createAttendanceRecord: () => (/* binding */ createAttendanceRecord),\n/* harmony export */   createBranchShift: () => (/* binding */ createBranchShift),\n/* harmony export */   createExpenseRequest: () => (/* binding */ createExpenseRequest),\n/* harmony export */   createKasbonRequest: () => (/* binding */ createKasbonRequest),\n/* harmony export */   createTransaction: () => (/* binding */ createTransaction),\n/* harmony export */   createTransactionItems: () => (/* binding */ createTransactionItems),\n/* harmony export */   deleteEmployee: () => (/* binding */ deleteEmployee),\n/* harmony export */   deleteExpenseRequest: () => (/* binding */ deleteExpenseRequest),\n/* harmony export */   generateTransactionNumber: () => (/* binding */ generateTransactionNumber),\n/* harmony export */   getAbsentEmployeesToday: () => (/* binding */ getAbsentEmployeesToday),\n/* harmony export */   getActiveReceiptTemplate: () => (/* binding */ getActiveReceiptTemplate),\n/* harmony export */   getAllAttendanceRecords: () => (/* binding */ getAllAttendanceRecords),\n/* harmony export */   getAllExpensesWithDetails: () => (/* binding */ getAllExpensesWithDetails),\n/* harmony export */   getApprovedExpenses: () => (/* binding */ getApprovedExpenses),\n/* harmony export */   getAttendanceByDate: () => (/* binding */ getAttendanceByDate),\n/* harmony export */   getBranchShifts: () => (/* binding */ getBranchShifts),\n/* harmony export */   getBranches: () => (/* binding */ getBranches),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   getDetailedAttendanceRecords: () => (/* binding */ getDetailedAttendanceRecords),\n/* harmony export */   getEmployeeAbsenceInfo: () => (/* binding */ getEmployeeAbsenceInfo),\n/* harmony export */   getEmployeeAttendance: () => (/* binding */ getEmployeeAttendance),\n/* harmony export */   getEmployeeAttendanceWithPhotos: () => (/* binding */ getEmployeeAttendanceWithPhotos),\n/* harmony export */   getEmployeeCommissions: () => (/* binding */ getEmployeeCommissions),\n/* harmony export */   getEmployeePhotos: () => (/* binding */ getEmployeePhotos),\n/* harmony export */   getEmployeeStats: () => (/* binding */ getEmployeeStats),\n/* harmony export */   getEmployees: () => (/* binding */ getEmployees),\n/* harmony export */   getExpenseStatistics: () => (/* binding */ getExpenseStatistics),\n/* harmony export */   getExpenseStatisticsByBranch: () => (/* binding */ getExpenseStatisticsByBranch),\n/* harmony export */   getExpenses: () => (/* binding */ getExpenses),\n/* harmony export */   getExpensesByStatus: () => (/* binding */ getExpensesByStatus),\n/* harmony export */   getKasbonRequests: () => (/* binding */ getKasbonRequests),\n/* harmony export */   getKasbonStatistics: () => (/* binding */ getKasbonStatistics),\n/* harmony export */   getLowStockAlerts: () => (/* binding */ getLowStockAlerts),\n/* harmony export */   getOutletStock: () => (/* binding */ getOutletStock),\n/* harmony export */   getOwnerPin: () => (/* binding */ getOwnerPin),\n/* harmony export */   getPointTransactions: () => (/* binding */ getPointTransactions),\n/* harmony export */   getPointsStatistics: () => (/* binding */ getPointsStatistics),\n/* harmony export */   getReceiptTemplate: () => (/* binding */ getReceiptTemplate),\n/* harmony export */   getServiceCategories: () => (/* binding */ getServiceCategories),\n/* harmony export */   getServicesWithCategories: () => (/* binding */ getServicesWithCategories),\n/* harmony export */   getUserPoints: () => (/* binding */ getUserPoints),\n/* harmony export */   getUsersWithKasbon: () => (/* binding */ getUsersWithKasbon),\n/* harmony export */   getUsersWithPoints: () => (/* binding */ getUsersWithPoints),\n/* harmony export */   loadBranchData: () => (/* binding */ loadBranchData),\n/* harmony export */   loadBranchesData: () => (/* binding */ loadBranchesData),\n/* harmony export */   processTransaction: () => (/* binding */ processTransaction),\n/* harmony export */   reduceOutletStock: () => (/* binding */ reduceOutletStock),\n/* harmony export */   reduceServiceStock: () => (/* binding */ reduceServiceStock),\n/* harmony export */   setupEmployeeRealtime: () => (/* binding */ setupEmployeeRealtime),\n/* harmony export */   setupGlobalEventsListener: () => (/* binding */ setupGlobalEventsListener),\n/* harmony export */   setupKomisiRealtime: () => (/* binding */ setupKomisiRealtime),\n/* harmony export */   setupTransactionsRealtime: () => (/* binding */ setupTransactionsRealtime),\n/* harmony export */   subscribeToEvents: () => (/* binding */ subscribeToEvents),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   testSupabaseConnection: () => (/* binding */ testSupabaseConnection),\n/* harmony export */   updateAttendanceRecord: () => (/* binding */ updateAttendanceRecord),\n/* harmony export */   updateEmployee: () => (/* binding */ updateEmployee),\n/* harmony export */   updateExpenseRequest: () => (/* binding */ updateExpenseRequest),\n/* harmony export */   updateExpenseStatus: () => (/* binding */ updateExpenseStatus),\n/* harmony export */   updateKasbonStatus: () => (/* binding */ updateKasbonStatus),\n/* harmony export */   updateMaxAbsentDays: () => (/* binding */ updateMaxAbsentDays),\n/* harmony export */   updateOutletStock: () => (/* binding */ updateOutletStock),\n/* harmony export */   updateServiceStock: () => (/* binding */ updateServiceStock),\n/* harmony export */   updateUserPin: () => (/* binding */ updateUserPin),\n/* harmony export */   uploadPhotoToSupabase: () => (/* binding */ uploadPhotoToSupabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/.pnpm/@supabase+supabase-js@2.55.0/node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\n// =============================\n// Konfigurasi Supabase\n// =============================\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"https://tkrrjvcgviwnliinovik.supabase.co\";\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrcnJqdmNndml3bmxpaW5vdmlrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMDE4MjQsImV4cCI6MjA3MDY3NzgyNH0.uf7R06Gd6Mgf_3Zv3Q184HWPqzo6kbrfhQ1BkkdM9iM\";\nif (!supabaseUrl) {\n    throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable.\");\n}\nif (!supabaseAnonKey) {\n    throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable.\");\n}\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: true,\n        autoRefreshToken: true\n    },\n    realtime: {\n        params: {\n            eventsPerSecond: 10\n        }\n    },\n    global: {\n        headers: {\n            'x-application-name': 'pigtown-barbershop'\n        }\n    }\n});\nconst testSupabaseConnection = async ()=>{\n    try {\n        const { data, error } = await supabase.from(\"points\").select('*, users!inner(name, branch_id, branches:branch_id(name))');\n        if (error) {\n            console.error(\"Supabase connection test failed:\", error);\n            return false;\n        }\n        console.log(\"Supabase connection successful\");\n        return true;\n    } catch (error) {\n        console.error(\"Supabase connection error:\", error);\n        return false;\n    }\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Hitung Hari Kerja\n// =============================\nfunction getBusinessDaysCount(startDate, endDate) {\n    let count = 0;\n    const curDate = new Date(startDate.getTime());\n    while(curDate <= endDate){\n        const dayOfWeek = curDate.getDay();\n        // 0 = Minggu, 6 = Sabtu (tidak dihitung sebagai hari kerja)\n        if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n            count++;\n        }\n        curDate.setDate(curDate.getDate() + 1);\n    }\n    return count;\n}\nasync function getBranchShifts(branchId) {\n    console.log(\"[v0] getBranchShifts called with branchId:\", branchId);\n    const { data, error } = await supabase.from(\"branch_shifts\").select(\"*\").eq(\"branch_id\", branchId).eq(\"is_active\", true).order(\"start_time\");\n    console.log(\"[v0] Branch shifts result:\", {\n        data,\n        error\n    });\n    if (error || !data || data.length === 0) {\n        console.log(\"[v0] No shifts found, returning default shifts\");\n        return {\n            data: [\n                {\n                    id: \"default-pagi-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Pagi\",\n                    shift_type: \"pagi\",\n                    start_time: \"08:00\",\n                    end_time: \"16:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                },\n                {\n                    id: \"default-siang-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Siang\",\n                    shift_type: \"siang\",\n                    start_time: \"12:00\",\n                    end_time: \"20:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                },\n                {\n                    id: \"default-malam-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Malam\",\n                    shift_type: \"malam\",\n                    start_time: \"20:00\",\n                    end_time: \"04:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                }\n            ],\n            error: null\n        };\n    }\n    return {\n        data,\n        error: null\n    };\n}\nasync function createBranchShift(shiftData) {\n    console.log(\"[v0] createBranchShift called with:\", shiftData);\n    const shiftToInsert = {\n        ...shiftData,\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"branch_shifts\").insert([\n        shiftToInsert\n    ]).select().single();\n    console.log(\"[v0] Create branch shift result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// Fungsi helper Attendance\n// =============================\nasync function uploadPhotoToSupabase(base64, filename) {\n    try {\n        function base64ToBlob(base64Data) {\n            let contentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"image/jpeg\";\n            const byteCharacters = atob(base64Data.split(\",\")[1]);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++)byteNumbers[i] = slice.charCodeAt(i);\n                byteArrays.push(new Uint8Array(byteNumbers));\n            }\n            return new Blob(byteArrays, {\n                type: contentType\n            });\n        }\n        const blob = base64ToBlob(base64);\n        const { error } = await supabase.storage.from(\"attendance-photos\").upload(filename, blob, {\n            cacheControl: \"3600\",\n            upsert: true,\n            contentType: \"image/jpeg\"\n        });\n        if (error) throw error;\n        const { data: publicUrlData } = supabase.storage.from(\"attendance-photos\").getPublicUrl(filename);\n        return (publicUrlData === null || publicUrlData === void 0 ? void 0 : publicUrlData.publicUrl) || null;\n    } catch (error) {\n        console.error(\"Photo upload failed:\", error);\n        return null;\n    }\n}\nasync function createAttendanceRecord(attendanceData) {\n    const { data, error } = await supabase.from(\"attendance\").insert([\n        attendanceData\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateAttendanceRecord(id, updates) {\n    const { data, error } = await supabase.from(\"attendance\").update({\n        ...updates,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", id).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAttendanceByDate(userId, date) {\n    const { data, error } = await supabase.from(\"attendance\").select(\"*\").eq(\"user_id\", userId).eq(\"date\", date).single();\n    return error && error.code !== \"PGRST116\" ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAllAttendanceRecords(branchId) {\n    let query = supabase.from(\"attendance\").select(\"*,\\n      users:user_id ( id, name, email ),\\n      branches:branch_id ( id, name )\\n    \").order(\"date\", {\n        ascending: false\n    }).order(\"created_at\", {\n        ascending: false\n    });\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data, error } = await query;\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Fungsi helper POS\n// =============================\nasync function getServicesWithCategories() {\n    const { data, error } = await supabase.from(\"services\").select(\"*,\\n    service_categories ( id, name, description )\\n  \").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function getServiceCategories() {\n    const { data, error } = await supabase.from(\"service_categories\").select(\"*\").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function createTransaction(transactionData) {\n    const transactionNumber = await generateTransactionNumber();\n    let { cashier_id, branch_id, server_id } = transactionData;\n    // Get cashier, branch, server data untuk snapshot\n    let cashierName = 'Unknown';\n    let branchName = 'Unknown';\n    let serverName;\n    if (!cashier_id) {\n        const { data: users } = await supabase.from(\"users\").select(\"id, name\").limit(1).single();\n        cashier_id = users === null || users === void 0 ? void 0 : users.id;\n        cashierName = (users === null || users === void 0 ? void 0 : users.name) || 'Unknown';\n    } else {\n        const { data: cashier } = await supabase.from(\"users\").select(\"name\").eq(\"id\", cashier_id).single();\n        cashierName = (cashier === null || cashier === void 0 ? void 0 : cashier.name) || 'Unknown';\n    }\n    if (!branch_id) {\n        const { data: branches } = await supabase.from(\"branches\").select(\"id, name\").limit(1).single();\n        branch_id = branches === null || branches === void 0 ? void 0 : branches.id;\n        branchName = (branches === null || branches === void 0 ? void 0 : branches.name) || 'Unknown';\n    } else {\n        const { data: branch } = await supabase.from(\"branches\").select(\"name\").eq(\"id\", branch_id).single();\n        branchName = (branch === null || branch === void 0 ? void 0 : branch.name) || 'Unknown';\n    }\n    if (server_id) {\n        const { data: server } = await supabase.from(\"users\").select(\"name\").eq(\"id\", server_id).single();\n        serverName = server === null || server === void 0 ? void 0 : server.name;\n    }\n    const transactionToInsert = {\n        ...transactionData,\n        transaction_number: transactionNumber,\n        receipt_number: transactionNumber,\n        cashier_id,\n        cashier_name: cashierName,\n        branch_id,\n        branch_name: branchName,\n        server_id,\n        server_name: serverName,\n        subtotal: transactionData.subtotal || transactionData.total_amount || 0,\n        payment_status: transactionData.payment_status || \"completed\",\n        payment_method: transactionData.payment_method || \"cash\",\n        total_amount: transactionData.total_amount || 0,\n        discount_amount: transactionData.discount_amount || 0,\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"transactions\").insert([\n        transactionToInsert\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function createTransactionItems(items) {\n    // Enrich items dengan snapshot data dari services\n    const enrichedItems = await Promise.all(items.map(async (item)=>{\n        if (item.service_id) {\n            var _service_service_categories;\n            const { data: service } = await supabase.from(\"services\").select(\"name, type, service_categories(name)\").eq(\"id\", item.service_id).single();\n            return {\n                ...item,\n                service_name: (service === null || service === void 0 ? void 0 : service.name) || 'Unknown Service',\n                service_type: service === null || service === void 0 ? void 0 : service.type,\n                service_category: service === null || service === void 0 ? void 0 : (_service_service_categories = service.service_categories) === null || _service_service_categories === void 0 ? void 0 : _service_service_categories.name\n            };\n        }\n        return item;\n    }));\n    const { data, error } = await supabase.from(\"transaction_items\").insert(enrichedItems).select();\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function getReceiptTemplate(branchId) {\n    let query = supabase.from(\"receipt_templates\").select(\"*\");\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data, error } = await query.single();\n    return error && error.code !== \"PGRST116\" ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getActiveReceiptTemplate(branchId) {\n    // Priority 1: Try to get active template (is_active = true)\n    let query = supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_active\", true);\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data: activeData, error: activeError } = await query.single();\n    if (activeData && !activeError) {\n        return {\n            data: activeData,\n            error: null\n        };\n    }\n    // Priority 2: If no active template, get default template (is_default = true)\n    let defaultQuery = supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_default\", true);\n    if (branchId) defaultQuery = defaultQuery.eq(\"branch_id\", branchId);\n    const { data: defaultData, error: defaultError } = await defaultQuery.single();\n    if (defaultData && !defaultError) {\n        return {\n            data: defaultData,\n            error: null\n        };\n    }\n    // Priority 3: Fallback to any template\n    return await getReceiptTemplate(branchId);\n}\nasync function getBranches() {\n    const { data, error } = await supabase.from(\"branches\").select(\"*\").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function generateTransactionNumber() {\n    try {\n        const { data, error } = await supabase.rpc(\"generate_receipt_number\");\n        if (!error && data) return data;\n        const today = new Date();\n        const dateStr = today.toISOString().slice(0, 10).replace(/-/g, \"\");\n        const { data: transactions } = await supabase.from(\"transactions\").select(\"transaction_number\").gte(\"created_at\", \"\".concat(today.toISOString().slice(0, 10), \"T00:00:00.000Z\")).lt(\"created_at\", \"\".concat(today.toISOString().slice(0, 10), \"T23:59:59.999Z\"));\n        const counter = ((transactions === null || transactions === void 0 ? void 0 : transactions.length) || 0) + 1;\n        return \"\".concat(dateStr).concat(counter.toString().padStart(3, \"0\"));\n    } catch (e) {\n        return \"\".concat(Date.now());\n    }\n}\n// =============================\n// Fungsi helper Stock Management\n// =============================\nasync function checkServiceStock(serviceId) {\n    const { data, error } = await supabase.from(\"services\").select(\"stock\").eq(\"id\", serviceId).single();\n    return error ? 0 : (data === null || data === void 0 ? void 0 : data.stock) || 0;\n}\nasync function reduceServiceStock(serviceId, quantity) {\n    const { data: currentService, error: fetchError } = await supabase.from(\"services\").select(\"stock\").eq(\"id\", serviceId).single();\n    if (fetchError) return {\n        data: null,\n        error: fetchError\n    };\n    const currentStock = currentService.stock || 0;\n    const newStock = Math.max(0, currentStock - quantity);\n    const { data, error } = await supabase.from(\"services\").update({\n        stock: newStock\n    }).eq(\"id\", serviceId).select(\"stock\").single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateServiceStock(serviceId, newStock) {\n    const { data, error } = await supabase.from(\"services\").update({\n        stock: newStock,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", serviceId).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// Fungsi helper Points System\n// =============================\nasync function getUsersWithPoints(branchId) {\n    console.log(\"[v1] getUsersWithPoints called with branchId:\", branchId);\n    let usersQuery = supabase.from(\"users\").select(\"*, branches:branch_id(name)\").order(\"name\");\n    if (branchId && branchId !== \"all\") {\n        usersQuery = usersQuery.eq(\"branch_id\", branchId);\n    }\n    const { data: users, error: usersError } = await usersQuery;\n    if (usersError) return {\n        data: [],\n        error: usersError\n    };\n    if (!users) return {\n        data: [],\n        error: null\n    };\n    const { data: allPoints, error: pointsError } = await supabase.from(\"points\").select(\"user_id, points_earned, created_at\");\n    if (pointsError) return {\n        data: [],\n        error: pointsError\n    };\n    const usersWithCalculatedPoints = users.map((user)=>{\n        const userPoints = (allPoints === null || allPoints === void 0 ? void 0 : allPoints.filter((point)=>point.user_id === user.id)) || [];\n        const totalPoints = userPoints.reduce((sum, point)=>sum + (point.points_earned || 0), 0);\n        const currentMonth = new Date().getMonth();\n        const currentYear = new Date().getFullYear();\n        const monthlyPoints = userPoints.reduce((sum, point)=>{\n            const pointDate = new Date(point.created_at);\n            if (pointDate.getMonth() === currentMonth && pointDate.getFullYear() === currentYear) {\n                return sum + (point.points_earned || 0);\n            }\n            return sum;\n        }, 0);\n        return {\n            ...user,\n            total_points: totalPoints,\n            monthly_points: monthlyPoints\n        };\n    });\n    const sortedUsers = usersWithCalculatedPoints.sort((a, b)=>(b.total_points || 0) - (a.total_points || 0)).map((user, index)=>({\n            ...user,\n            rank: index + 1\n        }));\n    console.log(\"[v1] Final sorted users:\", sortedUsers);\n    return {\n        data: sortedUsers,\n        error: null\n    };\n}\nasync function getPointsStatistics(branchId) {\n    const { data: users, error } = await getUsersWithPoints(branchId);\n    if (error) return {\n        data: null,\n        error\n    };\n    const totalEmployees = users.length;\n    const topPerformer = users[0] || null;\n    const totalPoints = users.reduce((sum, user)=>sum + (user.total_points || 0), 0);\n    const averagePoints = totalEmployees > 0 ? Math.round(totalPoints / totalEmployees) : 0;\n    return {\n        data: {\n            totalEmployees,\n            topPerformer,\n            averagePoints,\n            totalPoints\n        },\n        error: null\n    };\n}\nasync function getPointTransactions(branchId) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n    console.log(\"[v3 Final] getPointTransactions called with branchId:\", branchId);\n    try {\n        // First, get point transactions\n        let query = supabase.from(\"points\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        }).limit(limit);\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: [],\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                // No users in this branch, return empty\n                console.log(\"No users found in branch:\", branchId);\n                return {\n                    data: [],\n                    error: null\n                };\n            }\n        }\n        const { data: pointsData, error } = await query;\n        if (error) {\n            console.error(\"Error fetching point transactions:\", error);\n            console.error(\"Error details:\", JSON.stringify(error, null, 2));\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            return {\n                data: [],\n                error\n            };\n        }\n        if (!pointsData || pointsData.length === 0) {\n            console.log(\"No point transactions found\");\n            return {\n                data: [],\n                error: null\n            };\n        }\n        // Get user details for all points\n        const userIds = [\n            ...new Set(pointsData.map((p)=>p.user_id).filter(Boolean))\n        ];\n        let usersMap = {};\n        if (userIds.length > 0) {\n            const { data: users } = await supabase.from(\"users\").select(\"id, name, branch_id\").in(\"id\", userIds);\n            if (users) {\n                usersMap = users.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Get all unique branch_ids\n        const branchIds = [\n            ...new Set(Object.values(usersMap).map((u)=>u.branch_id).filter(Boolean))\n        ];\n        // Fetch branch details\n        let branchesMap = {};\n        if (branchIds.length > 0) {\n            const { data: branches } = await supabase.from(\"branches\").select(\"id, name\").in(\"id\", branchIds);\n            if (branches) {\n                branchesMap = branches.reduce((acc, b)=>({\n                        ...acc,\n                        [b.id]: b\n                    }), {});\n            }\n        }\n        // Merge user and branch info into points\n        const enrichedData = pointsData === null || pointsData === void 0 ? void 0 : pointsData.map((point)=>{\n            var _usersMap_point_user_id;\n            return {\n                ...point,\n                users: point.user_id ? {\n                    ...usersMap[point.user_id],\n                    branches: ((_usersMap_point_user_id = usersMap[point.user_id]) === null || _usersMap_point_user_id === void 0 ? void 0 : _usersMap_point_user_id.branch_id) ? branchesMap[usersMap[point.user_id].branch_id] : null\n                } : null\n            };\n        });\n        console.log(\"Point transactions fetched successfully:\", (enrichedData === null || enrichedData === void 0 ? void 0 : enrichedData.length) || 0, \"records\");\n        return {\n            data: enrichedData || [],\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Unexpected error in getPointTransactions:\", error);\n        return {\n            data: [],\n            error: error\n        };\n    }\n}\nasync function addPointTransaction(pointData) {\n    const { data, error } = await supabase.from(\"points\").insert([\n        {\n            ...pointData,\n            created_at: new Date().toISOString()\n        }\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getUserPoints(userId) {\n    const { data, error } = await supabase.from(\"points\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Kasbon Functions\n// =============================\nasync function getKasbonRequests(branchId, statusFilter) {\n    console.log(\"[v0] getKasbonRequests called with:\", {\n        branchId,\n        statusFilter\n    });\n    try {\n        // First, get kasbon requests\n        let query = supabase.from(\"kasbon\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        });\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: [],\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                console.log(\"No users found in branch:\", branchId);\n                return {\n                    data: [],\n                    error: null\n                };\n            }\n        }\n        if (statusFilter && statusFilter !== \"all\") {\n            query = query.eq(\"status\", statusFilter);\n        }\n        const { data: kasbonData, error } = await query;\n        if (error) {\n            console.error(\"[v0] Kasbon requests error:\", error);\n            return {\n                data: [],\n                error\n            };\n        }\n        if (!kasbonData || kasbonData.length === 0) {\n            console.log(\"[v0] No kasbon requests found\");\n            return {\n                data: [],\n                error: null\n            };\n        }\n        // Get user details\n        const userIds = [\n            ...new Set(kasbonData.map((k)=>k.user_id).filter(Boolean))\n        ];\n        let usersMap = {};\n        if (userIds.length > 0) {\n            const { data: users } = await supabase.from(\"users\").select(\"id, name, email, position, branch_id\").in(\"id\", userIds);\n            if (users) {\n                usersMap = users.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Get approver details\n        const approverIds = [\n            ...new Set(kasbonData.map((k)=>k.approved_by).filter(Boolean))\n        ];\n        let approversMap = {};\n        if (approverIds.length > 0) {\n            const { data: approvers } = await supabase.from(\"users\").select(\"id, name\").in(\"id\", approverIds);\n            if (approvers) {\n                approversMap = approvers.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Merge user and approver info\n        const enrichedData = kasbonData.map((kasbon)=>({\n                ...kasbon,\n                user: kasbon.user_id ? usersMap[kasbon.user_id] : null,\n                approver: kasbon.approved_by ? approversMap[kasbon.approved_by] : null\n            }));\n        console.log(\"[v0] Kasbon requests result:\", (enrichedData === null || enrichedData === void 0 ? void 0 : enrichedData.length) || 0, \"records\");\n        return {\n            data: enrichedData || [],\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[v0] Unexpected error in getKasbonRequests:\", error);\n        return {\n            data: [],\n            error: error\n        };\n    }\n}\nasync function getKasbonStatistics(branchId) {\n    console.log(\"[v0] getKasbonStatistics called with branchId:\", branchId);\n    try {\n        let query = supabase.from(\"kasbon\").select(\"amount, status, user_id\");\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: {\n                        pendingAmount: 0,\n                        approvedAmount: 0,\n                        totalPaid: 0,\n                        activeEmployees: 0\n                    },\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                return {\n                    data: {\n                        pendingAmount: 0,\n                        approvedAmount: 0,\n                        totalPaid: 0,\n                        activeEmployees: 0\n                    },\n                    error: null\n                };\n            }\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.log(\"[v0] Error fetching kasbon statistics:\", error);\n            return {\n                data: {\n                    pendingAmount: 0,\n                    approvedAmount: 0,\n                    totalPaid: 0,\n                    activeEmployees: 0\n                },\n                error\n            };\n        }\n        const pendingAmount = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"pending\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const approvedAmount = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"approved\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const totalPaid = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"paid\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const { data: usersData } = await supabase.from(\"users\").select(\"id\").eq(\"status\", \"active\");\n        const activeEmployees = (usersData === null || usersData === void 0 ? void 0 : usersData.length) || 0;\n        const statistics = {\n            pendingAmount,\n            approvedAmount,\n            totalPaid,\n            activeEmployees\n        };\n        console.log(\"[v0] Kasbon statistics result:\", statistics);\n        return {\n            data: statistics,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[v0] Unexpected error in getKasbonStatistics:\", error);\n        return {\n            data: {\n                pendingAmount: 0,\n                approvedAmount: 0,\n                totalPaid: 0,\n                activeEmployees: 0\n            },\n            error: error\n        };\n    }\n}\nasync function getUsersWithKasbon(branchId) {\n    console.log(\"[v0] getUsersWithKasbon called with branchId:\", branchId);\n    let query = supabase.from(\"users\").select(\"*\").order(\"name\");\n    if (branchId && branchId !== \"all\") {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data: users, error: usersError } = await query;\n    if (usersError) return {\n        data: [],\n        error: usersError\n    };\n    const { data: allKasbon, error: kasbonError } = await supabase.from(\"kasbon\").select(\"*\").order(\"created_at\", {\n        ascending: false\n    });\n    if (kasbonError) {\n        console.log(\"[v0] Kasbon error, returning users without kasbon data:\", kasbonError);\n        const usersWithoutKasbon = (users === null || users === void 0 ? void 0 : users.map((user)=>({\n                ...user,\n                total_kasbon: 0,\n                active_kasbon: 0,\n                kasbon_history: []\n            }))) || [];\n        return {\n            data: usersWithoutKasbon,\n            error: null\n        };\n    }\n    const usersWithKasbonData = (users === null || users === void 0 ? void 0 : users.map((user)=>{\n        const userKasbon = (allKasbon === null || allKasbon === void 0 ? void 0 : allKasbon.filter((kasbon)=>kasbon.user_id === user.id)) || [];\n        const totalKasbon = userKasbon.reduce((sum, kasbon)=>sum + (kasbon.amount || 0), 0);\n        const activeKasbon = userKasbon.filter((kasbon)=>kasbon.status === \"approved\" || kasbon.status === \"pending\").reduce((sum, kasbon)=>sum + (kasbon.amount || 0), 0);\n        return {\n            ...user,\n            total_kasbon: totalKasbon,\n            active_kasbon: activeKasbon,\n            kasbon_history: userKasbon\n        };\n    })) || [];\n    console.log(\"[v0] Users with kasbon data:\", usersWithKasbonData);\n    return {\n        data: usersWithKasbonData,\n        error: null\n    };\n}\nasync function createKasbonRequest(kasbonData) {\n    console.log(\"[v0] createKasbonRequest called with:\", kasbonData);\n    // Get user name for snapshot\n    const { data: user, error: userError } = await supabase.from(\"users\").select(\"name\").eq(\"id\", kasbonData.user_id).single();\n    if (userError) {\n        console.error(\"[createKasbonRequest] Error getting user name:\", userError);\n        return {\n            data: null,\n            error: userError\n        };\n    }\n    const kasbonToInsert = {\n        ...kasbonData,\n        user_name: (user === null || user === void 0 ? void 0 : user.name) || \"Unknown\",\n        status: \"pending\",\n        request_date: new Date().toISOString(),\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"kasbon\").insert([\n        kasbonToInsert\n    ]).select().single();\n    console.log(\"[v0] Create kasbon result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateKasbonStatus(kasbonId, status, approvedBy) {\n    console.log(\"[v0] updateKasbonStatus called with:\", {\n        kasbonId,\n        status,\n        approvedBy\n    });\n    const updateData = {\n        status,\n        updated_at: new Date().toISOString()\n    };\n    if (status === \"approved\") {\n        updateData.approved_by = approvedBy;\n        updateData.approved_at = new Date().toISOString();\n    }\n    const { data, error } = await supabase.from(\"kasbon\").update(updateData).eq(\"id\", kasbonId).select().single();\n    console.log(\"[v0] Update kasbon status result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// FUNGSI SEDERHANA: HITUNG HARI TIDAK HADIR\n// =============================\nasync function getEmployeeAbsenceInfo(employeeId) {\n    console.log(\"[SIMPLE] getEmployeeAbsenceInfo called for:\", employeeId);\n    try {\n        // 1. Get employee data termasuk settingan libur\n        const { data: employee, error: empError } = await supabase.from(\"users\").select(\"max_absent_days\").eq(\"id\", employeeId).single();\n        if (empError || !employee) {\n            console.error(\"Error getting employee:\", empError);\n            return {\n                maxAbsentDays: 4,\n                currentAbsentDays: 0,\n                remainingDays: 4,\n                excessDays: 0\n            };\n        }\n        // 2. Hitung hari tidak hadir bulan ini\n        const currentDate = new Date();\n        const firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);\n        const lastDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);\n        const { data: attendanceData, error: attendanceError } = await supabase.from(\"attendance\").select(\"status, date\").eq(\"user_id\", employeeId).gte(\"date\", firstDayOfMonth.toISOString().split('T')[0]).lte(\"date\", lastDayOfMonth.toISOString().split('T')[0]);\n        if (attendanceError) {\n            console.error(\"Error getting attendance data:\", attendanceError);\n            return {\n                maxAbsentDays: employee.max_absent_days || 4,\n                currentAbsentDays: 0,\n                remainingDays: employee.max_absent_days || 4,\n                excessDays: 0\n            };\n        }\n        // Hitung hari tidak hadir (status absent atau tidak ada data attendance)\n        const currentAbsentDays = (attendanceData === null || attendanceData === void 0 ? void 0 : attendanceData.filter((record)=>record.status === \"absent\" || record.status === null).length) || 0;\n        const maxAbsentDays = employee.max_absent_days || 4;\n        const remainingDays = Math.max(0, maxAbsentDays - currentAbsentDays);\n        const excessDays = Math.max(0, currentAbsentDays - maxAbsentDays);\n        console.log(\"[SIMPLE] Absence info:\", {\n            maxAbsentDays,\n            currentAbsentDays,\n            remainingDays,\n            excessDays\n        });\n        return {\n            maxAbsentDays,\n            currentAbsentDays,\n            remainingDays,\n            excessDays\n        };\n    } catch (error) {\n        console.error(\"Error in getEmployeeAbsenceInfo:\", error);\n        return {\n            maxAbsentDays: 4,\n            currentAbsentDays: 0,\n            remainingDays: 4,\n            excessDays: 0\n        };\n    }\n}\n// =============================\n// FUNGSI UPDATE JUMLAH HARI LIBUR\n// =============================\nasync function updateMaxAbsentDays(employeeId, maxDays) {\n    try {\n        const { data, error } = await supabase.from(\"users\").update({\n            max_absent_days: maxDays\n        }).eq(\"id\", employeeId).select().single();\n        if (error) {\n            console.error(\"Error updating max absent days:\", error);\n            return {\n                error\n            };\n        }\n        console.log(\"Max absent days updated:\", data);\n        return {\n            data\n        };\n    } catch (error) {\n        console.error(\"Exception updating max absent days:\", error);\n        return {\n            error\n        };\n    }\n}\n// =============================\n// Employee Management Functions\n// =============================\nasync function getEmployees() {\n    console.log(\"[MODERN] getEmployees called - fetching all employees including inactive\");\n    const { data: users, error: usersError } = await supabase.from(\"users\").select(\"\\n      id,\\n      name,\\n      email,\\n      phone,\\n      position,\\n      status,\\n      created_at,\\n      salary,\\n      commission_rate,\\n      max_absent_days,\\n      pin,\\n      rating,\\n      attendanceRate,\\n      currentMonthCustomers,\\n      totalCustomers,\\n      presentDays,\\n      totalWorkDays,\\n      lateDays,\\n      overtimeHours,\\n      overtimeRate,\\n      bonusPoints,\\n      penaltyPoints,\\n      kasbonBalance,\\n      kasbonLimit,\\n      monthlyRevenue\\n    \").order(\"name\"); // Tampilkan SEMUA karyawan (aktif dan tidak aktif)\n    console.log(\"[MODERN] Result:\", {\n        usersCount: users === null || users === void 0 ? void 0 : users.length,\n        hasError: !!usersError,\n        firstUser: users === null || users === void 0 ? void 0 : users[0]\n    });\n    // PENTING: Hanya return error jika benar-benar ada error DAN tidak ada data\n    if (usersError && !users) {\n        console.error(\"[MODERN] Error fetching employees:\", usersError);\n        return {\n            data: [],\n            error: usersError\n        };\n    }\n    // Transformasi data - gunakan data dari database\n    const employees = (users || []).map((user)=>({\n            id: user.id,\n            name: user.name,\n            email: user.email || '',\n            phone: user.phone || '',\n            position: user.position || '',\n            status: user.status || 'active',\n            salary: user.salary || 3000000,\n            baseSalary: user.salary || 3000000,\n            commissionRate: user.commission_rate || 0,\n            pin: user.pin || '',\n            max_absent_days: user.max_absent_days || 4,\n            created_at: user.created_at,\n            totalBonus: 0,\n            totalPenalty: 0,\n            rating: user.rating || 0,\n            attendanceRate: user.attendanceRate || 0,\n            currentMonthCustomers: user.currentMonthCustomers || 0,\n            totalCustomers: user.totalCustomers || 0,\n            presentDays: user.presentDays || 0,\n            totalWorkDays: user.totalWorkDays || 0,\n            lateDays: user.lateDays || 0,\n            overtimeHours: user.overtimeHours || 0,\n            overtimeRate: user.overtimeRate || 0,\n            bonusPoints: user.bonusPoints || 0,\n            penaltyPoints: user.penaltyPoints || 0,\n            kasbonBalance: user.kasbonBalance || 0,\n            kasbonLimit: user.kasbonLimit || 0,\n            monthlyRevenue: String(user.monthlyRevenue || '0')\n        }));\n    console.log(\"[MODERN] Final employees:\", employees.length);\n    return {\n        data: employees,\n        error: null\n    };\n}\nasync function addEmployee(employee) {\n    console.log(\"[v11] addEmployee called with:\", employee);\n    // Just create user profile in users table\n    // Admin will manually create auth user in Supabase Dashboard if needed\n    const userData = {\n        name: employee.name,\n        email: employee.email,\n        phone: employee.phone || null,\n        status: employee.status || \"active\",\n        pin: employee.pin,\n        position: employee.position,\n        salary: employee.salary || employee.baseSalary || 0,\n        commission_rate: employee.commissionRate || 0\n    };\n    const { data, error } = await supabase.from(\"users\").insert([\n        userData\n    ]).select().single();\n    console.log(\"[v11] addEmployee result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function updateEmployee(id, employee) {\n    console.log(\"[v11] updateEmployee called with:\", id);\n    const userData = {\n        name: employee.name,\n        email: employee.email,\n        phone: employee.phone,\n        status: employee.status,\n        pin: employee.pin,\n        position: employee.position,\n        salary: employee.baseSalary,\n        commission_rate: employee.commissionRate\n    };\n    const { data, error } = await supabase.from(\"users\").update(userData).eq(\"id\", id).select().single();\n    console.log(\"[v11] updateEmployee result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function deleteEmployee(id) {\n    console.log(\"[deleteEmployee] Starting deletion for id:\", id);\n    try {\n        // Cek apakah user ada\n        const { data: existingUser, error: checkError } = await supabase.from(\"users\").select(\"*\").eq(\"id\", id).single();\n        if (checkError) {\n            console.error(\"[deleteEmployee] Error checking user:\", checkError);\n            return {\n                data: null,\n                error: checkError\n            };\n        }\n        if (!existingUser) {\n            console.error(\"[deleteEmployee] User not found\");\n            return {\n                data: null,\n                error: {\n                    message: \"Karyawan tidak ditemukan\"\n                }\n            };\n        }\n        console.log(\"[deleteEmployee] User exists:\", existingUser);\n        // SOFT DELETE - ubah status jadi 'inactive' agar data tetap ada untuk transaksi\n        const { data, error } = await supabase.from(\"users\").update({\n            status: 'inactive'\n        }).eq(\"id\", id).select().single();\n        console.log(\"[deleteEmployee] Soft delete response:\", {\n            data,\n            error\n        });\n        if (error) {\n            console.error(\"[deleteEmployee] Soft delete error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"[deleteEmployee] Soft delete successful - status changed to inactive\");\n        return {\n            data,\n            error: null\n        };\n    } catch (e) {\n        console.error(\"[deleteEmployee] Exception:\", e);\n        return {\n            data: null,\n            error: {\n                message: String(e)\n            }\n        };\n    }\n}\n// =============================\n// PERBAIKAN FUNGSI GET EMPLOYEE STATS\n// =============================\nasync function getEmployeeStats(employeeId) {\n    console.log(\"[v13-FIXED] getEmployeeStats called for:\", employeeId);\n    try {\n        // 1. Hitung transaksi dan revenue - gunakan server_id (yang melayani), bukan cashier_id\n        const { data: transactions, error: transactionsError } = await supabase.from(\"transactions\").select(\"total_amount, created_at\").eq(\"server_id\", employeeId).gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n        if (transactionsError) {\n            console.error(\"[v13-FIXED] Error fetching transactions:\", transactionsError);\n        }\n        const totalTransactions = (transactions === null || transactions === void 0 ? void 0 : transactions.length) || 0;\n        const totalRevenue = (transactions === null || transactions === void 0 ? void 0 : transactions.reduce((sum, t)=>sum + (t.total_amount || 0), 0)) || 0;\n        const averageTransaction = totalTransactions > 0 ? totalRevenue / totalTransactions : 0;\n        // 2. Hitung komisi dari commission_amount yang sudah tersimpan di transaction_items\n        let totalCommission = 0;\n        try {\n            console.log(\"[getEmployeeStats] Calculating commission for employee:\", employeeId);\n            const { data: commissionData, error: commissionError } = await supabase.from(\"transaction_items\").select(\"commission_amount, commission_status\").eq(\"barber_id\", employeeId).eq(\"commission_status\", \"credited\").gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n            if (!commissionError && commissionData) {\n                totalCommission = commissionData.reduce((sum, item)=>{\n                    return sum + (item.commission_amount || 0);\n                }, 0);\n                console.log(\"[getEmployeeStats] Commission items found:\", commissionData.length, \"Total:\", totalCommission);\n            } else if (commissionError) {\n                console.error(\"[v13-FIXED] Error calculating commission:\", commissionError);\n            }\n        } catch (commissionError) {\n            console.error(\"[v13-FIXED] Unexpected error calculating commission:\", commissionError);\n            totalCommission = 0;\n        }\n        // 3. Hitung points untuk bonus/penalty\n        const { data: pointsData, error: pointsError } = await supabase.from(\"points\").select(\"points_earned, points_type\").eq(\"user_id\", employeeId).gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n        let bonusPoints = 0;\n        let penaltyPoints = 0;\n        if (!pointsError && pointsData) {\n            pointsData.forEach((point)=>{\n                if (point.points_earned > 0) {\n                    bonusPoints += point.points_earned;\n                } else {\n                    penaltyPoints += Math.abs(point.points_earned);\n                }\n            });\n        }\n        const stats = {\n            totalTransactions,\n            totalRevenue,\n            totalCommission,\n            averageTransaction,\n            bonusPoints,\n            penaltyPoints,\n            totalBonus: bonusPoints,\n            totalPenalty: penaltyPoints\n        };\n        console.log(\"[v13-FIXED] Employee stats:\", stats);\n        return stats;\n    } catch (error) {\n        console.error(\"[v13-FIXED] Unexpected error in getEmployeeStats:\", error);\n        // Return default stats jika terjadi error\n        return {\n            totalTransactions: 0,\n            totalRevenue: 0,\n            totalCommission: 0,\n            averageTransaction: 0,\n            bonusPoints: 0,\n            penaltyPoints: 0,\n            totalBonus: 0,\n            totalPenalty: 0\n        };\n    }\n}\nasync function getEmployeeCommissions(employeeId) {\n    console.log(\"[v12-FIXED] getEmployeeCommissions (now rules) called for:\", employeeId);\n    const { data, error } = await supabase.from(\"commission_rules\").select(\"*, services (name, price)\").eq(\"user_id\", employeeId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) {\n        console.error(\"[v12-FIXED] Error fetching commission rules:\", error);\n    }\n    console.log(\"[v12-FIXED] Employee commission rules result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// PERBAIKAN FUNGSI GET EMPLOYEE ATTENDANCE\n// =============================\nasync function getEmployeeAttendance(employeeId) {\n    console.log(\"[v13-FIXED] getEmployeeAttendance called for:\", employeeId);\n    try {\n        const currentMonth = new Date().getMonth();\n        const currentYear = new Date().getFullYear();\n        const firstDayOfMonth = new Date(currentYear, currentMonth, 1);\n        const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);\n        const { data, error } = await supabase.from(\"attendance\").select(\"*\").eq(\"user_id\", employeeId).gte(\"date\", firstDayOfMonth.toISOString().split('T')[0]).lte(\"date\", lastDayOfMonth.toISOString().split('T')[0]).order(\"date\", {\n            ascending: true\n        });\n        if (error) {\n            console.error(\"[v13-FIXED] Error fetching attendance:\", error);\n            return {\n                data: [],\n                error,\n                attendanceRate: 0,\n                presentDays: 0,\n                lateDays: 0,\n                overtimeHours: 0,\n                totalWorkDays: 0\n            };\n        }\n        const totalWorkDays = getBusinessDaysCount(firstDayOfMonth, lastDayOfMonth);\n        const presentDays = data.filter((record)=>record.status === \"checked_out\" || record.status === \"checked_in\").length;\n        const lateDays = data.filter((record)=>{\n            if (!record.check_in_time) return false;\n            const checkInTime = record.check_in_time;\n            return checkInTime > \"08:30:00\";\n        }).length;\n        const totalHours = data.reduce((sum, record)=>sum + (record.total_hours || 0), 0);\n        const regularHours = presentDays * 8;\n        const overtimeHours = Math.max(0, totalHours - regularHours);\n        const attendanceRate = totalWorkDays > 0 ? Math.round(presentDays / totalWorkDays * 100) : 0;\n        console.log(\"[v13-FIXED] Employee attendance result:\", {\n            totalWorkDays,\n            presentDays,\n            lateDays,\n            overtimeHours: Math.max(0, overtimeHours),\n            attendanceRate\n        });\n        return {\n            data: data || [],\n            error: null,\n            attendanceRate,\n            presentDays,\n            lateDays,\n            overtimeHours: Math.max(0, overtimeHours),\n            totalWorkDays\n        };\n    } catch (error) {\n        console.error(\"[v13-FIXED] Unexpected error in getEmployeeAttendance:\", error);\n        return {\n            data: [],\n            error: error,\n            attendanceRate: 0,\n            presentDays: 0,\n            lateDays: 0,\n            overtimeHours: 0,\n            totalWorkDays: 0\n        };\n    }\n}\n// =============================\n// ðŸ”¥ FUNGSI BARU YANG DITAMBAHKAN - getEmployeePhotos\n// =============================\nasync function getEmployeePhotos(userId) {\n    console.log(\"[getEmployeePhotos] Called with userId:\", userId);\n    try {\n        const { data, error } = await supabase.from(\"attendance\").select(\"\\n        *,\\n        users:user_id ( id, name, email, position, branch_id ),\\n        branches:branch_id ( id, name, address )\\n      \").eq(\"user_id\", userId).or(\"check_in_photo.not.is.null,check_out_photo.not.is.null\").order(\"date\", {\n            ascending: false\n        }).order(\"created_at\", {\n            ascending: false\n        }).limit(50);\n        console.log(\"[getEmployeePhotos] Query result:\", {\n            data,\n            error\n        });\n        if (error) {\n            console.error(\"[getEmployeePhotos] Error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        const attendanceWithDetails = (data || []).map((record)=>({\n                id: record.id,\n                user_id: record.user_id,\n                branch_id: record.branch_id,\n                shift_type: record.shift_type,\n                check_in_time: record.check_in_time,\n                check_out_time: record.check_out_time,\n                break_start_time: record.break_start_time,\n                break_end_time: record.break_end_time,\n                total_hours: record.total_hours,\n                break_duration: record.break_duration,\n                status: record.status,\n                check_in_photo: record.check_in_photo,\n                check_out_photo: record.check_out_photo,\n                date: record.date,\n                created_at: record.created_at,\n                updated_at: record.updated_at,\n                users: record.users ? {\n                    id: record.users.id,\n                    name: record.users.name,\n                    email: record.users.email,\n                    position: record.users.position,\n                    branch_id: record.users.branch_id,\n                    created_at: record.users.created_at || new Date().toISOString()\n                } : undefined,\n                branches: record.branches ? {\n                    id: record.branches.id,\n                    name: record.branches.name,\n                    address: record.branches.address,\n                    created_at: record.branches.created_at || new Date().toISOString()\n                } : undefined\n            }));\n        console.log(\"[getEmployeePhotos] Returning:\", attendanceWithDetails.length, \"records\");\n        return {\n            data: attendanceWithDetails,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[getEmployeePhotos] Exception:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// =============================\n// ðŸ”¥ FUNGSI BARU YANG DITAMBAHKAN - getEmployeeAttendanceWithPhotos\n// =============================\nasync function getEmployeeAttendanceWithPhotos(userId) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    console.log(\"[getEmployeeAttendanceWithPhotos] Called with userId:\", userId, \"days:\", days);\n    try {\n        const endDate = new Date();\n        const startDate = new Date();\n        startDate.setDate(endDate.getDate() - days);\n        const startDateStr = startDate.toISOString().split('T')[0];\n        const endDateStr = endDate.toISOString().split('T')[0];\n        console.log(\"[getEmployeeAttendanceWithPhotos] Date range:\", startDateStr, \"to\", endDateStr);\n        const { data, error } = await supabase.from(\"attendance\").select(\"\\n        *,\\n        users:user_id ( id, name, email, position, branch_id ),\\n        branches:branch_id ( id, name, address )\\n      \").eq(\"user_id\", userId).gte(\"date\", startDateStr).lte(\"date\", endDateStr).order(\"date\", {\n            ascending: false\n        }).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"[getEmployeeAttendanceWithPhotos] Query result:\", {\n            dataLength: data === null || data === void 0 ? void 0 : data.length,\n            error\n        });\n        // Ignore empty error objects\n        if (error === null || error === void 0 ? void 0 : error.message) {\n            console.error(\"[getEmployeeAttendanceWithPhotos] Error:\", error);\n            return {\n                data: [],\n                error,\n                attendanceRate: 0,\n                presentDays: 0,\n                lateDays: 0,\n                totalWorkDays: days,\n                overtimeHours: 0\n            };\n        }\n        const attendanceRecords = (data || []).map((record)=>({\n                id: record.id,\n                user_id: record.user_id,\n                branch_id: record.branch_id,\n                shift_type: record.shift_type,\n                check_in_time: record.check_in_time,\n                check_out_time: record.check_out_time,\n                break_start_time: record.break_start_time,\n                break_end_time: record.break_end_time,\n                total_hours: record.total_hours,\n                break_duration: record.break_duration,\n                status: record.status,\n                check_in_photo: record.check_in_photo,\n                check_out_photo: record.check_out_photo,\n                date: record.date,\n                created_at: record.created_at,\n                updated_at: record.updated_at,\n                users: record.users ? {\n                    id: record.users.id,\n                    name: record.users.name,\n                    email: record.users.email,\n                    position: record.users.position,\n                    branch_id: record.users.branch_id,\n                    created_at: record.users.created_at || new Date().toISOString()\n                } : undefined,\n                branches: record.branches ? {\n                    id: record.branches.id,\n                    name: record.branches.name,\n                    address: record.branches.address,\n                    created_at: record.branches.created_at || new Date().toISOString()\n                } : undefined\n            }));\n        const presentDays = attendanceRecords.filter((r)=>r.status !== 'absent' && (r.check_in_time || r.check_out_time)).length;\n        const lateDays = attendanceRecords.filter((r)=>{\n            if (!r.check_in_time) return false;\n            const checkInTime = r.check_in_time;\n            return checkInTime > \"08:30\";\n        }).length;\n        const totalHours = attendanceRecords.reduce((sum, r)=>sum + (r.total_hours || 0), 0);\n        const regularHours = presentDays * 8;\n        const overtimeHours = Math.max(0, totalHours - regularHours);\n        const attendanceRate = days > 0 ? Math.round(presentDays / days * 100) : 0;\n        console.log(\"[getEmployeeAttendanceWithPhotos] Statistics:\", {\n            attendanceRate,\n            presentDays,\n            lateDays,\n            totalWorkDays: days,\n            overtimeHours: Math.round(overtimeHours * 100) / 100\n        });\n        return {\n            data: attendanceRecords,\n            error: null,\n            attendanceRate,\n            presentDays,\n            lateDays,\n            totalWorkDays: days,\n            overtimeHours: Math.round(overtimeHours * 100) / 100\n        };\n    } catch (error) {\n        console.error(\"[getEmployeeAttendanceWithPhotos] Exception:\", error);\n        return {\n            data: [],\n            error: error,\n            attendanceRate: 0,\n            presentDays: 0,\n            lateDays: 0,\n            totalWorkDays: days,\n            overtimeHours: 0\n        };\n    }\n}\n// =============================\n// Auth Helper Functions\n// =============================\nasync function getCurrentUser() {\n    try {\n        const { data: { user }, error } = await supabase.auth.getUser();\n        console.log(\"[getCurrentUser] Auth user:\", user);\n        console.log(\"[getCurrentUser] Auth error:\", error);\n        if (error) {\n            console.error(\"[getCurrentUser] Error getting current user:\", error);\n            return null;\n        }\n        return user;\n    } catch (error) {\n        console.error(\"[getCurrentUser] Unexpected error:\", error);\n        return null;\n    }\n}\n// Fungsi untuk get profile dari auth data saja\nasync function getAuthUserProfile(userId) {\n    try {\n        const { data: authData } = await supabase.auth.getUser();\n        if (authData.user && authData.user.id === userId) {\n            var _authData_user_email;\n            return {\n                id: authData.user.id,\n                email: authData.user.email || \"\",\n                name: ((_authData_user_email = authData.user.email) === null || _authData_user_email === void 0 ? void 0 : _authData_user_email.split('@')[0]) || \"User\",\n                pin: \"\",\n                position: \"employee\",\n                status: \"active\",\n                created_at: new Date().toISOString()\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[getAuthUserProfile] Error:\", error);\n        return null;\n    }\n}\n// Fungsi untuk create user profile dari auth data\nasync function createUserProfileFromAuth(userId) {\n    try {\n        var _authData_user_email;\n        // Get auth user data\n        const { data: authData, error: authError } = await supabase.auth.admin.getUserById(userId);\n        if (authError || !authData.user) {\n            console.error(\"[createUserProfile] Cannot get auth user:\", authError);\n            return getAuthUserProfile(userId);\n        }\n        // Create user profile\n        const { data: newUser, error: insertError } = await supabase.from('users').insert({\n            id: authData.user.id,\n            email: authData.user.email,\n            name: ((_authData_user_email = authData.user.email) === null || _authData_user_email === void 0 ? void 0 : _authData_user_email.split('@')[0]) || 'User',\n            position: 'employee',\n            status: 'active',\n            created_at: new Date().toISOString()\n        }).select().single();\n        if (insertError) {\n            console.error(\"[createUserProfile] Insert failed, using auth data:\", insertError);\n            return getAuthUserProfile(userId);\n        }\n        console.log(\"[createUserProfile] New user profile created\");\n        return newUser;\n    } catch (error) {\n        console.error(\"[createUserProfile] Error:\", error);\n        return getAuthUserProfile(userId);\n    }\n}\n// =============================\n// Pengeluaran Cabang\n// =============================\nasync function updateExpenseRequest(expenseId, expenseData) {\n    console.log(\"[v0] updateExpenseRequest called with:\", {\n        expenseId,\n        expenseData\n    });\n    const { data, error } = await supabase.from(\"expenses\").update({\n        ...expenseData,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", expenseId).select().single();\n    console.log(\"[v0] Update expense result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function deleteExpenseRequest(expenseId) {\n    console.log(\"[v0] deleteExpenseRequest called with id:\", expenseId);\n    const { data, error } = await supabase.from(\"expenses\").delete().eq(\"id\", expenseId);\n    console.log(\"[v0] Delete expense result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\n// =============================\n// Pengeluaran Cabang - GET\n// =============================\nasync function getExpenses(branchId) {\n    console.log(\"[v0] getExpenses called with branchId:\", branchId);\n    let query = supabase.from(\"expenses\").select(\"\\n      *,\\n      branches!inner (\\n        id,\\n        name\\n      )\\n    \").order(\"expense_date\", {\n        ascending: false\n    });\n    if (branchId) {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data, error } = await query;\n    console.log(\"[v0] Expenses result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Pengeluaran Cabang - STATISTICS\n// =============================\nasync function getExpenseStatistics(branchId) {\n    console.log(\"[v0] getExpenseStatistics called with branchId:\", branchId);\n    let query = supabase.from(\"expenses\").select(\"amount\");\n    if (branchId) {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data, error } = await query;\n    if (error) {\n        console.log(\"[v0] Error fetching expense statistics:\", error);\n        return {\n            data: {\n                totalExpenses: 0,\n                averagePerTransaction: 0\n            },\n            error\n        };\n    }\n    const totalExpenses = (data === null || data === void 0 ? void 0 : data.reduce((sum, expense)=>sum + (expense.amount || 0), 0)) || 0;\n    const transactionCount = (data === null || data === void 0 ? void 0 : data.length) || 0;\n    const averagePerTransaction = transactionCount > 0 ? Math.round(totalExpenses / transactionCount) : 0;\n    const statistics = {\n        totalExpenses,\n        averagePerTransaction\n    };\n    console.log(\"[v0] Expense statistics result:\", statistics);\n    return {\n        data: statistics,\n        error: null\n    };\n}\n// =============================\n// Pengeluaran Cabang - CREATE\n// =============================\nasync function createExpenseRequest(expenseData) {\n    console.log(\"[v0] createExpenseRequest called with:\", expenseData);\n    const expenseToInsert = {\n        branch_id: expenseData.branch_id || null,\n        category: expenseData.category,\n        description: expenseData.description,\n        amount: expenseData.amount,\n        notes: expenseData.notes || null,\n        expense_date: new Date().toISOString().split(\"T\")[0],\n        status: \"pending\",\n        created_at: new Date().toISOString()\n    };\n    console.log(\"Data yang akan diinsert:\", expenseToInsert);\n    const { data, error } = await supabase.from(\"expenses\").insert(expenseToInsert).select().single();\n    console.log(\"[v0] Create expense result:\", {\n        data,\n        error\n    });\n    if (error) {\n        console.error(\"Detail error:\", error);\n    }\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAllExpensesWithDetails() {\n    try {\n        console.log(\"ðŸ” Fetching expenses without users relationship...\");\n        // PASTIKAN hanya select branches saja, tanpa users\n        const { data, error } = await supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*)\\n      \").order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('âŒ Error fetching expenses:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"âœ… Successfully fetched expenses:\", data === null || data === void 0 ? void 0 : data.length);\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\nasync function updateExpenseStatus(expenseId, status, rejectionReason) {\n    try {\n        console.log(\"ðŸ”„ Updating expense status:\", {\n            expenseId,\n            status,\n            rejectionReason\n        });\n        // Update status dan rejection_reason jika ada\n        const updateData = {\n            status,\n            updated_at: new Date().toISOString()\n        };\n        // Tambahkan rejection_reason jika status rejected\n        if (status === \"rejected\" && rejectionReason) {\n            updateData.rejection_reason = rejectionReason;\n        }\n        // Clear rejection_reason jika status approved/paid\n        if (status === \"approved\" || status === \"paid\") {\n            updateData.rejection_reason = null;\n        }\n        const { data, error } = await supabase.from('expenses').update(updateData).eq('id', expenseId).select('*').single();\n        if (error) {\n            console.error('âŒ Error updating expense status:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"âœ… Expense status updated successfully\");\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\nasync function getExpenseStatisticsByBranch(branchId) {\n    try {\n        let query = supabase.from('expenses').select('status, amount');\n        if (branchId && branchId !== 'all') {\n            query = query.eq('branch_id', branchId);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Error fetching expense statistics:', error);\n            return {\n                total: 0,\n                pending: 0,\n                approved: 0,\n                rejected: 0,\n                paid: 0,\n                totalAmount: 0,\n                pendingAmount: 0,\n                approvedAmount: 0,\n                rejectedAmount: 0,\n                paidAmount: 0\n            };\n        }\n        const stats = {\n            total: (data === null || data === void 0 ? void 0 : data.length) || 0,\n            pending: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'pending').length) || 0,\n            approved: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'approved').length) || 0,\n            rejected: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'rejected').length) || 0,\n            paid: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'paid').length) || 0,\n            totalAmount: (data === null || data === void 0 ? void 0 : data.reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            pendingAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'pending').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            approvedAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'approved').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            rejectedAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'rejected').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            paidAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'paid').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0\n        };\n        return stats;\n    } catch (error) {\n        console.error('Unexpected error in getExpenseStatisticsByBranch:', error);\n        return {\n            total: 0,\n            pending: 0,\n            approved: 0,\n            rejected: 0,\n            paid: 0,\n            totalAmount: 0,\n            pendingAmount: 0,\n            approvedAmount: 0,\n            rejectedAmount: 0,\n            paidAmount: 0\n        };\n    }\n}\nasync function getExpensesByStatus(status, branchId) {\n    try {\n        let query = supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*),\\n        users:requested_by (*)\\n      \").eq('status', status).order('created_at', {\n            ascending: false\n        });\n        if (branchId && branchId !== 'all') {\n            query = query.eq('branch_id', branchId);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error(\"Error fetching \".concat(status, \" expenses:\"), error);\n            return {\n                data: [],\n                error\n            };\n        }\n        return {\n            data: data || [],\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error:', error);\n        return {\n            data: [],\n            error\n        };\n    }\n}\n// =============================\n// Additional Functions\n// =============================\nasync function getAbsentEmployeesToday() {\n    console.log(\"[v0] getAbsentEmployeesToday called\");\n    const today = new Date().toISOString().split(\"T\")[0];\n    try {\n        const { data: activeEmployees, error: employeesError } = await supabase.from(\"users\").select(\"*\").eq(\"status\", \"active\").order(\"name\");\n        if (employeesError) {\n            console.error(\"[v0] Error fetching active employees:\", employeesError);\n            return [];\n        }\n        const { data: todayAttendance, error: attendanceError } = await supabase.from(\"attendance\").select(\"user_id\").eq(\"date\", today);\n        if (attendanceError) {\n            console.error(\"[v0] Error fetching today's attendance:\", attendanceError);\n            return [];\n        }\n        const presentEmployeeIds = new Set((todayAttendance === null || todayAttendance === void 0 ? void 0 : todayAttendance.map((a)=>a.user_id)) || []);\n        const absentEmployees = (activeEmployees === null || activeEmployees === void 0 ? void 0 : activeEmployees.filter((employee)=>!presentEmployeeIds.has(employee.id))) || [];\n        const transformedAbsentEmployees = absentEmployees.map((user)=>({\n                id: user.id,\n                name: user.name,\n                email: user.email || \"\",\n                phone: user.phone || \"\",\n                position: user.position || \"employee\",\n                status: user.status || \"active\",\n                avatar: \"/placeholder.svg?height=40&width=40&query=\".concat(encodeURIComponent(user.name)),\n                rating: 4.5,\n                baseSalary: 5000000,\n                attendanceRate: 95,\n                currentMonthCustomers: 0,\n                totalCustomers: 0,\n                presentDays: 0,\n                totalWorkDays: 0,\n                lateDays: 0,\n                overtimeHours: 0,\n                overtimeRate: 25000,\n                bonusPoints: 0,\n                penaltyPoints: 0,\n                commissionRate: 0.05,\n                joinDate: user.created_at,\n                kasbonBalance: 0,\n                kasbonLimit: 2000000,\n                monthlyRevenue: \"0\",\n                pin: user.pin || \"\"\n            }));\n        console.log(\"[v0] Found absent employees:\", transformedAbsentEmployees.length);\n        return transformedAbsentEmployees;\n    } catch (error) {\n        console.error(\"[v0] Error in getAbsentEmployeesToday:\", error);\n        return [];\n    }\n}\n// =============================\n// Attendance Management Functions\n// =============================\nasync function getDetailedAttendanceRecords(date) {\n    let query = supabase.from(\"attendance\").select(\"*,\\n      users:user_id (\\n        id,\\n        name,\\n        email,\\n        position,\\n        branch_id\\n      ),\\n      branches:branch_id (\\n        id,\\n        name,\\n        address,\\n        shifts\\n      )\\n    \").order(\"date\", {\n        ascending: false\n    }).order(\"created_at\", {\n        ascending: false\n    });\n    if (date) {\n        query = query.eq(\"date\", date);\n    }\n    const { data, error } = await query;\n    if (error) {\n        console.error(\"[v0] Error fetching detailed attendance:\", error);\n        return {\n            data: [],\n            error\n        };\n    }\n    return {\n        data: data || [],\n        error: null\n    };\n}\n// ðŸ”¥ GET stock per outlet\nconst getOutletStock = async (outletId)=>{\n    try {\n        const { data, error } = await supabase.from('outlet_stock').select('*').eq('outlet_id', outletId).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('Error fetching outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in getOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ UPDATE stock per outlet (with UPSERT)\nconst updateOutletStock = async (outletId, serviceId, newStock)=>{\n    try {\n        // Use upsert to create if not exists, update if exists\n        const { data, error } = await supabase.from('outlet_stock').upsert({\n            outlet_id: outletId,\n            service_id: serviceId,\n            stock_quantity: newStock,\n            is_active: true,\n            min_stock_threshold: 5,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: 'outlet_id,service_id'\n        }).select().single();\n        if (error) {\n            console.error('Error updating outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in updateOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ GET low stock alerts (FIXED VERSION)\nconst getLowStockAlerts = async ()=>{\n    try {\n        // Get all outlet stock (no joins needed)\n        const { data: allStock, error: fetchError } = await supabase.from('outlet_stock').select('*').eq('is_active', true);\n        if (fetchError) {\n            console.error('Error fetching outlet stock:', fetchError);\n            return {\n                data: null,\n                error: fetchError\n            };\n        }\n        // Filter manually for low stock\n        const lowStock = (allStock || []).filter((item)=>item.stock_quantity <= item.min_stock_threshold);\n        return {\n            data: lowStock,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in getLowStockAlerts:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ REDUCE stock ketika terjadi transaksi\n// ðŸ”¥ REDUCE stock ketika terjadi transaksi (FIXED)\nconst reduceOutletStock = async (outletId, serviceId, quantity)=>{\n    try {\n        // Get current stock\n        const { data: currentStock, error: fetchError } = await supabase.from('outlet_stock').select('stock_quantity').eq('outlet_id', outletId).eq('service_id', serviceId).single();\n        if (fetchError) {\n            console.error('Error fetching current stock:', fetchError);\n            return {\n                data: null,\n                error: fetchError\n            };\n        }\n        const newStock = Math.max(0, ((currentStock === null || currentStock === void 0 ? void 0 : currentStock.stock_quantity) || 0) - quantity);\n        // Update stock\n        const { data, error } = await supabase.from('outlet_stock').update({\n            stock_quantity: newStock,\n            updated_at: new Date().toISOString()\n        }).eq('outlet_id', outletId).eq('service_id', serviceId).select(\"\\n        *,\\n        service:services(*, service_categories(*)),\\n        branch:outlet_id(*)\\n      \").single();\n        if (error) {\n            console.error('Error reducing outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in reduceOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// =============================\n// POS Helper Functions\n// =============================\nconst loadBranchesData = async (supabase, setBranches, setSelectedBranch)=>{\n    const { data, error } = await supabase.from(\"branches\").select(\"*\");\n    if (error) {\n        console.error(\"Error loading branches:\", error);\n        return;\n    }\n    setBranches(data);\n    if (data.length > 0) {\n        setSelectedBranch(data[0].name);\n    }\n};\nconst loadBranchData = async (supabase, setReceiptTemplate, setBranchInfo)=>{\n    console.log(\"[v0] Loading branch and template data...\");\n    try {\n        const { data: templateData, error: templateError } = await supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_active\", true).single();\n        if (templateError) {\n            console.error(\"Error loading receipt template:\", templateError);\n        } else {\n            console.log(\"[v0] Loaded active template:\", templateData);\n            setReceiptTemplate(templateData);\n        }\n        console.log(\"[v0] Branch data loading completed without overriding selectedBranch\");\n    } catch (error) {\n        console.error(\"Error loading branch and template data:\", error);\n    }\n};\nconst processTransaction = async (supabase, branches, selectedBranch, cart, currentUser, paymentMethod, customerName, discountReason, getTotalPrice, getDiscountAmount, getFinalTotal)=>{\n    const selectedBranchData = branches.find((b)=>b.name === selectedBranch);\n    if (!(selectedBranchData === null || selectedBranchData === void 0 ? void 0 : selectedBranchData.id)) {\n        throw new Error(\"Data cabang tidak ditemukan\");\n    }\n    const receiptNumber = \"\".concat(new Date().getFullYear()).concat(String(new Date().getMonth() + 1).padStart(2, \"0\")).concat(String(new Date().getDate()).padStart(2, \"0\")).concat(String(Math.floor(Math.random() * 1000)).padStart(3, \"0\"));\n    const transactionData = {\n        receipt_number: receiptNumber,\n        branch_id: selectedBranchData.id,\n        total_amount: getTotalPrice(),\n        discount_amount: getDiscountAmount(),\n        final_amount: getFinalTotal(),\n        payment_method: paymentMethod,\n        customer_name: customerName || null,\n        notes: discountReason || null\n    };\n    console.log(\"[v0] Creating transaction with correct branch_id:\", transactionData);\n    return transactionData;\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Setup Realtime Subscription untuk Transaksi\n// =============================\nconst setupTransactionsRealtime = (callback)=>{\n    const channel = supabase.channel('transactions-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'transactions'\n    }, (payload)=>{\n        console.log('Transaction change detected:', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'transaction_items'\n    }, (payload)=>{\n        console.log('Transaction item change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Realtime subscription status:', status);\n    });\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Setup Realtime untuk Komisi\nconst setupKomisiRealtime = (callback)=>{\n    const channel = supabase.channel('komisi-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'commission_rules'\n    }, (payload)=>{\n        console.log('Commission rule change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Komisi subscription status:', status);\n    });\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Broadcast Event untuk Sinkronisasi Global\nconst broadcastTransactionEvent = async (eventType, payload)=>{\n    try {\n        await supabase.channel('global-events').send({\n            type: 'broadcast',\n            event: eventType,\n            payload: payload\n        });\n        console.log(\"Broadcast event '\".concat(eventType, \"' sent successfully\"));\n    } catch (error) {\n        console.error('Error broadcasting event:', error);\n    }\n};\n// ðŸ”¥ FUNGSI BARU: Listen untuk Global Events\nconst setupGlobalEventsListener = (callback)=>{\n    const channel = supabase.channel('global-events-listener').on('broadcast', {\n        event: '*'\n    }, (payload)=>{\n        console.log('Global event received:', payload);\n        callback(payload.event, payload.payload);\n    }).subscribe();\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Subscribe to Events\nconst subscribeToEvents = (callback)=>{\n    const channel = supabase.channel('global-events-listener').on('broadcast', {\n        event: '*'\n    }, (payload)=>{\n        console.log('Global event received:', payload);\n        callback(payload.event, payload.payload);\n    }).subscribe();\n    return channel;\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Setup Realtime Subscription untuk Employee\n// =============================\nconst setupEmployeeRealtime = (callback)=>{\n    console.log(\"Setting up employee realtime subscription\");\n    const channel = supabase.channel('employees-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'users'\n    }, (payload)=>{\n        console.log('Employee change detected:', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'points'\n    }, (payload)=>{\n        console.log('Points change detected (affects employee stats):', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'attendance'\n    }, (payload)=>{\n        console.log('Attendance change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Employee realtime subscription status:', status);\n    });\n    return channel;\n};\nasync function getApprovedExpenses() {\n    try {\n        console.log(\"ðŸ” Fetching approved expenses...\");\n        const { data, error } = await supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*)\\n      \").in('status', [\n            'approved',\n            'paid'\n        ]).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('âŒ Error fetching approved expenses:', error);\n            return {\n                data: [],\n                error\n            };\n        }\n        console.log(\"âœ… Successfully fetched approved expenses:\", data === null || data === void 0 ? void 0 : data.length);\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: [],\n            error\n        };\n    }\n}\n// ðŸ”¥ TAMBAHKAN fungsi ini di supabase.ts\nconst getOwnerPin = async ()=>{\n    try {\n        const { data, error } = await supabase.from('users').select('pin').eq('position', 'owner').single();\n        if (error || !data) {\n            console.error('Error fetching owner PIN:', error);\n            return ''; // Return empty string if not found\n        }\n        return data.pin || '';\n    } catch (error) {\n        console.error('Unexpected error in getOwnerPin:', error);\n        return '';\n    }\n};\n// ðŸ”¥ TAMBAHKAN fungsi ini di supabase.ts\nconst updateUserPin = async (userId, newPin)=>{\n    try {\n        // Validasi PIN 6 digit\n        if (newPin.length !== 6 || !/^\\d+$/.test(newPin)) {\n            console.error('Invalid PIN format');\n            return false;\n        }\n        const { error } = await supabase.from('users').update({\n            pin: newPin\n        }).eq('id', userId);\n        if (error) {\n            console.error('Error updating PIN:', error);\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error('Unexpected error in updateUserPin:', error);\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdXBhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUVwRCxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxNQUFNQyxjQUFjQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHdCQUF3QixJQUFJO0FBQzVELE1BQU1DLGtCQUNKSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLDZCQUE2QixJQUN6QztBQUVGLElBQUksQ0FBQ0wsYUFBYTtJQUNoQixNQUFNLElBQUlNLE1BQU07QUFDbEI7QUFDQSxJQUFJLENBQUNGLGlCQUFpQjtJQUNwQixNQUFNLElBQUlFLE1BQU07QUFDbEI7QUFFTyxNQUFNQyxXQUFXUixtRUFBWUEsQ0FBQ0MsYUFBYUksaUJBQWlCO0lBQ2pFSSxNQUFNO1FBQ0pDLGdCQUFnQjtRQUNoQkMsa0JBQWtCO0lBQ3BCO0lBQ0FDLFVBQVU7UUFDUkMsUUFBUTtZQUNOQyxpQkFBaUI7UUFDbkI7SUFDRjtJQUNBQyxRQUFRO1FBQ05DLFNBQVM7WUFDUCxzQkFBc0I7UUFDeEI7SUFDRjtBQUNGLEdBQUc7QUFFSSxNQUFNQyx5QkFBeUI7SUFDcEMsSUFBSTtRQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUFTWSxJQUFJLENBQUMsVUFBVUMsTUFBTSxDQUFDO1FBQzdELElBQUlGLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsT0FBTztRQUNUO1FBQ0FHLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE9BQU87SUFDVCxFQUFFLE9BQU9KLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUNELGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLFNBQVNLLHFCQUFxQkMsU0FBZSxFQUFFQyxPQUFhO0lBQ3hELElBQUlDLFFBQVE7SUFDWixNQUFNQyxVQUFVLElBQUlDLEtBQUtKLFVBQVVLLE9BQU87SUFFMUMsTUFBT0YsV0FBV0YsUUFBUztRQUN2QixNQUFNSyxZQUFZSCxRQUFRSSxNQUFNO1FBQ2hDLDREQUE0RDtRQUM1RCxJQUFJRCxjQUFjLEtBQUtBLGNBQWMsR0FBRztZQUNwQ0o7UUFDSjtRQUNBQyxRQUFRSyxPQUFPLENBQUNMLFFBQVFNLE9BQU8sS0FBSztJQUN4QztJQUVBLE9BQU9QO0FBQ1g7QUF5Uk8sZUFBZVEsZ0JBQWdCQyxRQUFnQjtJQUNwRGQsUUFBUUMsR0FBRyxDQUFDLDhDQUE4Q2E7SUFFMUQsTUFBTSxFQUFFbEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLGlCQUNMQyxNQUFNLENBQUMsS0FDUGdCLEVBQUUsQ0FBQyxhQUFhRCxVQUNoQkMsRUFBRSxDQUFDLGFBQWEsTUFDaEJDLEtBQUssQ0FBQztJQUVUaEIsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QjtRQUFFTDtRQUFNQztJQUFNO0lBRXhELElBQUlBLFNBQVMsQ0FBQ0QsUUFBUUEsS0FBS3FCLE1BQU0sS0FBSyxHQUFHO1FBQ3ZDakIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBTztZQUNMTCxNQUFNO2dCQUNKO29CQUNFc0IsSUFBSSxnQkFBeUIsT0FBVEo7b0JBQ3BCSyxXQUFXTDtvQkFDWE0sWUFBWTtvQkFDWkMsWUFBWTtvQkFDWkMsWUFBWTtvQkFDWkMsVUFBVTtvQkFDVkMsV0FBVztvQkFDWEMsWUFBWSxJQUFJbEIsT0FBT21CLFdBQVc7Z0JBQ3BDO2dCQUNBO29CQUNFUixJQUFJLGlCQUEwQixPQUFUSjtvQkFDckJLLFdBQVdMO29CQUNYTSxZQUFZO29CQUNaQyxZQUFZO29CQUNaQyxZQUFZO29CQUNaQyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxZQUFZLElBQUlsQixPQUFPbUIsV0FBVztnQkFDcEM7Z0JBQ0E7b0JBQ0VSLElBQUksaUJBQTBCLE9BQVRKO29CQUNyQkssV0FBV0w7b0JBQ1hNLFlBQVk7b0JBQ1pDLFlBQVk7b0JBQ1pDLFlBQVk7b0JBQ1pDLFVBQVU7b0JBQ1ZDLFdBQVc7b0JBQ1hDLFlBQVksSUFBSWxCLE9BQU9tQixXQUFXO2dCQUNwQzthQUNEO1lBQ0Q3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87UUFBRUQ7UUFBTUMsT0FBTztJQUFLO0FBQzdCO0FBRU8sZUFBZThCLGtCQUFrQkMsU0FBaUQ7SUFDdkY1QixRQUFRQyxHQUFHLENBQUMsdUNBQXVDMkI7SUFFbkQsTUFBTUMsZ0JBQWdCO1FBQ3BCLEdBQUdELFNBQVM7UUFDWkgsWUFBWSxJQUFJbEIsT0FBT21CLFdBQVc7SUFDcEM7SUFFQSxNQUFNLEVBQUU5QixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxpQkFBaUJnQyxNQUFNLENBQUM7UUFBQ0Q7S0FBYyxFQUFFOUIsTUFBTSxHQUFHZ0MsTUFBTTtJQUVwRy9CLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0M7UUFBRUw7UUFBTUM7SUFBTTtJQUM5RCxPQUFPQSxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQUVBLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ3pCLGVBQWVtQyxzQkFBc0JDLE1BQWMsRUFBRUMsUUFBZ0I7SUFDMUUsSUFBSTtRQUNGLFNBQVNDLGFBQWFDLFVBQWtCO2dCQUFFQyxjQUFBQSxpRUFBYztZQUN0RCxNQUFNQyxpQkFBaUJDLEtBQUtILFdBQVdJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNwRCxNQUFNQyxhQUFhLEVBQUU7WUFDckIsSUFBSyxJQUFJQyxTQUFTLEdBQUdBLFNBQVNKLGVBQWVyQixNQUFNLEVBQUV5QixVQUFVLElBQUs7Z0JBQ2xFLE1BQU1DLFFBQVFMLGVBQWVLLEtBQUssQ0FBQ0QsUUFBUUEsU0FBUztnQkFDcEQsTUFBTUUsY0FBYyxJQUFJQyxNQUFNRixNQUFNMUIsTUFBTTtnQkFDMUMsSUFBSyxJQUFJNkIsSUFBSSxHQUFHQSxJQUFJSCxNQUFNMUIsTUFBTSxFQUFFNkIsSUFBS0YsV0FBVyxDQUFDRSxFQUFFLEdBQUdILE1BQU1JLFVBQVUsQ0FBQ0Q7Z0JBQ3pFTCxXQUFXTyxJQUFJLENBQUMsSUFBSUMsV0FBV0w7WUFDakM7WUFDQSxPQUFPLElBQUlNLEtBQUtULFlBQVk7Z0JBQUVVLE1BQU1kO1lBQVk7UUFDbEQ7UUFFQSxNQUFNZSxPQUFPakIsYUFBYUY7UUFDMUIsTUFBTSxFQUFFcEMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU21FLE9BQU8sQ0FBQ3ZELElBQUksQ0FBQyxxQkFBcUJ3RCxNQUFNLENBQUNwQixVQUFVa0IsTUFBTTtZQUN4RkcsY0FBYztZQUNkQyxRQUFRO1lBQ1JuQixhQUFhO1FBQ2Y7UUFDQSxJQUFJeEMsT0FBTyxNQUFNQTtRQUVqQixNQUFNLEVBQUVELE1BQU02RCxhQUFhLEVBQUUsR0FBR3ZFLFNBQVNtRSxPQUFPLENBQUN2RCxJQUFJLENBQUMscUJBQXFCNEQsWUFBWSxDQUFDeEI7UUFDeEYsT0FBT3VCLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZUUsU0FBUyxLQUFJO0lBQ3JDLEVBQUUsT0FBTzlELE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLHdCQUF3QkE7UUFDdEMsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlK0QsdUJBQXVCQyxjQUFtQztJQUM5RSxNQUFNLEVBQUVqRSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxjQUFjZ0MsTUFBTSxDQUFDO1FBQUMrQjtLQUFlLEVBQUU5RCxNQUFNLEdBQUdnQyxNQUFNO0lBQ2xHLE9BQU9sQyxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQUVPLGVBQWVpRSx1QkFBdUI1QyxFQUFVLEVBQUU2QyxPQUE0QjtJQUNuRixNQUFNLEVBQUVuRSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsY0FDTGtFLE1BQU0sQ0FBQztRQUFFLEdBQUdELE9BQU87UUFBRUUsWUFBWSxJQUFJMUQsT0FBT21CLFdBQVc7SUFBRyxHQUMxRFgsRUFBRSxDQUFDLE1BQU1HLElBQ1RuQixNQUFNLEdBQ05nQyxNQUFNO0lBQ1QsT0FBT2xDLFFBQVE7UUFBRUQsTUFBTTtRQUFNQztJQUFNLElBQUk7UUFBRUQ7UUFBTUMsT0FBTztJQUFLO0FBQzdEO0FBRU8sZUFBZXFFLG9CQUFvQkMsTUFBYyxFQUFFQyxJQUFZO0lBQ3BFLE1BQU0sRUFBRXhFLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU1ksSUFBSSxDQUFDLGNBQWNDLE1BQU0sQ0FBQyxLQUFLZ0IsRUFBRSxDQUFDLFdBQVdvRCxRQUFRcEQsRUFBRSxDQUFDLFFBQVFxRCxNQUFNckMsTUFBTTtJQUNuSCxPQUFPbEMsU0FBU0EsTUFBTXdFLElBQUksS0FBSyxhQUFhO1FBQUV6RSxNQUFNO1FBQU1DO0lBQU0sSUFBSTtRQUFFRDtRQUFNQyxPQUFPO0lBQUs7QUFDMUY7QUFFTyxlQUFleUUsd0JBQXdCeEQsUUFBaUI7SUFDN0QsSUFBSXlELFFBQVFyRixTQUNUWSxJQUFJLENBQUMsY0FDTEMsTUFBTSxDQUFFLDZGQUlSaUIsS0FBSyxDQUFDLFFBQVE7UUFBRXdELFdBQVc7SUFBTSxHQUNqQ3hELEtBQUssQ0FBQyxjQUFjO1FBQUV3RCxXQUFXO0lBQU07SUFDMUMsSUFBSTFELFVBQVV5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQzVDLE1BQU0sRUFBRWxCLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTTBFO0lBQzlCLE9BQU8xRSxRQUFRO1FBQUVELE1BQU0sRUFBRTtRQUFFQztJQUFNLElBQUk7UUFBRUQsTUFBTUEsUUFBUSxFQUFFO1FBQUVDLE9BQU87SUFBSztBQUN2RTtBQUVBLGdDQUFnQztBQUNoQyxvQkFBb0I7QUFDcEIsZ0NBQWdDO0FBQ3pCLGVBQWU0RTtJQUNwQixNQUFNLEVBQUU3RSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFFLDREQUdSaUIsS0FBSyxDQUFDO0lBQ1QsT0FBT25CLFFBQVE7UUFBRUQsTUFBTSxFQUFFO1FBQUVDO0lBQU0sSUFBSTtRQUFFRCxNQUFNQSxRQUFRLEVBQUU7UUFBRUMsT0FBTztJQUFLO0FBQ3ZFO0FBRU8sZUFBZTZFO0lBQ3BCLE1BQU0sRUFBRTlFLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU1ksSUFBSSxDQUFDLHNCQUFzQkMsTUFBTSxDQUFDLEtBQUtpQixLQUFLLENBQUM7SUFDcEYsT0FBT25CLFFBQVE7UUFBRUQsTUFBTSxFQUFFO1FBQUVDO0lBQU0sSUFBSTtRQUFFRCxNQUFNQSxRQUFRLEVBQUU7UUFBRUMsT0FBTztJQUFLO0FBQ3ZFO0FBRU8sZUFBZThFLGtCQUFrQkMsZUFBOEM7SUFDcEYsTUFBTUMsb0JBQW9CLE1BQU1DO0lBQ2hDLElBQUksRUFBRUMsVUFBVSxFQUFFNUQsU0FBUyxFQUFFNkQsU0FBUyxFQUFFLEdBQUdKO0lBRTNDLGtEQUFrRDtJQUNsRCxJQUFJSyxjQUFjO0lBQ2xCLElBQUlDLGFBQWE7SUFDakIsSUFBSUM7SUFFSixJQUFJLENBQUNKLFlBQVk7UUFDZixNQUFNLEVBQUVuRixNQUFNd0YsS0FBSyxFQUFFLEdBQUcsTUFBTWxHLFNBQVNZLElBQUksQ0FBQyxTQUFTQyxNQUFNLENBQUMsWUFBWXNGLEtBQUssQ0FBQyxHQUFHdEQsTUFBTTtRQUN2RmdELGFBQWFLLGtCQUFBQSw0QkFBQUEsTUFBT2xFLEVBQUU7UUFDdEIrRCxjQUFjRyxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9FLElBQUksS0FBSTtJQUMvQixPQUFPO1FBQ0wsTUFBTSxFQUFFMUYsTUFBTTJGLE9BQU8sRUFBRSxHQUFHLE1BQU1yRyxTQUFTWSxJQUFJLENBQUMsU0FBU0MsTUFBTSxDQUFDLFFBQVFnQixFQUFFLENBQUMsTUFBTWdFLFlBQVloRCxNQUFNO1FBQ2pHa0QsY0FBY00sQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTRCxJQUFJLEtBQUk7SUFDakM7SUFFQSxJQUFJLENBQUNuRSxXQUFXO1FBQ2QsTUFBTSxFQUFFdkIsTUFBTTRGLFFBQVEsRUFBRSxHQUFHLE1BQU10RyxTQUFTWSxJQUFJLENBQUMsWUFBWUMsTUFBTSxDQUFDLFlBQVlzRixLQUFLLENBQUMsR0FBR3RELE1BQU07UUFDN0ZaLFlBQVlxRSxxQkFBQUEsK0JBQUFBLFNBQVV0RSxFQUFFO1FBQ3hCZ0UsYUFBYU0sQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVRixJQUFJLEtBQUk7SUFDakMsT0FBTztRQUNMLE1BQU0sRUFBRTFGLE1BQU02RixNQUFNLEVBQUUsR0FBRyxNQUFNdkcsU0FBU1ksSUFBSSxDQUFDLFlBQVlDLE1BQU0sQ0FBQyxRQUFRZ0IsRUFBRSxDQUFDLE1BQU1JLFdBQVdZLE1BQU07UUFDbEdtRCxhQUFhTyxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFILElBQUksS0FBSTtJQUMvQjtJQUVBLElBQUlOLFdBQVc7UUFDYixNQUFNLEVBQUVwRixNQUFNOEYsTUFBTSxFQUFFLEdBQUcsTUFBTXhHLFNBQVNZLElBQUksQ0FBQyxTQUFTQyxNQUFNLENBQUMsUUFBUWdCLEVBQUUsQ0FBQyxNQUFNaUUsV0FBV2pELE1BQU07UUFDL0ZvRCxhQUFhTyxtQkFBQUEsNkJBQUFBLE9BQVFKLElBQUk7SUFDM0I7SUFFQSxNQUFNSyxzQkFBc0I7UUFDMUIsR0FBR2YsZUFBZTtRQUNsQmdCLG9CQUFvQmY7UUFDcEJnQixnQkFBZ0JoQjtRQUNoQkU7UUFDQWUsY0FBY2I7UUFDZDlEO1FBQ0E0RSxhQUFhYjtRQUNiRjtRQUNBZ0IsYUFBYWI7UUFDYmMsVUFBVXJCLGdCQUFnQnFCLFFBQVEsSUFBSXJCLGdCQUFnQnNCLFlBQVksSUFBSTtRQUN0RUMsZ0JBQWdCdkIsZ0JBQWdCdUIsY0FBYyxJQUFJO1FBQ2xEQyxnQkFBZ0J4QixnQkFBZ0J3QixjQUFjLElBQUk7UUFDbERGLGNBQWN0QixnQkFBZ0JzQixZQUFZLElBQUk7UUFDOUNHLGlCQUFpQnpCLGdCQUFnQnlCLGVBQWUsSUFBSTtRQUNwRDVFLFlBQVksSUFBSWxCLE9BQU9tQixXQUFXO0lBQ3BDO0lBRUEsTUFBTSxFQUFFOUIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUFTWSxJQUFJLENBQUMsZ0JBQWdCZ0MsTUFBTSxDQUFDO1FBQUM2RDtLQUFvQixFQUFFNUYsTUFBTSxHQUFHZ0MsTUFBTTtJQUN6RyxPQUFPbEMsUUFBUTtRQUFFRCxNQUFNO1FBQU1DO0lBQU0sSUFBSTtRQUFFRDtRQUFNQyxPQUFPO0lBQUs7QUFDN0Q7QUFFTyxlQUFleUcsdUJBQXVCQyxLQUFpQztJQUM1RSxrREFBa0Q7SUFDbEQsTUFBTUMsZ0JBQWdCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0gsTUFBTUksR0FBRyxDQUFDLE9BQU9DO1FBQ3ZELElBQUlBLEtBQUtDLFVBQVUsRUFBRTtnQkFXQ0M7WUFWcEIsTUFBTSxFQUFFbEgsTUFBTWtILE9BQU8sRUFBRSxHQUFHLE1BQU01SCxTQUM3QlksSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyx3Q0FDUGdCLEVBQUUsQ0FBQyxNQUFNNkYsS0FBS0MsVUFBVSxFQUN4QjlFLE1BQU07WUFFVCxPQUFPO2dCQUNMLEdBQUc2RSxJQUFJO2dCQUNQRyxjQUFjRCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVN4QixJQUFJLEtBQUk7Z0JBQy9CMEIsWUFBWSxFQUFFRixvQkFBQUEsOEJBQUFBLFFBQVMzRCxJQUFJO2dCQUMzQjhELGdCQUFnQixFQUFFSCxvQkFBQUEsK0JBQUFBLDhCQUFBQSxRQUFTSSxrQkFBa0IsY0FBM0JKLGtEQUFBQSw0QkFBNkJ4QixJQUFJO1lBQ3JEO1FBQ0Y7UUFDQSxPQUFPc0I7SUFDVDtJQUVBLE1BQU0sRUFBRWhILElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU1ksSUFBSSxDQUFDLHFCQUFxQmdDLE1BQU0sQ0FBQzBFLGVBQWV6RyxNQUFNO0lBQzdGLE9BQU9GLFFBQVE7UUFBRUQsTUFBTSxFQUFFO1FBQUVDO0lBQU0sSUFBSTtRQUFFRCxNQUFNQSxRQUFRLEVBQUU7UUFBRUMsT0FBTztJQUFLO0FBQ3ZFO0FBRU8sZUFBZXNILG1CQUFtQnJHLFFBQWlCO0lBQ3hELElBQUl5RCxRQUFRckYsU0FBU1ksSUFBSSxDQUFDLHFCQUFxQkMsTUFBTSxDQUFDO0lBQ3RELElBQUllLFVBQVV5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQzVDLE1BQU0sRUFBRWxCLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTTBFLE1BQU14QyxNQUFNO0lBQzFDLE9BQU9sQyxTQUFTQSxNQUFNd0UsSUFBSSxLQUFLLGFBQWE7UUFBRXpFLE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUMxRjtBQUVPLGVBQWV1SCx5QkFBeUJ0RyxRQUFpQjtJQUM5RCw0REFBNEQ7SUFDNUQsSUFBSXlELFFBQVFyRixTQUFTWSxJQUFJLENBQUMscUJBQXFCQyxNQUFNLENBQUMsS0FBS2dCLEVBQUUsQ0FBQyxhQUFhO0lBQzNFLElBQUlELFVBQVV5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQzVDLE1BQU0sRUFBRWxCLE1BQU15SCxVQUFVLEVBQUV4SCxPQUFPeUgsV0FBVyxFQUFFLEdBQUcsTUFBTS9DLE1BQU14QyxNQUFNO0lBRW5FLElBQUlzRixjQUFjLENBQUNDLGFBQWE7UUFDOUIsT0FBTztZQUFFMUgsTUFBTXlIO1lBQVl4SCxPQUFPO1FBQUs7SUFDekM7SUFFQSw4RUFBOEU7SUFDOUUsSUFBSTBILGVBQWVySSxTQUFTWSxJQUFJLENBQUMscUJBQXFCQyxNQUFNLENBQUMsS0FBS2dCLEVBQUUsQ0FBQyxjQUFjO0lBQ25GLElBQUlELFVBQVV5RyxlQUFlQSxhQUFheEcsRUFBRSxDQUFDLGFBQWFEO0lBQzFELE1BQU0sRUFBRWxCLE1BQU00SCxXQUFXLEVBQUUzSCxPQUFPNEgsWUFBWSxFQUFFLEdBQUcsTUFBTUYsYUFBYXhGLE1BQU07SUFFNUUsSUFBSXlGLGVBQWUsQ0FBQ0MsY0FBYztRQUNoQyxPQUFPO1lBQUU3SCxNQUFNNEg7WUFBYTNILE9BQU87UUFBSztJQUMxQztJQUVBLHVDQUF1QztJQUN2QyxPQUFPLE1BQU1zSCxtQkFBbUJyRztBQUNsQztBQUVPLGVBQWU0RztJQUNwQixNQUFNLEVBQUU5SCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxZQUFZQyxNQUFNLENBQUMsS0FBS2lCLEtBQUssQ0FBQztJQUMxRSxPQUFPbkIsUUFBUTtRQUFFRCxNQUFNLEVBQUU7UUFBRUM7SUFBTSxJQUFJO1FBQUVELE1BQU1BLFFBQVEsRUFBRTtRQUFFQyxPQUFPO0lBQUs7QUFDdkU7QUFFTyxlQUFlaUY7SUFDcEIsSUFBSTtRQUNGLE1BQU0sRUFBRWxGLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU3lJLEdBQUcsQ0FBQztRQUMzQyxJQUFJLENBQUM5SCxTQUFTRCxNQUFNLE9BQU9BO1FBRTNCLE1BQU1nSSxRQUFRLElBQUlySDtRQUNsQixNQUFNc0gsVUFBVUQsTUFBTWxHLFdBQVcsR0FBR2lCLEtBQUssQ0FBQyxHQUFHLElBQUltRixPQUFPLENBQUMsTUFBTTtRQUMvRCxNQUFNLEVBQUVsSSxNQUFNbUksWUFBWSxFQUFFLEdBQUcsTUFBTTdJLFNBQ2xDWSxJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBQyxzQkFDUGlJLEdBQUcsQ0FBQyxjQUFjLEdBQW9DLE9BQWpDSixNQUFNbEcsV0FBVyxHQUFHaUIsS0FBSyxDQUFDLEdBQUcsS0FBSSxtQkFDdERzRixFQUFFLENBQUMsY0FBYyxHQUFvQyxPQUFqQ0wsTUFBTWxHLFdBQVcsR0FBR2lCLEtBQUssQ0FBQyxHQUFHLEtBQUk7UUFDeEQsTUFBTXVGLFVBQVUsQ0FBQ0gsQ0FBQUEseUJBQUFBLG1DQUFBQSxhQUFjOUcsTUFBTSxLQUFJLEtBQUs7UUFDOUMsT0FBTyxHQUFhaUgsT0FBVkwsU0FBOEMsT0FBcENLLFFBQVFDLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUc7SUFDckQsRUFBRSxVQUFNO1FBQ04sT0FBTyxHQUFjLE9BQVg3SCxLQUFLOEgsR0FBRztJQUNwQjtBQUNGO0FBRUEsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDekIsZUFBZUMsa0JBQWtCQyxTQUFpQjtJQUN2RCxNQUFNLEVBQUUzSSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxZQUFZQyxNQUFNLENBQUMsU0FBU2dCLEVBQUUsQ0FBQyxNQUFNd0gsV0FBV3hHLE1BQU07SUFDbEcsT0FBT2xDLFFBQVEsSUFBSUQsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNNEksS0FBSyxLQUFJO0FBQ3BDO0FBRU8sZUFBZUMsbUJBQW1CRixTQUFpQixFQUFFRyxRQUFnQjtJQUMxRSxNQUFNLEVBQUU5SSxNQUFNK0ksY0FBYyxFQUFFOUksT0FBTytJLFVBQVUsRUFBRSxHQUFHLE1BQU0xSixTQUN2RFksSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyxTQUNQZ0IsRUFBRSxDQUFDLE1BQU13SCxXQUNUeEcsTUFBTTtJQUNULElBQUk2RyxZQUFZLE9BQU87UUFBRWhKLE1BQU07UUFBTUMsT0FBTytJO0lBQVc7SUFFdkQsTUFBTUMsZUFBZUYsZUFBZUgsS0FBSyxJQUFJO0lBQzdDLE1BQU1NLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSCxlQUFlSDtJQUU1QyxNQUFNLEVBQUU5SSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsWUFDTGtFLE1BQU0sQ0FBQztRQUFFd0UsT0FBT007SUFBUyxHQUN6Qi9ILEVBQUUsQ0FBQyxNQUFNd0gsV0FDVHhJLE1BQU0sQ0FBQyxTQUNQZ0MsTUFBTTtJQUNULE9BQU9sQyxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQUVPLGVBQWVvSixtQkFBbUJWLFNBQWlCLEVBQUVPLFFBQWdCO0lBQzFFLE1BQU0sRUFBRWxKLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FDM0JZLElBQUksQ0FBQyxZQUNMa0UsTUFBTSxDQUFDO1FBQUV3RSxPQUFPTTtRQUFVN0UsWUFBWSxJQUFJMUQsT0FBT21CLFdBQVc7SUFBRyxHQUMvRFgsRUFBRSxDQUFDLE1BQU13SCxXQUNUeEksTUFBTSxHQUNOZ0MsTUFBTTtJQUNULE9BQU9sQyxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQUVBLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ3pCLGVBQWVxSixtQkFBbUJwSSxRQUFpQjtJQUN4RGQsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRGE7SUFFN0QsSUFBSXFJLGFBQWFqSyxTQUFTWSxJQUFJLENBQUMsU0FBU0MsTUFBTSxDQUFDLCtCQUErQmlCLEtBQUssQ0FBQztJQUNwRixJQUFJRixZQUFZQSxhQUFhLE9BQU87UUFDbENxSSxhQUFhQSxXQUFXcEksRUFBRSxDQUFDLGFBQWFEO0lBQzFDO0lBRUEsTUFBTSxFQUFFbEIsTUFBTXdGLEtBQUssRUFBRXZGLE9BQU91SixVQUFVLEVBQUUsR0FBRyxNQUFNRDtJQUNqRCxJQUFJQyxZQUFZLE9BQU87UUFBRXhKLE1BQU0sRUFBRTtRQUFFQyxPQUFPdUo7SUFBVztJQUNyRCxJQUFJLENBQUNoRSxPQUFPLE9BQU87UUFBRXhGLE1BQU0sRUFBRTtRQUFFQyxPQUFPO0lBQUs7SUFFM0MsTUFBTSxFQUFFRCxNQUFNeUosU0FBUyxFQUFFeEosT0FBT3lKLFdBQVcsRUFBRSxHQUFHLE1BQU1wSyxTQUNuRFksSUFBSSxDQUFDLFVBQ0xDLE1BQU0sQ0FBQztJQUNWLElBQUl1SixhQUFhLE9BQU87UUFBRTFKLE1BQU0sRUFBRTtRQUFFQyxPQUFPeUo7SUFBWTtJQUV2RCxNQUFNQyw0QkFBNEJuRSxNQUFNdUIsR0FBRyxDQUFDLENBQUM2QztRQUMzQyxNQUFNQyxhQUFhSixDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdLLE1BQU0sQ0FBQyxDQUFDQyxRQUFVQSxNQUFNQyxPQUFPLEtBQUtKLEtBQUt0SSxFQUFFLE1BQUssRUFBRTtRQUNoRixNQUFNMkksY0FBY0osV0FBV0ssTUFBTSxDQUFDLENBQUNDLEtBQUtKLFFBQVVJLE1BQU9KLENBQUFBLE1BQU1LLGFBQWEsSUFBSSxJQUFJO1FBRXhGLE1BQU1DLGVBQWUsSUFBSTFKLE9BQU8ySixRQUFRO1FBQ3hDLE1BQU1DLGNBQWMsSUFBSTVKLE9BQU82SixXQUFXO1FBRTFDLE1BQU1DLGdCQUFnQlosV0FBV0ssTUFBTSxDQUFDLENBQUNDLEtBQUtKO1lBQzVDLE1BQU1XLFlBQVksSUFBSS9KLEtBQUtvSixNQUFNbEksVUFBVTtZQUMzQyxJQUFJNkksVUFBVUosUUFBUSxPQUFPRCxnQkFBZ0JLLFVBQVVGLFdBQVcsT0FBT0QsYUFBYTtnQkFDcEYsT0FBT0osTUFBT0osQ0FBQUEsTUFBTUssYUFBYSxJQUFJO1lBQ3ZDO1lBQ0EsT0FBT0Q7UUFDVCxHQUFHO1FBRUgsT0FBTztZQUNMLEdBQUdQLElBQUk7WUFDUGUsY0FBY1Y7WUFDZFcsZ0JBQWdCSDtRQUNsQjtJQUNGO0lBRUEsTUFBTUksY0FBY2xCLDBCQUNqQm1CLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLENBQUNBLEVBQUVMLFlBQVksSUFBSSxLQUFNSSxDQUFBQSxFQUFFSixZQUFZLElBQUksSUFDMUQ1RCxHQUFHLENBQUMsQ0FBQzZDLE1BQU1xQixRQUFXO1lBQ3JCLEdBQUdyQixJQUFJO1lBQ1BzQixNQUFNRCxRQUFRO1FBQ2hCO0lBRUY3SyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCd0s7SUFDeEMsT0FBTztRQUFFN0ssTUFBTTZLO1FBQWE1SyxPQUFPO0lBQUs7QUFDMUM7QUFFTyxlQUFla0wsb0JBQW9CakssUUFBaUI7SUFDekQsTUFBTSxFQUFFbEIsTUFBTXdGLEtBQUssRUFBRXZGLEtBQUssRUFBRSxHQUFHLE1BQU1xSixtQkFBbUJwSTtJQUV4RCxJQUFJakIsT0FBTyxPQUFPO1FBQUVELE1BQU07UUFBTUM7SUFBTTtJQUV0QyxNQUFNbUwsaUJBQWlCNUYsTUFBTW5FLE1BQU07SUFDbkMsTUFBTWdLLGVBQWU3RixLQUFLLENBQUMsRUFBRSxJQUFJO0lBQ2pDLE1BQU15RSxjQUFjekUsTUFBTTBFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLUCxPQUFTTyxNQUFPUCxDQUFBQSxLQUFLZSxZQUFZLElBQUksSUFBSTtJQUNoRixNQUFNVyxnQkFBZ0JGLGlCQUFpQixJQUFJakMsS0FBS29DLEtBQUssQ0FBQ3RCLGNBQWNtQixrQkFBa0I7SUFFdEYsT0FBTztRQUNMcEwsTUFBTTtZQUNKb0w7WUFDQUM7WUFDQUM7WUFDQXJCO1FBQ0Y7UUFDQWhLLE9BQU87SUFDVDtBQUNGO0FBRU8sZUFBZXVMLHFCQUFxQnRLLFFBQWlCO1FBQUV1RSxRQUFBQSxpRUFBUTtJQUNwRXJGLFFBQVFDLEdBQUcsQ0FBQyx5REFBeURhO0lBRXJFLElBQUk7UUFDRixnQ0FBZ0M7UUFDaEMsSUFBSXlELFFBQVFyRixTQUNUWSxJQUFJLENBQUMsVUFDTEMsTUFBTSxDQUFDLEtBQ1BpQixLQUFLLENBQUMsY0FBYztZQUFFd0QsV0FBVztRQUFNLEdBQ3ZDYSxLQUFLLENBQUNBO1FBRVQsSUFBSXZFLFlBQVlBLGFBQWEsT0FBTztZQUNsQyw2QkFBNkI7WUFDN0IsTUFBTSxFQUFFbEIsTUFBTXlMLGFBQWEsRUFBRXhMLE9BQU91SixVQUFVLEVBQUUsR0FBRyxNQUFNbEssU0FDdERZLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsTUFDUGdCLEVBQUUsQ0FBQyxhQUFhRDtZQUVuQixJQUFJc0ksWUFBWTtnQkFDZHBKLFFBQVFILEtBQUssQ0FBQyxtQ0FBbUN1SjtnQkFDakQsT0FBTztvQkFBRXhKLE1BQU0sRUFBRTtvQkFBRUMsT0FBT3VKO2dCQUFXO1lBQ3ZDO1lBRUEsSUFBSWlDLGlCQUFpQkEsY0FBY3BLLE1BQU0sR0FBRyxHQUFHO2dCQUM3QyxNQUFNcUssVUFBVUQsY0FBYzFFLEdBQUcsQ0FBQzRFLENBQUFBLElBQUtBLEVBQUVySyxFQUFFO2dCQUMzQ3FELFFBQVFBLE1BQU1pSCxFQUFFLENBQUMsV0FBV0Y7WUFDOUIsT0FBTztnQkFDTCx3Q0FBd0M7Z0JBQ3hDdEwsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QmE7Z0JBQ3pDLE9BQU87b0JBQUVsQixNQUFNLEVBQUU7b0JBQUVDLE9BQU87Z0JBQUs7WUFDakM7UUFDRjtRQUVBLE1BQU0sRUFBRUQsTUFBTTZMLFVBQVUsRUFBRTVMLEtBQUssRUFBRSxHQUFHLE1BQU0wRTtRQUUxQyxJQUFJMUUsT0FBTztZQUNURyxRQUFRSCxLQUFLLENBQUMsc0NBQXNDQTtZQUNwREcsUUFBUUgsS0FBSyxDQUFDLGtCQUFrQjZMLEtBQUtDLFNBQVMsQ0FBQzlMLE9BQU8sTUFBTTtZQUM1REcsUUFBUUgsS0FBSyxDQUFDLGVBQWVBLE1BQU13RSxJQUFJO1lBQ3ZDckUsUUFBUUgsS0FBSyxDQUFDLGtCQUFrQkEsTUFBTStMLE9BQU87WUFDN0MsT0FBTztnQkFBRWhNLE1BQU0sRUFBRTtnQkFBRUM7WUFBTTtRQUMzQjtRQUVBLElBQUksQ0FBQzRMLGNBQWNBLFdBQVd4SyxNQUFNLEtBQUssR0FBRztZQUMxQ2pCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87Z0JBQUVMLE1BQU0sRUFBRTtnQkFBRUMsT0FBTztZQUFLO1FBQ2pDO1FBRUEsa0NBQWtDO1FBQ2xDLE1BQU15TCxVQUFVO2VBQUksSUFBSU8sSUFBSUosV0FBVzlFLEdBQUcsQ0FBQ21GLENBQUFBLElBQUtBLEVBQUVsQyxPQUFPLEVBQUVGLE1BQU0sQ0FBQ3FDO1NBQVU7UUFDNUUsSUFBSUMsV0FBZ0MsQ0FBQztRQUVyQyxJQUFJVixRQUFRckssTUFBTSxHQUFHLEdBQUc7WUFDdEIsTUFBTSxFQUFFckIsTUFBTXdGLEtBQUssRUFBRSxHQUFHLE1BQU1sRyxTQUMzQlksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyx1QkFDUHlMLEVBQUUsQ0FBQyxNQUFNRjtZQUVaLElBQUlsRyxPQUFPO2dCQUNUNEcsV0FBVzVHLE1BQU0wRSxNQUFNLENBQUMsQ0FBQ21DLEtBQUtWLElBQU87d0JBQUUsR0FBR1UsR0FBRzt3QkFBRSxDQUFDVixFQUFFckssRUFBRSxDQUFDLEVBQUVxSztvQkFBRSxJQUFJLENBQUM7WUFDaEU7UUFDRjtRQUVBLDRCQUE0QjtRQUM1QixNQUFNVyxZQUFZO2VBQUksSUFBSUwsSUFBSU0sT0FBT0MsTUFBTSxDQUFDSixVQUFVckYsR0FBRyxDQUFDLENBQUM0RSxJQUFXQSxFQUFFcEssU0FBUyxFQUFFdUksTUFBTSxDQUFDcUM7U0FBVTtRQUVwRyx1QkFBdUI7UUFDdkIsSUFBSU0sY0FBbUMsQ0FBQztRQUN4QyxJQUFJSCxVQUFVakwsTUFBTSxHQUFHLEdBQUc7WUFDeEIsTUFBTSxFQUFFckIsTUFBTTRGLFFBQVEsRUFBRSxHQUFHLE1BQU10RyxTQUM5QlksSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyxZQUNQeUwsRUFBRSxDQUFDLE1BQU1VO1lBRVosSUFBSTFHLFVBQVU7Z0JBQ1o2RyxjQUFjN0csU0FBU3NFLE1BQU0sQ0FBQyxDQUFDbUMsS0FBS3JCLElBQU87d0JBQUUsR0FBR3FCLEdBQUc7d0JBQUUsQ0FBQ3JCLEVBQUUxSixFQUFFLENBQUMsRUFBRTBKO29CQUFFLElBQUksQ0FBQztZQUN0RTtRQUNGO1FBRUEseUNBQXlDO1FBQ3pDLE1BQU0wQixlQUFlYix1QkFBQUEsaUNBQUFBLFdBQVk5RSxHQUFHLENBQUNnRCxDQUFBQTtnQkFJdkJxQzttQkFKaUM7Z0JBQzdDLEdBQUdyQyxLQUFLO2dCQUNSdkUsT0FBT3VFLE1BQU1DLE9BQU8sR0FBRztvQkFDckIsR0FBR29DLFFBQVEsQ0FBQ3JDLE1BQU1DLE9BQU8sQ0FBQztvQkFDMUJwRSxVQUFVd0csRUFBQUEsMEJBQUFBLFFBQVEsQ0FBQ3JDLE1BQU1DLE9BQU8sQ0FBQyxjQUF2Qm9DLDhDQUFBQSx3QkFBeUI3SyxTQUFTLElBQUdrTCxXQUFXLENBQUNMLFFBQVEsQ0FBQ3JDLE1BQU1DLE9BQU8sQ0FBQyxDQUFDekksU0FBUyxDQUFDLEdBQUc7Z0JBQ2xHLElBQUk7WUFDTjs7UUFFQW5CLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBNENxTSxDQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNyTCxNQUFNLEtBQUksR0FBRztRQUNuRixPQUFPO1lBQUVyQixNQUFNME0sZ0JBQWdCLEVBQUU7WUFBRXpNLE9BQU87UUFBSztJQUNqRCxFQUFFLE9BQU9BLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDZDQUE2Q0E7UUFDM0QsT0FBTztZQUFFRCxNQUFNLEVBQUU7WUFBRUMsT0FBT0E7UUFBYTtJQUN6QztBQUNGO0FBRU8sZUFBZTBNLG9CQUFvQkMsU0FLekM7SUFDQyxNQUFNLEVBQUU1TSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsVUFDTGdDLE1BQU0sQ0FBQztRQUNOO1lBQ0UsR0FBRzBLLFNBQVM7WUFDWi9LLFlBQVksSUFBSWxCLE9BQU9tQixXQUFXO1FBQ3BDO0tBQ0QsRUFDQTNCLE1BQU0sR0FDTmdDLE1BQU07SUFFVCxPQUFPbEMsUUFBUTtRQUFFRCxNQUFNO1FBQU1DO0lBQU0sSUFBSTtRQUFFRDtRQUFNQyxPQUFPO0lBQUs7QUFDN0Q7QUFFTyxlQUFlNE0sY0FBY3RJLE1BQWM7SUFDaEQsTUFBTSxFQUFFdkUsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLFVBQ0xDLE1BQU0sQ0FBQyxLQUNQZ0IsRUFBRSxDQUFDLFdBQVdvRCxRQUNkbkQsS0FBSyxDQUFDLGNBQWM7UUFBRXdELFdBQVc7SUFBTTtJQUUxQyxPQUFPM0UsUUFBUTtRQUFFRCxNQUFNLEVBQUU7UUFBRUM7SUFBTSxJQUFJO1FBQUVELE1BQU1BLFFBQVEsRUFBRTtRQUFFQyxPQUFPO0lBQUs7QUFDdkU7QUFFQSxnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLGdDQUFnQztBQUN6QixlQUFlNk0sa0JBQWtCNUwsUUFBaUIsRUFBRTZMLFlBQXFCO0lBQzlFM00sUUFBUUMsR0FBRyxDQUFDLHVDQUF1QztRQUFFYTtRQUFVNkw7SUFBYTtJQUU1RSxJQUFJO1FBQ0YsNkJBQTZCO1FBQzdCLElBQUlwSSxRQUFRckYsU0FDVFksSUFBSSxDQUFDLFVBQ0xDLE1BQU0sQ0FBQyxLQUNQaUIsS0FBSyxDQUFDLGNBQWM7WUFBRXdELFdBQVc7UUFBTTtRQUUxQyxJQUFJMUQsWUFBWUEsYUFBYSxPQUFPO1lBQ2xDLDZCQUE2QjtZQUM3QixNQUFNLEVBQUVsQixNQUFNeUwsYUFBYSxFQUFFeEwsT0FBT3VKLFVBQVUsRUFBRSxHQUFHLE1BQU1sSyxTQUN0RFksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxNQUNQZ0IsRUFBRSxDQUFDLGFBQWFEO1lBRW5CLElBQUlzSSxZQUFZO2dCQUNkcEosUUFBUUgsS0FBSyxDQUFDLG1DQUFtQ3VKO2dCQUNqRCxPQUFPO29CQUFFeEosTUFBTSxFQUFFO29CQUFFQyxPQUFPdUo7Z0JBQVc7WUFDdkM7WUFFQSxJQUFJaUMsaUJBQWlCQSxjQUFjcEssTUFBTSxHQUFHLEdBQUc7Z0JBQzdDLE1BQU1xSyxVQUFVRCxjQUFjMUUsR0FBRyxDQUFDNEUsQ0FBQUEsSUFBS0EsRUFBRXJLLEVBQUU7Z0JBQzNDcUQsUUFBUUEsTUFBTWlILEVBQUUsQ0FBQyxXQUFXRjtZQUM5QixPQUFPO2dCQUNMdEwsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QmE7Z0JBQ3pDLE9BQU87b0JBQUVsQixNQUFNLEVBQUU7b0JBQUVDLE9BQU87Z0JBQUs7WUFDakM7UUFDRjtRQUVBLElBQUk4TSxnQkFBZ0JBLGlCQUFpQixPQUFPO1lBQzFDcEksUUFBUUEsTUFBTXhELEVBQUUsQ0FBQyxVQUFVNEw7UUFDN0I7UUFFQSxNQUFNLEVBQUUvTSxNQUFNZ04sVUFBVSxFQUFFL00sS0FBSyxFQUFFLEdBQUcsTUFBTTBFO1FBRTFDLElBQUkxRSxPQUFPO1lBQ1RHLFFBQVFILEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU87Z0JBQUVELE1BQU0sRUFBRTtnQkFBRUM7WUFBTTtRQUMzQjtRQUVBLElBQUksQ0FBQytNLGNBQWNBLFdBQVczTCxNQUFNLEtBQUssR0FBRztZQUMxQ2pCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87Z0JBQUVMLE1BQU0sRUFBRTtnQkFBRUMsT0FBTztZQUFLO1FBQ2pDO1FBRUEsbUJBQW1CO1FBQ25CLE1BQU15TCxVQUFVO2VBQUksSUFBSU8sSUFBSWUsV0FBV2pHLEdBQUcsQ0FBQ2tHLENBQUFBLElBQUtBLEVBQUVqRCxPQUFPLEVBQUVGLE1BQU0sQ0FBQ3FDO1NBQVU7UUFDNUUsSUFBSUMsV0FBZ0MsQ0FBQztRQUVyQyxJQUFJVixRQUFRckssTUFBTSxHQUFHLEdBQUc7WUFDdEIsTUFBTSxFQUFFckIsTUFBTXdGLEtBQUssRUFBRSxHQUFHLE1BQU1sRyxTQUMzQlksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyx3Q0FDUHlMLEVBQUUsQ0FBQyxNQUFNRjtZQUVaLElBQUlsRyxPQUFPO2dCQUNUNEcsV0FBVzVHLE1BQU0wRSxNQUFNLENBQUMsQ0FBQ21DLEtBQUtWLElBQU87d0JBQUUsR0FBR1UsR0FBRzt3QkFBRSxDQUFDVixFQUFFckssRUFBRSxDQUFDLEVBQUVxSztvQkFBRSxJQUFJLENBQUM7WUFDaEU7UUFDRjtRQUVBLHVCQUF1QjtRQUN2QixNQUFNdUIsY0FBYztlQUFJLElBQUlqQixJQUFJZSxXQUFXakcsR0FBRyxDQUFDa0csQ0FBQUEsSUFBS0EsRUFBRUUsV0FBVyxFQUFFckQsTUFBTSxDQUFDcUM7U0FBVTtRQUNwRixJQUFJaUIsZUFBb0MsQ0FBQztRQUV6QyxJQUFJRixZQUFZN0wsTUFBTSxHQUFHLEdBQUc7WUFDMUIsTUFBTSxFQUFFckIsTUFBTXFOLFNBQVMsRUFBRSxHQUFHLE1BQU0vTixTQUMvQlksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxZQUNQeUwsRUFBRSxDQUFDLE1BQU1zQjtZQUVaLElBQUlHLFdBQVc7Z0JBQ2JELGVBQWVDLFVBQVVuRCxNQUFNLENBQUMsQ0FBQ21DLEtBQUtWLElBQU87d0JBQUUsR0FBR1UsR0FBRzt3QkFBRSxDQUFDVixFQUFFckssRUFBRSxDQUFDLEVBQUVxSztvQkFBRSxJQUFJLENBQUM7WUFDeEU7UUFDRjtRQUVBLCtCQUErQjtRQUMvQixNQUFNZSxlQUFlTSxXQUFXakcsR0FBRyxDQUFDdUcsQ0FBQUEsU0FBVztnQkFDN0MsR0FBR0EsTUFBTTtnQkFDVDFELE1BQU0wRCxPQUFPdEQsT0FBTyxHQUFHb0MsUUFBUSxDQUFDa0IsT0FBT3RELE9BQU8sQ0FBQyxHQUFHO2dCQUNsRHVELFVBQVVELE9BQU9ILFdBQVcsR0FBR0MsWUFBWSxDQUFDRSxPQUFPSCxXQUFXLENBQUMsR0FBRztZQUNwRTtRQUVBL00sUUFBUUMsR0FBRyxDQUFDLGdDQUFnQ3FNLENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY3JMLE1BQU0sS0FBSSxHQUFHO1FBQ3ZFLE9BQU87WUFBRXJCLE1BQU0wTSxnQkFBZ0IsRUFBRTtZQUFFek0sT0FBTztRQUFLO0lBQ2pELEVBQUUsT0FBT0EsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsK0NBQStDQTtRQUM3RCxPQUFPO1lBQUVELE1BQU0sRUFBRTtZQUFFQyxPQUFPQTtRQUFhO0lBQ3pDO0FBQ0Y7QUFFTyxlQUFldU4sb0JBQW9CdE0sUUFBaUI7SUFDekRkLFFBQVFDLEdBQUcsQ0FBQyxrREFBa0RhO0lBRTlELElBQUk7UUFDRixJQUFJeUQsUUFBUXJGLFNBQVNZLElBQUksQ0FBQyxVQUFVQyxNQUFNLENBQUM7UUFFM0MsSUFBSWUsWUFBWUEsYUFBYSxPQUFPO1lBQ2xDLDZCQUE2QjtZQUM3QixNQUFNLEVBQUVsQixNQUFNeUwsYUFBYSxFQUFFeEwsT0FBT3VKLFVBQVUsRUFBRSxHQUFHLE1BQU1sSyxTQUN0RFksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxNQUNQZ0IsRUFBRSxDQUFDLGFBQWFEO1lBRW5CLElBQUlzSSxZQUFZO2dCQUNkcEosUUFBUUgsS0FBSyxDQUFDLG1DQUFtQ3VKO2dCQUNqRCxPQUFPO29CQUNMeEosTUFBTTt3QkFDSnlOLGVBQWU7d0JBQ2ZDLGdCQUFnQjt3QkFDaEJDLFdBQVc7d0JBQ1hDLGlCQUFpQjtvQkFDbkI7b0JBQ0EzTixPQUFPdUo7Z0JBQ1Q7WUFDRjtZQUVBLElBQUlpQyxpQkFBaUJBLGNBQWNwSyxNQUFNLEdBQUcsR0FBRztnQkFDN0MsTUFBTXFLLFVBQVVELGNBQWMxRSxHQUFHLENBQUM0RSxDQUFBQSxJQUFLQSxFQUFFckssRUFBRTtnQkFDM0NxRCxRQUFRQSxNQUFNaUgsRUFBRSxDQUFDLFdBQVdGO1lBQzlCLE9BQU87Z0JBQ0wsT0FBTztvQkFDTDFMLE1BQU07d0JBQ0p5TixlQUFlO3dCQUNmQyxnQkFBZ0I7d0JBQ2hCQyxXQUFXO3dCQUNYQyxpQkFBaUI7b0JBQ25CO29CQUNBM04sT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxNQUFNLEVBQUVELElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTTBFO1FBRTlCLElBQUkxRSxPQUFPO1lBQ1RHLFFBQVFDLEdBQUcsQ0FBQywwQ0FBMENKO1lBQ3RELE9BQU87Z0JBQ0xELE1BQU07b0JBQ0p5TixlQUFlO29CQUNmQyxnQkFBZ0I7b0JBQ2hCQyxXQUFXO29CQUNYQyxpQkFBaUI7Z0JBQ25CO2dCQUNBM047WUFDRjtRQUNGO1FBRUEsTUFBTXdOLGdCQUFnQnpOLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTThKLE1BQU0sQ0FBQyxDQUFDbUQsSUFBTUEsRUFBRVksTUFBTSxLQUFLLFdBQVczRCxNQUFNLENBQUMsQ0FBQ0MsS0FBSzhDLElBQU05QyxNQUFPOEMsQ0FBQUEsRUFBRWEsTUFBTSxJQUFJLElBQUksT0FBTTtRQUNsSCxNQUFNSixpQkFBaUIxTixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU04SixNQUFNLENBQUMsQ0FBQ21ELElBQU1BLEVBQUVZLE1BQU0sS0FBSyxZQUFZM0QsTUFBTSxDQUFDLENBQUNDLEtBQUs4QyxJQUFNOUMsTUFBTzhDLENBQUFBLEVBQUVhLE1BQU0sSUFBSSxJQUFJLE9BQU07UUFDcEgsTUFBTUgsWUFBWTNOLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTThKLE1BQU0sQ0FBQyxDQUFDbUQsSUFBTUEsRUFBRVksTUFBTSxLQUFLLFFBQVEzRCxNQUFNLENBQUMsQ0FBQ0MsS0FBSzhDLElBQU05QyxNQUFPOEMsQ0FBQUEsRUFBRWEsTUFBTSxJQUFJLElBQUksT0FBTTtRQUUzRyxNQUFNLEVBQUU5TixNQUFNK04sU0FBUyxFQUFFLEdBQUcsTUFBTXpPLFNBQVNZLElBQUksQ0FBQyxTQUFTQyxNQUFNLENBQUMsTUFBTWdCLEVBQUUsQ0FBQyxVQUFVO1FBQ25GLE1BQU15TSxrQkFBa0JHLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBVzFNLE1BQU0sS0FBSTtRQUU3QyxNQUFNMk0sYUFBYTtZQUNqQlA7WUFDQUM7WUFDQUM7WUFDQUM7UUFDRjtRQUVBeE4sUUFBUUMsR0FBRyxDQUFDLGtDQUFrQzJOO1FBQzlDLE9BQU87WUFBRWhPLE1BQU1nTztZQUFZL04sT0FBTztRQUFLO0lBQ3pDLEVBQUUsT0FBT0EsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsaURBQWlEQTtRQUMvRCxPQUFPO1lBQ0xELE1BQU07Z0JBQ0p5TixlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCQyxXQUFXO2dCQUNYQyxpQkFBaUI7WUFDbkI7WUFDQTNOLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBRU8sZUFBZWdPLG1CQUFtQi9NLFFBQWlCO0lBQ3hEZCxRQUFRQyxHQUFHLENBQUMsaURBQWlEYTtJQUU3RCxJQUFJeUQsUUFBUXJGLFNBQVNZLElBQUksQ0FBQyxTQUFTQyxNQUFNLENBQUMsS0FBS2lCLEtBQUssQ0FBQztJQUVyRCxJQUFJRixZQUFZQSxhQUFhLE9BQU87UUFDbEN5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQ2hDO0lBRUEsTUFBTSxFQUFFbEIsTUFBTXdGLEtBQUssRUFBRXZGLE9BQU91SixVQUFVLEVBQUUsR0FBRyxNQUFNN0U7SUFFakQsSUFBSTZFLFlBQVksT0FBTztRQUFFeEosTUFBTSxFQUFFO1FBQUVDLE9BQU91SjtJQUFXO0lBRXJELE1BQU0sRUFBRXhKLE1BQU1rTyxTQUFTLEVBQUVqTyxPQUFPa08sV0FBVyxFQUFFLEdBQUcsTUFBTTdPLFNBQ25EWSxJQUFJLENBQUMsVUFDTEMsTUFBTSxDQUFDLEtBQ1BpQixLQUFLLENBQUMsY0FBYztRQUFFd0QsV0FBVztJQUFNO0lBRTFDLElBQUl1SixhQUFhO1FBQ2YvTixRQUFRQyxHQUFHLENBQUMsMkRBQTJEOE47UUFDdkUsTUFBTUMscUJBQ0o1SSxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU91QixHQUFHLENBQUMsQ0FBQzZDLE9BQWU7Z0JBQ3pCLEdBQUdBLElBQUk7Z0JBQ1B5RSxjQUFjO2dCQUNkQyxlQUFlO2dCQUNmQyxnQkFBZ0IsRUFBRTtZQUNwQixRQUFPLEVBQUU7UUFDWCxPQUFPO1lBQUV2TyxNQUFNb087WUFBb0JuTyxPQUFPO1FBQUs7SUFDakQ7SUFFQSxNQUFNdU8sc0JBQ0poSixDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU91QixHQUFHLENBQUMsQ0FBQzZDO1FBQ1YsTUFBTTZFLGFBQWFQLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3BFLE1BQU0sQ0FBQyxDQUFDd0QsU0FBZ0JBLE9BQU90RCxPQUFPLEtBQUtKLEtBQUt0SSxFQUFFLE1BQUssRUFBRTtRQUN2RixNQUFNb04sY0FBY0QsV0FBV3ZFLE1BQU0sQ0FBQyxDQUFDQyxLQUFhbUQsU0FBZ0JuRCxNQUFPbUQsQ0FBQUEsT0FBT1EsTUFBTSxJQUFJLElBQUk7UUFDaEcsTUFBTWEsZUFBZUYsV0FDbEIzRSxNQUFNLENBQUMsQ0FBQ3dELFNBQWdCQSxPQUFPTyxNQUFNLEtBQUssY0FBY1AsT0FBT08sTUFBTSxLQUFLLFdBQzFFM0QsTUFBTSxDQUFDLENBQUNDLEtBQWFtRCxTQUFnQm5ELE1BQU9tRCxDQUFBQSxPQUFPUSxNQUFNLElBQUksSUFBSTtRQUVwRSxPQUFPO1lBQ0wsR0FBR2xFLElBQUk7WUFDUHlFLGNBQWNLO1lBQ2RKLGVBQWVLO1lBQ2ZKLGdCQUFnQkU7UUFDbEI7SUFDRixPQUFNLEVBQUU7SUFFVnJPLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NtTztJQUM1QyxPQUFPO1FBQUV4TyxNQUFNd087UUFBcUJ2TyxPQUFPO0lBQUs7QUFDbEQ7QUFFTyxlQUFlMk8sb0JBQW9CNUIsVUFNekM7SUFDQzVNLFFBQVFDLEdBQUcsQ0FBQyx5Q0FBeUMyTTtJQUVyRCw2QkFBNkI7SUFDN0IsTUFBTSxFQUFFaE4sTUFBTTRKLElBQUksRUFBRTNKLE9BQU80TyxTQUFTLEVBQUUsR0FBRyxNQUFNdlAsU0FDNUNZLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsUUFDUGdCLEVBQUUsQ0FBQyxNQUFNNkwsV0FBV2hELE9BQU8sRUFDM0I3SCxNQUFNO0lBRVQsSUFBSTBNLFdBQVc7UUFDYnpPLFFBQVFILEtBQUssQ0FBQyxrREFBa0Q0TztRQUNoRSxPQUFPO1lBQUU3TyxNQUFNO1lBQU1DLE9BQU80TztRQUFVO0lBQ3hDO0lBRUEsTUFBTUMsaUJBQWlCO1FBQ3JCLEdBQUc5QixVQUFVO1FBQ2IrQixXQUFXbkYsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNbEUsSUFBSSxLQUFJO1FBQ3pCbUksUUFBUTtRQUNSbUIsY0FBYyxJQUFJck8sT0FBT21CLFdBQVc7UUFDcENELFlBQVksSUFBSWxCLE9BQU9tQixXQUFXO0lBQ3BDO0lBRUEsTUFBTSxFQUFFOUIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUFTWSxJQUFJLENBQUMsVUFBVWdDLE1BQU0sQ0FBQztRQUFDNE07S0FBZSxFQUFFM08sTUFBTSxHQUFHZ0MsTUFBTTtJQUU5Ri9CLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEI7UUFBRUw7UUFBTUM7SUFBTTtJQUN4RCxPQUFPQSxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQUVPLGVBQWVnUCxtQkFDcEJDLFFBQWdCLEVBQ2hCckIsTUFBd0MsRUFDeENzQixVQUFrQjtJQUVsQi9PLFFBQVFDLEdBQUcsQ0FBQyx3Q0FBd0M7UUFBRTZPO1FBQVVyQjtRQUFRc0I7SUFBVztJQUVuRixNQUFNQyxhQUFrQjtRQUN0QnZCO1FBQ0F4SixZQUFZLElBQUkxRCxPQUFPbUIsV0FBVztJQUNwQztJQUVBLElBQUkrTCxXQUFXLFlBQVk7UUFDekJ1QixXQUFXakMsV0FBVyxHQUFHZ0M7UUFDekJDLFdBQVdDLFdBQVcsR0FBRyxJQUFJMU8sT0FBT21CLFdBQVc7SUFDakQ7SUFFQSxNQUFNLEVBQUU5QixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxVQUFVa0UsTUFBTSxDQUFDZ0wsWUFBWWpPLEVBQUUsQ0FBQyxNQUFNK04sVUFBVS9PLE1BQU0sR0FBR2dDLE1BQU07SUFFM0cvQixRQUFRQyxHQUFHLENBQUMscUNBQXFDO1FBQUVMO1FBQU1DO0lBQU07SUFDL0QsT0FBT0EsUUFBUTtRQUFFRCxNQUFNO1FBQU1DO0lBQU0sSUFBSTtRQUFFRDtRQUFNQyxPQUFPO0lBQUs7QUFDN0Q7QUFxQ0EsZ0NBQWdDO0FBQ2hDLDRDQUE0QztBQUM1QyxnQ0FBZ0M7QUFDekIsZUFBZXFQLHVCQUF1QkMsVUFBa0I7SUFDN0RuUCxRQUFRQyxHQUFHLENBQUMsK0NBQStDa1A7SUFFM0QsSUFBSTtRQUNGLGdEQUFnRDtRQUNoRCxNQUFNLEVBQUV2UCxNQUFNd1AsUUFBUSxFQUFFdlAsT0FBT3dQLFFBQVEsRUFBRSxHQUFHLE1BQU1uUSxTQUMvQ1ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxtQkFDUGdCLEVBQUUsQ0FBQyxNQUFNb08sWUFDVHBOLE1BQU07UUFFVCxJQUFJc04sWUFBWSxDQUFDRCxVQUFVO1lBQ3pCcFAsUUFBUUgsS0FBSyxDQUFDLDJCQUEyQndQO1lBQ3pDLE9BQU87Z0JBQ0xDLGVBQWU7Z0JBQ2ZDLG1CQUFtQjtnQkFDbkJDLGVBQWU7Z0JBQ2ZDLFlBQVk7WUFDZDtRQUNGO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU1DLGNBQWMsSUFBSW5QO1FBQ3hCLE1BQU1vUCxrQkFBa0IsSUFBSXBQLEtBQUttUCxZQUFZdEYsV0FBVyxJQUFJc0YsWUFBWXhGLFFBQVEsSUFBSTtRQUNwRixNQUFNMEYsaUJBQWlCLElBQUlyUCxLQUFLbVAsWUFBWXRGLFdBQVcsSUFBSXNGLFlBQVl4RixRQUFRLEtBQUssR0FBRztRQUV2RixNQUFNLEVBQUV0SyxNQUFNaUUsY0FBYyxFQUFFaEUsT0FBT2dRLGVBQWUsRUFBRSxHQUFHLE1BQU0zUSxTQUM1RFksSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQyxnQkFDUGdCLEVBQUUsQ0FBQyxXQUFXb08sWUFDZG5ILEdBQUcsQ0FBQyxRQUFRMkgsZ0JBQWdCak8sV0FBVyxHQUFHYyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFDdkRzTixHQUFHLENBQUMsUUFBUUYsZUFBZWxPLFdBQVcsR0FBR2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBRXpELElBQUlxTixpQkFBaUI7WUFDbkI3UCxRQUFRSCxLQUFLLENBQUMsa0NBQWtDZ1E7WUFDaEQsT0FBTztnQkFDTFAsZUFBZUYsU0FBU1csZUFBZSxJQUFJO2dCQUMzQ1IsbUJBQW1CO2dCQUNuQkMsZUFBZUosU0FBU1csZUFBZSxJQUFJO2dCQUMzQ04sWUFBWTtZQUNkO1FBQ0Y7UUFFQSx5RUFBeUU7UUFDekUsTUFBTUYsb0JBQW9CMUwsQ0FBQUEsMkJBQUFBLHFDQUFBQSxlQUFnQjZGLE1BQU0sQ0FBQ3NHLENBQUFBLFNBQy9DQSxPQUFPdkMsTUFBTSxLQUFLLFlBQVl1QyxPQUFPdkMsTUFBTSxLQUFLLE1BQ2hEeE0sTUFBTSxLQUFJO1FBRVosTUFBTXFPLGdCQUFnQkYsU0FBU1csZUFBZSxJQUFJO1FBQ2xELE1BQU1QLGdCQUFnQnpHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHc0csZ0JBQWdCQztRQUNsRCxNQUFNRSxhQUFhMUcsS0FBS0MsR0FBRyxDQUFDLEdBQUd1RyxvQkFBb0JEO1FBRW5EdFAsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQjtZQUNwQ3FQO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xIO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFFRixFQUFFLE9BQU81UCxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE9BQU87WUFDTHlQLGVBQWU7WUFDZkMsbUJBQW1CO1lBQ25CQyxlQUFlO1lBQ2ZDLFlBQVk7UUFDZDtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUN6QixlQUFlUSxvQkFBb0JkLFVBQWtCLEVBQUVlLE9BQWU7SUFDM0UsSUFBSTtRQUNGLE1BQU0sRUFBRXRRLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FDM0JZLElBQUksQ0FBQyxTQUNMa0UsTUFBTSxDQUFDO1lBQUUrTCxpQkFBaUJHO1FBQVEsR0FDbENuUCxFQUFFLENBQUMsTUFBTW9PLFlBQ1RwUCxNQUFNLEdBQ05nQyxNQUFNO1FBRVQsSUFBSWxDLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLG1DQUFtQ0E7WUFDakQsT0FBTztnQkFBRUE7WUFBTTtRQUNqQjtRQUVBRyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCTDtRQUN4QyxPQUFPO1lBQUVBO1FBQUs7SUFDaEIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyx1Q0FBdUNBO1FBQ3JELE9BQU87WUFBRUE7UUFBTTtJQUNqQjtBQUNGO0FBYUEsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFFekIsZUFBZXNRO0lBQ3BCblEsUUFBUUMsR0FBRyxDQUFDO0lBRVosTUFBTSxFQUFFTCxNQUFNd0YsS0FBSyxFQUFFdkYsT0FBT3VKLFVBQVUsRUFBRSxHQUFHLE1BQU1sSyxTQUM5Q1ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBRSx1ZUEyQlJpQixLQUFLLENBQUMsU0FBVSxtREFBbUQ7SUFFdEVoQixRQUFRQyxHQUFHLENBQUMsb0JBQW9CO1FBQzlCbVEsVUFBVSxFQUFFaEwsa0JBQUFBLDRCQUFBQSxNQUFPbkUsTUFBTTtRQUN6Qm9QLFVBQVUsQ0FBQyxDQUFDakg7UUFDWmtILFNBQVMsRUFBRWxMLGtCQUFBQSw0QkFBQUEsS0FBTyxDQUFDLEVBQUU7SUFDdkI7SUFFQSw0RUFBNEU7SUFDNUUsSUFBSWdFLGNBQWMsQ0FBQ2hFLE9BQU87UUFDeEJwRixRQUFRSCxLQUFLLENBQUMsc0NBQXNDdUo7UUFDcEQsT0FBTztZQUFFeEosTUFBTSxFQUFFO1lBQUVDLE9BQU91SjtRQUFXO0lBQ3ZDO0lBRUEsaURBQWlEO0lBQ2pELE1BQU1tSCxZQUFZLENBQUNuTCxTQUFTLEVBQUUsRUFBRXVCLEdBQUcsQ0FBQyxDQUFDNkMsT0FBZTtZQUNsRHRJLElBQUlzSSxLQUFLdEksRUFBRTtZQUNYb0UsTUFBTWtFLEtBQUtsRSxJQUFJO1lBQ2ZrTCxPQUFPaEgsS0FBS2dILEtBQUssSUFBSTtZQUNyQkMsT0FBT2pILEtBQUtpSCxLQUFLLElBQUk7WUFDckJDLFVBQVVsSCxLQUFLa0gsUUFBUSxJQUFJO1lBQzNCakQsUUFBUWpFLEtBQUtpRSxNQUFNLElBQUk7WUFDdkJrRCxRQUFRbkgsS0FBS21ILE1BQU0sSUFBSTtZQUN2QkMsWUFBWXBILEtBQUttSCxNQUFNLElBQUk7WUFDM0JFLGdCQUFnQnJILEtBQUtzSCxlQUFlLElBQUk7WUFDeENDLEtBQUt2SCxLQUFLdUgsR0FBRyxJQUFJO1lBQ2pCaEIsaUJBQWlCdkcsS0FBS3VHLGVBQWUsSUFBSTtZQUN6Q3RPLFlBQVkrSCxLQUFLL0gsVUFBVTtZQUMzQnVQLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxRQUFRMUgsS0FBSzBILE1BQU0sSUFBSTtZQUN2QkMsZ0JBQWdCM0gsS0FBSzJILGNBQWMsSUFBSTtZQUN2Q0MsdUJBQXVCNUgsS0FBSzRILHFCQUFxQixJQUFJO1lBQ3JEQyxnQkFBZ0I3SCxLQUFLNkgsY0FBYyxJQUFJO1lBQ3ZDQyxhQUFhOUgsS0FBSzhILFdBQVcsSUFBSTtZQUNqQ0MsZUFBZS9ILEtBQUsrSCxhQUFhLElBQUk7WUFDckNDLFVBQVVoSSxLQUFLZ0ksUUFBUSxJQUFJO1lBQzNCQyxlQUFlakksS0FBS2lJLGFBQWEsSUFBSTtZQUNyQ0MsY0FBY2xJLEtBQUtrSSxZQUFZLElBQUk7WUFDbkNDLGFBQWFuSSxLQUFLbUksV0FBVyxJQUFJO1lBQ2pDQyxlQUFlcEksS0FBS29JLGFBQWEsSUFBSTtZQUNyQ0MsZUFBZXJJLEtBQUtxSSxhQUFhLElBQUk7WUFDckNDLGFBQWF0SSxLQUFLc0ksV0FBVyxJQUFJO1lBQ2pDQyxnQkFBZ0JDLE9BQU94SSxLQUFLdUksY0FBYyxJQUFJO1FBQ2hEO0lBRUEvUixRQUFRQyxHQUFHLENBQUMsNkJBQTZCc1EsVUFBVXRQLE1BQU07SUFDekQsT0FBTztRQUFFckIsTUFBTTJRO1FBQVcxUSxPQUFPO0lBQUs7QUFDeEM7QUFFTyxlQUFlb1MsWUFBWTdDLFFBQTJCO0lBQzNEcFAsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ21QO0lBRTlDLDBDQUEwQztJQUMxQyx1RUFBdUU7SUFDdkUsTUFBTThDLFdBQVc7UUFDZjVNLE1BQU04SixTQUFTOUosSUFBSTtRQUNuQmtMLE9BQU9wQixTQUFTb0IsS0FBSztRQUNyQkMsT0FBT3JCLFNBQVNxQixLQUFLLElBQUk7UUFDekJoRCxRQUFRMkIsU0FBUzNCLE1BQU0sSUFBSTtRQUMzQnNELEtBQUszQixTQUFTMkIsR0FBRztRQUNqQkwsVUFBVXRCLFNBQVNzQixRQUFRO1FBQzNCQyxRQUFRdkIsU0FBU3VCLE1BQU0sSUFBSXZCLFNBQVN3QixVQUFVLElBQUk7UUFDbERFLGlCQUFpQjFCLFNBQVN5QixjQUFjLElBQUk7SUFDOUM7SUFFQSxNQUFNLEVBQUVqUixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxTQUFTZ0MsTUFBTSxDQUFDO1FBQUNvUTtLQUFTLEVBQUVuUyxNQUFNLEdBQUdnQyxNQUFNO0lBRXZGL0IsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QjtRQUFFTDtRQUFNQztJQUFNO0lBQ3ZELE9BQU87UUFBRUQ7UUFBTUM7SUFBTTtBQUN2QjtBQUVPLGVBQWVzUyxlQUFlalIsRUFBVSxFQUFFa08sUUFBMkI7SUFDMUVwUCxRQUFRQyxHQUFHLENBQUMscUNBQXFDaUI7SUFFakQsTUFBTWdSLFdBQVc7UUFDZjVNLE1BQU04SixTQUFTOUosSUFBSTtRQUNuQmtMLE9BQU9wQixTQUFTb0IsS0FBSztRQUNyQkMsT0FBT3JCLFNBQVNxQixLQUFLO1FBQ3JCaEQsUUFBUTJCLFNBQVMzQixNQUFNO1FBQ3ZCc0QsS0FBSzNCLFNBQVMyQixHQUFHO1FBQ2pCTCxVQUFVdEIsU0FBU3NCLFFBQVE7UUFDM0JDLFFBQVF2QixTQUFTd0IsVUFBVTtRQUMzQkUsaUJBQWlCMUIsU0FBU3lCLGNBQWM7SUFDMUM7SUFFQSxNQUFNLEVBQUVqUixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQyxTQUFTa0UsTUFBTSxDQUFDa08sVUFBVW5SLEVBQUUsQ0FBQyxNQUFNRyxJQUFJbkIsTUFBTSxHQUFHZ0MsTUFBTTtJQUVsRy9CLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0M7UUFBRUw7UUFBTUM7SUFBTTtJQUMxRCxPQUFPO1FBQUVEO1FBQU1DO0lBQU07QUFDdkI7QUFFTyxlQUFldVMsZUFBZWxSLEVBQVU7SUFDN0NsQixRQUFRQyxHQUFHLENBQUMsOENBQThDaUI7SUFFMUQsSUFBSTtRQUNGLHNCQUFzQjtRQUN0QixNQUFNLEVBQUV0QixNQUFNeVMsWUFBWSxFQUFFeFMsT0FBT3lTLFVBQVUsRUFBRSxHQUFHLE1BQU1wVCxTQUNyRFksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQZ0IsRUFBRSxDQUFDLE1BQU1HLElBQ1RhLE1BQU07UUFFVCxJQUFJdVEsWUFBWTtZQUNkdFMsUUFBUUgsS0FBSyxDQUFDLHlDQUF5Q3lTO1lBQ3ZELE9BQU87Z0JBQUUxUyxNQUFNO2dCQUFNQyxPQUFPeVM7WUFBVztRQUN6QztRQUVBLElBQUksQ0FBQ0QsY0FBYztZQUNqQnJTLFFBQVFILEtBQUssQ0FBQztZQUNkLE9BQU87Z0JBQUVELE1BQU07Z0JBQU1DLE9BQU87b0JBQUUrTCxTQUFTO2dCQUEyQjtZQUFTO1FBQzdFO1FBRUE1TCxRQUFRQyxHQUFHLENBQUMsaUNBQWlDb1M7UUFFN0MsZ0ZBQWdGO1FBQ2hGLE1BQU0sRUFBRXpTLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FDM0JZLElBQUksQ0FBQyxTQUNMa0UsTUFBTSxDQUFDO1lBQUV5SixRQUFRO1FBQVcsR0FDNUIxTSxFQUFFLENBQUMsTUFBTUcsSUFDVG5CLE1BQU0sR0FDTmdDLE1BQU07UUFFVC9CLFFBQVFDLEdBQUcsQ0FBQywwQ0FBMEM7WUFBRUw7WUFBTUM7UUFBTTtRQUVwRSxJQUFJQSxPQUFPO1lBQ1RHLFFBQVFILEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELE9BQU87Z0JBQUVELE1BQU07Z0JBQU1DO1lBQU07UUFDN0I7UUFFQUcsUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBTztZQUFFTDtZQUFNQyxPQUFPO1FBQUs7SUFFN0IsRUFBRSxPQUFPMFMsR0FBRztRQUNWdlMsUUFBUUgsS0FBSyxDQUFDLCtCQUErQjBTO1FBQzdDLE9BQU87WUFBRTNTLE1BQU07WUFBTUMsT0FBTztnQkFBRStMLFNBQVNvRyxPQUFPTztZQUFHO1FBQVM7SUFDNUQ7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEMsZ0NBQWdDO0FBQ3pCLGVBQWVDLGlCQUFpQnJELFVBQWtCO0lBQ3ZEblAsUUFBUUMsR0FBRyxDQUFDLDRDQUE0Q2tQO0lBRXhELElBQUk7UUFDRix3RkFBd0Y7UUFDeEYsTUFBTSxFQUFFdlAsTUFBTW1JLFlBQVksRUFBRWxJLE9BQU80UyxpQkFBaUIsRUFBRSxHQUFHLE1BQU12VCxTQUM1RFksSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUMsNEJBQ1BnQixFQUFFLENBQUMsYUFBYW9PLFlBQ2hCbkgsR0FBRyxDQUFDLGNBQWMsSUFBSXpILEtBQUssSUFBSUEsT0FBTzZKLFdBQVcsSUFBSSxJQUFJN0osT0FBTzJKLFFBQVEsSUFBSSxHQUFHeEksV0FBVztRQUU3RixJQUFJK1EsbUJBQW1CO1lBQ3JCelMsUUFBUUgsS0FBSyxDQUFDLDRDQUE0QzRTO1FBQzVEO1FBRUEsTUFBTUMsb0JBQW9CM0ssQ0FBQUEseUJBQUFBLG1DQUFBQSxhQUFjOUcsTUFBTSxLQUFJO1FBQ2xELE1BQU0wUixlQUFlNUssQ0FBQUEseUJBQUFBLG1DQUFBQSxhQUFjK0IsTUFBTSxDQUFDLENBQUNDLEtBQUs2SSxJQUFNN0ksTUFBTzZJLENBQUFBLEVBQUUxTSxZQUFZLElBQUksSUFBSSxPQUFNO1FBQ3pGLE1BQU0yTSxxQkFBcUJILG9CQUFvQixJQUFJQyxlQUFlRCxvQkFBb0I7UUFFdEYsb0ZBQW9GO1FBQ3BGLElBQUlJLGtCQUFrQjtRQUN0QixJQUFJO1lBQ0Y5UyxRQUFRQyxHQUFHLENBQUMsMkRBQTJEa1A7WUFFdkUsTUFBTSxFQUFFdlAsTUFBTW1ULGNBQWMsRUFBRWxULE9BQU9tVCxlQUFlLEVBQUUsR0FBRyxNQUFNOVQsU0FDNURZLElBQUksQ0FBQyxxQkFDTEMsTUFBTSxDQUFDLHdDQUNQZ0IsRUFBRSxDQUFDLGFBQWFvTyxZQUNoQnBPLEVBQUUsQ0FBQyxxQkFBcUIsWUFDeEJpSCxHQUFHLENBQUMsY0FBYyxJQUFJekgsS0FBSyxJQUFJQSxPQUFPNkosV0FBVyxJQUFJLElBQUk3SixPQUFPMkosUUFBUSxJQUFJLEdBQUd4SSxXQUFXO1lBRTdGLElBQUksQ0FBQ3NSLG1CQUFtQkQsZ0JBQWdCO2dCQUN0Q0Qsa0JBQWtCQyxlQUFlakosTUFBTSxDQUFDLENBQUNDLEtBQUtuRDtvQkFDNUMsT0FBT21ELE1BQU9uRCxDQUFBQSxLQUFLcU0saUJBQWlCLElBQUk7Z0JBQzFDLEdBQUc7Z0JBRUhqVCxRQUFRQyxHQUFHLENBQUMsOENBQThDOFMsZUFBZTlSLE1BQU0sRUFBRSxVQUFVNlI7WUFDN0YsT0FBTyxJQUFJRSxpQkFBaUI7Z0JBQzFCaFQsUUFBUUgsS0FBSyxDQUFDLDZDQUE2Q21UO1lBQzdEO1FBQ0YsRUFBRSxPQUFPQSxpQkFBaUI7WUFDeEJoVCxRQUFRSCxLQUFLLENBQUMsd0RBQXdEbVQ7WUFDdEVGLGtCQUFrQjtRQUNwQjtRQUVBLHVDQUF1QztRQUN2QyxNQUFNLEVBQUVsVCxNQUFNNkwsVUFBVSxFQUFFNUwsT0FBT3lKLFdBQVcsRUFBRSxHQUFHLE1BQU1wSyxTQUNwRFksSUFBSSxDQUFDLFVBQ0xDLE1BQU0sQ0FBQyw4QkFDUGdCLEVBQUUsQ0FBQyxXQUFXb08sWUFDZG5ILEdBQUcsQ0FBQyxjQUFjLElBQUl6SCxLQUFLLElBQUlBLE9BQU82SixXQUFXLElBQUksSUFBSTdKLE9BQU8ySixRQUFRLElBQUksR0FBR3hJLFdBQVc7UUFFN0YsSUFBSWlRLGNBQWM7UUFDbEIsSUFBSUMsZ0JBQWdCO1FBRXBCLElBQUksQ0FBQ3RJLGVBQWVtQyxZQUFZO1lBQzlCQSxXQUFXeUgsT0FBTyxDQUFDdkosQ0FBQUE7Z0JBQ2pCLElBQUlBLE1BQU1LLGFBQWEsR0FBRyxHQUFHO29CQUMzQjJILGVBQWVoSSxNQUFNSyxhQUFhO2dCQUNwQyxPQUFPO29CQUNMNEgsaUJBQWlCN0ksS0FBS29LLEdBQUcsQ0FBQ3hKLE1BQU1LLGFBQWE7Z0JBQy9DO1lBQ0Y7UUFDRjtRQUVBLE1BQU1vSixRQUF1QjtZQUMzQlY7WUFDQUM7WUFDQUc7WUFDQUQ7WUFDQWxCO1lBQ0FDO1lBQ0FaLFlBQVlXO1lBQ1pWLGNBQWNXO1FBQ2hCO1FBRUE1UixRQUFRQyxHQUFHLENBQUMsK0JBQStCbVQ7UUFDM0MsT0FBT0E7SUFDVCxFQUFFLE9BQU92VCxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyxxREFBcURBO1FBRW5FLDBDQUEwQztRQUMxQyxPQUFPO1lBQ0w2UyxtQkFBbUI7WUFDbkJDLGNBQWM7WUFDZEcsaUJBQWlCO1lBQ2pCRCxvQkFBb0I7WUFDcEJsQixhQUFhO1lBQ2JDLGVBQWU7WUFDZlosWUFBWTtZQUNaQyxjQUFjO1FBQ2hCO0lBQ0Y7QUFDRjtBQUVPLGVBQWVvQyx1QkFBdUJsRSxVQUFrQjtJQUM3RG5QLFFBQVFDLEdBQUcsQ0FBQyw4REFBOERrUDtJQUUxRSxNQUFNLEVBQUV2UCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBRSw2QkFDUmdCLEVBQUUsQ0FBQyxXQUFXb08sWUFDZG5PLEtBQUssQ0FBQyxjQUFjO1FBQUV3RCxXQUFXO0lBQU07SUFFMUMsSUFBSTNFLE9BQU87UUFDVEcsUUFBUUgsS0FBSyxDQUFDLGdEQUFnREE7SUFDaEU7SUFFQUcsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRDtRQUFFTDtRQUFNQztJQUFNO0lBQzNFLE9BQU9BLFFBQVE7UUFBRUQsTUFBTSxFQUFFO1FBQUVDO0lBQU0sSUFBSTtRQUFFRCxNQUFNQSxRQUFRLEVBQUU7UUFBRUMsT0FBTztJQUFLO0FBQ3ZFO0FBRUEsZ0NBQWdDO0FBQ2hDLDJDQUEyQztBQUMzQyxnQ0FBZ0M7QUFDekIsZUFBZXlULHNCQUFzQm5FLFVBQWtCO0lBQzVEblAsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRGtQO0lBRTdELElBQUk7UUFDRixNQUFNbEYsZUFBZSxJQUFJMUosT0FBTzJKLFFBQVE7UUFDeEMsTUFBTUMsY0FBYyxJQUFJNUosT0FBTzZKLFdBQVc7UUFDMUMsTUFBTXVGLGtCQUFrQixJQUFJcFAsS0FBSzRKLGFBQWFGLGNBQWM7UUFDNUQsTUFBTTJGLGlCQUFpQixJQUFJclAsS0FBSzRKLGFBQWFGLGVBQWUsR0FBRztRQUUvRCxNQUFNLEVBQUVySyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsY0FDTEMsTUFBTSxDQUFDLEtBQ1BnQixFQUFFLENBQUMsV0FBV29PLFlBQ2RuSCxHQUFHLENBQUMsUUFBUTJILGdCQUFnQmpPLFdBQVcsR0FBR2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQ3ZEc04sR0FBRyxDQUFDLFFBQVFGLGVBQWVsTyxXQUFXLEdBQUdjLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUN0RHhCLEtBQUssQ0FBQyxRQUFRO1lBQUV3RCxXQUFXO1FBQUs7UUFFbkMsSUFBSTNFLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLDBDQUEwQ0E7WUFDeEQsT0FBTztnQkFDTEQsTUFBTSxFQUFFO2dCQUNSQztnQkFDQXNSLGdCQUFnQjtnQkFDaEJHLGFBQWE7Z0JBQ2JFLFVBQVU7Z0JBQ1ZDLGVBQWU7Z0JBQ2ZGLGVBQWU7WUFDakI7UUFDRjtRQUVBLE1BQU1BLGdCQUFnQnJSLHFCQUFxQnlQLGlCQUFpQkM7UUFDNUQsTUFBTTBCLGNBQWMxUixLQUFLOEosTUFBTSxDQUFDc0csQ0FBQUEsU0FDOUJBLE9BQU92QyxNQUFNLEtBQUssaUJBQWlCdUMsT0FBT3ZDLE1BQU0sS0FBSyxjQUNyRHhNLE1BQU07UUFFUixNQUFNdVEsV0FBVzVSLEtBQUs4SixNQUFNLENBQUNzRyxDQUFBQTtZQUMzQixJQUFJLENBQUNBLE9BQU91RCxhQUFhLEVBQUUsT0FBTztZQUNsQyxNQUFNQyxjQUFjeEQsT0FBT3VELGFBQWE7WUFDeEMsT0FBT0MsY0FBYztRQUN2QixHQUFHdlMsTUFBTTtRQUVULE1BQU13UyxhQUFhN1QsS0FBS2tLLE1BQU0sQ0FBQyxDQUFDQyxLQUFLaUcsU0FBV2pHLE1BQU9pRyxDQUFBQSxPQUFPMEQsV0FBVyxJQUFJLElBQUk7UUFDakYsTUFBTUMsZUFBZXJDLGNBQWM7UUFDbkMsTUFBTUcsZ0JBQWdCMUksS0FBS0MsR0FBRyxDQUFDLEdBQUd5SyxhQUFhRTtRQUMvQyxNQUFNeEMsaUJBQWlCSSxnQkFBZ0IsSUFBSXhJLEtBQUtvQyxLQUFLLENBQUMsY0FBZW9HLGdCQUFpQixPQUFPO1FBRTdGdlIsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQztZQUNyRHNSO1lBQ0FEO1lBQ0FFO1lBQ0FDLGVBQWUxSSxLQUFLQyxHQUFHLENBQUMsR0FBR3lJO1lBQzNCTjtRQUNGO1FBRUEsT0FBTztZQUNMdlIsTUFBTUEsUUFBUSxFQUFFO1lBQ2hCQyxPQUFPO1lBQ1BzUjtZQUNBRztZQUNBRTtZQUNBQyxlQUFlMUksS0FBS0MsR0FBRyxDQUFDLEdBQUd5STtZQUMzQkY7UUFDRjtJQUNGLEVBQUUsT0FBTzFSLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDBEQUEwREE7UUFDeEUsT0FBTztZQUNMRCxNQUFNLEVBQUU7WUFDUkMsT0FBT0E7WUFDUHNSLGdCQUFnQjtZQUNoQkcsYUFBYTtZQUNiRSxVQUFVO1lBQ1ZDLGVBQWU7WUFDZkYsZUFBZTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsc0RBQXNEO0FBQ3RELGdDQUFnQztBQUN6QixlQUFlcUMsa0JBQWtCelAsTUFBYztJQUNwRG5FLFFBQVFDLEdBQUcsQ0FBQywyQ0FBMkNrRTtJQUV2RCxJQUFJO1FBQ0YsTUFBTSxFQUFFdkUsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBRSwySUFLUmdCLEVBQUUsQ0FBQyxXQUFXb0QsUUFDZDBQLEVBQUUsQ0FBQywwREFDSDdTLEtBQUssQ0FBQyxRQUFRO1lBQUV3RCxXQUFXO1FBQU0sR0FDakN4RCxLQUFLLENBQUMsY0FBYztZQUFFd0QsV0FBVztRQUFNLEdBQ3ZDYSxLQUFLLENBQUM7UUFFVHJGLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUM7WUFBRUw7WUFBTUM7UUFBTTtRQUUvRCxJQUFJQSxPQUFPO1lBQ1RHLFFBQVFILEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE9BQU87Z0JBQUVELE1BQU07Z0JBQU1DO1lBQU07UUFDN0I7UUFFQSxNQUFNaVUsd0JBQWlELENBQUNsVSxRQUFRLEVBQUUsRUFBRStHLEdBQUcsQ0FBQyxDQUFDcUosU0FBaUI7Z0JBQ3hGOU8sSUFBSThPLE9BQU85TyxFQUFFO2dCQUNiMEksU0FBU29HLE9BQU9wRyxPQUFPO2dCQUN2QnpJLFdBQVc2TyxPQUFPN08sU0FBUztnQkFDM0JFLFlBQVkyTyxPQUFPM08sVUFBVTtnQkFDN0JrUyxlQUFldkQsT0FBT3VELGFBQWE7Z0JBQ25DUSxnQkFBZ0IvRCxPQUFPK0QsY0FBYztnQkFDckNDLGtCQUFrQmhFLE9BQU9nRSxnQkFBZ0I7Z0JBQ3pDQyxnQkFBZ0JqRSxPQUFPaUUsY0FBYztnQkFDckNQLGFBQWExRCxPQUFPMEQsV0FBVztnQkFDL0JRLGdCQUFnQmxFLE9BQU9rRSxjQUFjO2dCQUNyQ3pHLFFBQVF1QyxPQUFPdkMsTUFBTTtnQkFDckIwRyxnQkFBZ0JuRSxPQUFPbUUsY0FBYztnQkFDckNDLGlCQUFpQnBFLE9BQU9vRSxlQUFlO2dCQUN2Q2hRLE1BQU00TCxPQUFPNUwsSUFBSTtnQkFDakIzQyxZQUFZdU8sT0FBT3ZPLFVBQVU7Z0JBQzdCd0MsWUFBWStMLE9BQU8vTCxVQUFVO2dCQUM3Qm1CLE9BQU80SyxPQUFPNUssS0FBSyxHQUFHO29CQUNwQmxFLElBQUk4TyxPQUFPNUssS0FBSyxDQUFDbEUsRUFBRTtvQkFDbkJvRSxNQUFNMEssT0FBTzVLLEtBQUssQ0FBQ0UsSUFBSTtvQkFDdkJrTCxPQUFPUixPQUFPNUssS0FBSyxDQUFDb0wsS0FBSztvQkFDekJFLFVBQVVWLE9BQU81SyxLQUFLLENBQUNzTCxRQUFRO29CQUMvQnZQLFdBQVc2TyxPQUFPNUssS0FBSyxDQUFDakUsU0FBUztvQkFDakNNLFlBQVl1TyxPQUFPNUssS0FBSyxDQUFDM0QsVUFBVSxJQUFJLElBQUlsQixPQUFPbUIsV0FBVztnQkFDL0QsSUFBSTJTO2dCQUNKN08sVUFBVXdLLE9BQU94SyxRQUFRLEdBQUc7b0JBQzFCdEUsSUFBSThPLE9BQU94SyxRQUFRLENBQUN0RSxFQUFFO29CQUN0Qm9FLE1BQU0wSyxPQUFPeEssUUFBUSxDQUFDRixJQUFJO29CQUMxQmdQLFNBQVN0RSxPQUFPeEssUUFBUSxDQUFDOE8sT0FBTztvQkFDaEM3UyxZQUFZdU8sT0FBT3hLLFFBQVEsQ0FBQy9ELFVBQVUsSUFBSSxJQUFJbEIsT0FBT21CLFdBQVc7Z0JBQ2xFLElBQUkyUztZQUNOO1FBRUFyVSxRQUFRQyxHQUFHLENBQUMsa0NBQWtDNlQsc0JBQXNCN1MsTUFBTSxFQUFFO1FBQzVFLE9BQU87WUFBRXJCLE1BQU1rVTtZQUF1QmpVLE9BQU87UUFBSztJQUVwRCxFQUFFLE9BQU9BLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBTztZQUFFRCxNQUFNO1lBQU1DO1FBQU07SUFDN0I7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyxvRUFBb0U7QUFDcEUsZ0NBQWdDO0FBQ3pCLGVBQWUwVSxnQ0FBZ0NwUSxNQUFjO1FBQUVxUSxPQUFBQSxpRUFBZTtJQUNuRnhVLFFBQVFDLEdBQUcsQ0FBQyx5REFBeURrRSxRQUFRLFNBQVNxUTtJQUV0RixJQUFJO1FBQ0YsTUFBTXBVLFVBQVUsSUFBSUc7UUFDcEIsTUFBTUosWUFBWSxJQUFJSTtRQUN0QkosVUFBVVEsT0FBTyxDQUFDUCxRQUFRUSxPQUFPLEtBQUs0VDtRQUV0QyxNQUFNQyxlQUFldFUsVUFBVXVCLFdBQVcsR0FBR2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzFELE1BQU1rUyxhQUFhdFUsUUFBUXNCLFdBQVcsR0FBR2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBRXREeEMsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRHdVLGNBQWMsTUFBTUM7UUFFakYsTUFBTSxFQUFFOVUsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBRSwySUFLUmdCLEVBQUUsQ0FBQyxXQUFXb0QsUUFDZDZELEdBQUcsQ0FBQyxRQUFReU0sY0FDWjNFLEdBQUcsQ0FBQyxRQUFRNEUsWUFDWjFULEtBQUssQ0FBQyxRQUFRO1lBQUV3RCxXQUFXO1FBQU0sR0FDakN4RCxLQUFLLENBQUMsY0FBYztZQUFFd0QsV0FBVztRQUFNO1FBRTFDeEUsUUFBUUMsR0FBRyxDQUFDLG1EQUFtRDtZQUFFMFUsVUFBVSxFQUFFL1UsaUJBQUFBLDJCQUFBQSxLQUFNcUIsTUFBTTtZQUFFcEI7UUFBTTtRQUVqRyw2QkFBNkI7UUFDN0IsSUFBSUEsa0JBQUFBLDRCQUFBQSxNQUFPK0wsT0FBTyxFQUFFO1lBQ2xCNUwsUUFBUUgsS0FBSyxDQUFDLDRDQUE0Q0E7WUFDMUQsT0FBTztnQkFDTEQsTUFBTSxFQUFFO2dCQUNSQztnQkFDQXNSLGdCQUFnQjtnQkFDaEJHLGFBQWE7Z0JBQ2JFLFVBQVU7Z0JBQ1ZELGVBQWVpRDtnQkFDZi9DLGVBQWU7WUFDakI7UUFDRjtRQUVBLE1BQU1tRCxvQkFBNkMsQ0FBQ2hWLFFBQVEsRUFBRSxFQUFFK0csR0FBRyxDQUFDLENBQUNxSixTQUFpQjtnQkFDcEY5TyxJQUFJOE8sT0FBTzlPLEVBQUU7Z0JBQ2IwSSxTQUFTb0csT0FBT3BHLE9BQU87Z0JBQ3ZCekksV0FBVzZPLE9BQU83TyxTQUFTO2dCQUMzQkUsWUFBWTJPLE9BQU8zTyxVQUFVO2dCQUM3QmtTLGVBQWV2RCxPQUFPdUQsYUFBYTtnQkFDbkNRLGdCQUFnQi9ELE9BQU8rRCxjQUFjO2dCQUNyQ0Msa0JBQWtCaEUsT0FBT2dFLGdCQUFnQjtnQkFDekNDLGdCQUFnQmpFLE9BQU9pRSxjQUFjO2dCQUNyQ1AsYUFBYTFELE9BQU8wRCxXQUFXO2dCQUMvQlEsZ0JBQWdCbEUsT0FBT2tFLGNBQWM7Z0JBQ3JDekcsUUFBUXVDLE9BQU92QyxNQUFNO2dCQUNyQjBHLGdCQUFnQm5FLE9BQU9tRSxjQUFjO2dCQUNyQ0MsaUJBQWlCcEUsT0FBT29FLGVBQWU7Z0JBQ3ZDaFEsTUFBTTRMLE9BQU81TCxJQUFJO2dCQUNqQjNDLFlBQVl1TyxPQUFPdk8sVUFBVTtnQkFDN0J3QyxZQUFZK0wsT0FBTy9MLFVBQVU7Z0JBQzdCbUIsT0FBTzRLLE9BQU81SyxLQUFLLEdBQUc7b0JBQ3BCbEUsSUFBSThPLE9BQU81SyxLQUFLLENBQUNsRSxFQUFFO29CQUNuQm9FLE1BQU0wSyxPQUFPNUssS0FBSyxDQUFDRSxJQUFJO29CQUN2QmtMLE9BQU9SLE9BQU81SyxLQUFLLENBQUNvTCxLQUFLO29CQUN6QkUsVUFBVVYsT0FBTzVLLEtBQUssQ0FBQ3NMLFFBQVE7b0JBQy9CdlAsV0FBVzZPLE9BQU81SyxLQUFLLENBQUNqRSxTQUFTO29CQUNqQ00sWUFBWXVPLE9BQU81SyxLQUFLLENBQUMzRCxVQUFVLElBQUksSUFBSWxCLE9BQU9tQixXQUFXO2dCQUMvRCxJQUFJMlM7Z0JBQ0o3TyxVQUFVd0ssT0FBT3hLLFFBQVEsR0FBRztvQkFDMUJ0RSxJQUFJOE8sT0FBT3hLLFFBQVEsQ0FBQ3RFLEVBQUU7b0JBQ3RCb0UsTUFBTTBLLE9BQU94SyxRQUFRLENBQUNGLElBQUk7b0JBQzFCZ1AsU0FBU3RFLE9BQU94SyxRQUFRLENBQUM4TyxPQUFPO29CQUNoQzdTLFlBQVl1TyxPQUFPeEssUUFBUSxDQUFDL0QsVUFBVSxJQUFJLElBQUlsQixPQUFPbUIsV0FBVztnQkFDbEUsSUFBSTJTO1lBQ047UUFFQSxNQUFNL0MsY0FBY3NELGtCQUFrQmxMLE1BQU0sQ0FBQ21MLENBQUFBLElBQzNDQSxFQUFFcEgsTUFBTSxLQUFLLFlBQWFvSCxDQUFBQSxFQUFFdEIsYUFBYSxJQUFJc0IsRUFBRWQsY0FBYyxHQUM3RDlTLE1BQU07UUFFUixNQUFNdVEsV0FBV29ELGtCQUFrQmxMLE1BQU0sQ0FBQ21MLENBQUFBO1lBQ3hDLElBQUksQ0FBQ0EsRUFBRXRCLGFBQWEsRUFBRSxPQUFPO1lBQzdCLE1BQU1DLGNBQWNxQixFQUFFdEIsYUFBYTtZQUNuQyxPQUFPQyxjQUFjO1FBQ3ZCLEdBQUd2UyxNQUFNO1FBRVQsTUFBTXdTLGFBQWFtQixrQkFBa0I5SyxNQUFNLENBQUMsQ0FBQ0MsS0FBSzhLLElBQU05SyxNQUFPOEssQ0FBQUEsRUFBRW5CLFdBQVcsSUFBSSxJQUFJO1FBQ3BGLE1BQU1DLGVBQWVyQyxjQUFjO1FBQ25DLE1BQU1HLGdCQUFnQjFJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHeUssYUFBYUU7UUFDL0MsTUFBTXhDLGlCQUFpQnFELE9BQU8sSUFBSXpMLEtBQUtvQyxLQUFLLENBQUMsY0FBZXFKLE9BQVEsT0FBTztRQUUzRXhVLFFBQVFDLEdBQUcsQ0FBQyxpREFBaUQ7WUFDM0RrUjtZQUNBRztZQUNBRTtZQUNBRCxlQUFlaUQ7WUFDZi9DLGVBQWUxSSxLQUFLb0MsS0FBSyxDQUFDc0csZ0JBQWdCLE9BQU87UUFDbkQ7UUFFQSxPQUFPO1lBQ0w3UixNQUFNZ1Y7WUFDTi9VLE9BQU87WUFDUHNSO1lBQ0FHO1lBQ0FFO1lBQ0FELGVBQWVpRDtZQUNmL0MsZUFBZTFJLEtBQUtvQyxLQUFLLENBQUNzRyxnQkFBZ0IsT0FBTztRQUNuRDtJQUVGLEVBQUUsT0FBTzVSLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLGdEQUFnREE7UUFDOUQsT0FBTztZQUNMRCxNQUFNLEVBQUU7WUFDUkMsT0FBT0E7WUFDUHNSLGdCQUFnQjtZQUNoQkcsYUFBYTtZQUNiRSxVQUFVO1lBQ1ZELGVBQWVpRDtZQUNmL0MsZUFBZTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUN6QixlQUFlcUQ7SUFDcEIsSUFBSTtRQUNGLE1BQU0sRUFBRWxWLE1BQU0sRUFBRTRKLElBQUksRUFBRSxFQUFFM0osS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FBU0MsSUFBSSxDQUFDNFYsT0FBTztRQUU3RC9VLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0J1SjtRQUMzQ3hKLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NKO1FBRTVDLElBQUlBLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLGdEQUFnREE7WUFDOUQsT0FBTztRQUNUO1FBRUEsT0FBTzJKO0lBQ1QsRUFBRSxPQUFPM0osT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsc0NBQXNDQTtRQUNwRCxPQUFPO0lBQ1Q7QUFDRjtBQUdBLCtDQUErQztBQUMvQyxlQUFlbVYsbUJBQW1CN1EsTUFBYztJQUM5QyxJQUFJO1FBQ0YsTUFBTSxFQUFFdkUsTUFBTXFWLFFBQVEsRUFBRSxHQUFHLE1BQU0vVixTQUFTQyxJQUFJLENBQUM0VixPQUFPO1FBRXRELElBQUlFLFNBQVN6TCxJQUFJLElBQUl5TCxTQUFTekwsSUFBSSxDQUFDdEksRUFBRSxLQUFLaUQsUUFBUTtnQkFJeEM4UTtZQUhSLE9BQU87Z0JBQ0wvVCxJQUFJK1QsU0FBU3pMLElBQUksQ0FBQ3RJLEVBQUU7Z0JBQ3BCc1AsT0FBT3lFLFNBQVN6TCxJQUFJLENBQUNnSCxLQUFLLElBQUk7Z0JBQzlCbEwsTUFBTTJQLEVBQUFBLHVCQUFBQSxTQUFTekwsSUFBSSxDQUFDZ0gsS0FBSyxjQUFuQnlFLDJDQUFBQSxxQkFBcUJ6UyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSTtnQkFDNUN1TyxLQUFLO2dCQUNMTCxVQUFVO2dCQUNWakQsUUFBUTtnQkFDUmhNLFlBQVksSUFBSWxCLE9BQU9tQixXQUFXO1lBQ3BDO1FBQ0Y7UUFFQSxPQUFPO0lBQ1QsRUFBRSxPQUFPN0IsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGtEQUFrRDtBQUNsRCxlQUFlcVYsMEJBQTBCL1EsTUFBYztJQUNyRCxJQUFJO1lBZVE4UTtRQWRWLHFCQUFxQjtRQUNyQixNQUFNLEVBQUVyVixNQUFNcVYsUUFBUSxFQUFFcFYsT0FBT3NWLFNBQVMsRUFBRSxHQUFHLE1BQU1qVyxTQUFTQyxJQUFJLENBQUNpVyxLQUFLLENBQUNDLFdBQVcsQ0FBQ2xSO1FBRW5GLElBQUlnUixhQUFhLENBQUNGLFNBQVN6TCxJQUFJLEVBQUU7WUFDL0J4SixRQUFRSCxLQUFLLENBQUMsNkNBQTZDc1Y7WUFDM0QsT0FBT0gsbUJBQW1CN1E7UUFDNUI7UUFFQSxzQkFBc0I7UUFDdEIsTUFBTSxFQUFFdkUsTUFBTTBWLE9BQU8sRUFBRXpWLE9BQU8wVixXQUFXLEVBQUUsR0FBRyxNQUFNclcsU0FDakRZLElBQUksQ0FBQyxTQUNMZ0MsTUFBTSxDQUFDO1lBQ05aLElBQUkrVCxTQUFTekwsSUFBSSxDQUFDdEksRUFBRTtZQUNwQnNQLE9BQU95RSxTQUFTekwsSUFBSSxDQUFDZ0gsS0FBSztZQUMxQmxMLE1BQU0yUCxFQUFBQSx1QkFBQUEsU0FBU3pMLElBQUksQ0FBQ2dILEtBQUssY0FBbkJ5RSwyQ0FBQUEscUJBQXFCelMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUk7WUFDNUNrTyxVQUFVO1lBQ1ZqRCxRQUFRO1lBQ1JoTSxZQUFZLElBQUlsQixPQUFPbUIsV0FBVztRQUNwQyxHQUNDM0IsTUFBTSxHQUNOZ0MsTUFBTTtRQUVULElBQUl3VCxhQUFhO1lBQ2Z2VixRQUFRSCxLQUFLLENBQUMsdURBQXVEMFY7WUFDckUsT0FBT1AsbUJBQW1CN1E7UUFDNUI7UUFFQW5FLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE9BQU9xVjtJQUNULEVBQUUsT0FBT3pWLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBT21WLG1CQUFtQjdRO0lBQzVCO0FBQ0Y7QUFHQSxnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUN6QixlQUFlcVIscUJBQXFCQyxTQUFpQixFQUFFQyxXQUE2QjtJQUN6RjFWLFFBQVFDLEdBQUcsQ0FBQywwQ0FBMEM7UUFBRXdWO1FBQVdDO0lBQVk7SUFFL0UsTUFBTSxFQUFFOVYsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLFlBQ0xrRSxNQUFNLENBQUM7UUFDTixHQUFHMFIsV0FBVztRQUNkelIsWUFBWSxJQUFJMUQsT0FBT21CLFdBQVc7SUFDcEMsR0FDQ1gsRUFBRSxDQUFDLE1BQU0wVSxXQUNUMVYsTUFBTSxHQUNOZ0MsTUFBTTtJQUVUL0IsUUFBUUMsR0FBRyxDQUFDLCtCQUErQjtRQUFFTDtRQUFNQztJQUFNO0lBQ3pELE9BQU9BLFFBQVE7UUFBRUQsTUFBTTtRQUFNQztJQUFNLElBQUk7UUFBRUQ7UUFBTUMsT0FBTztJQUFLO0FBQzdEO0FBRU8sZUFBZThWLHFCQUFxQkYsU0FBaUI7SUFDMUR6VixRQUFRQyxHQUFHLENBQUMsNkNBQTZDd1Y7SUFFekQsTUFBTSxFQUFFN1YsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLFlBQ0w4VixNQUFNLEdBQ043VSxFQUFFLENBQUMsTUFBTTBVO0lBRVp6VixRQUFRQyxHQUFHLENBQUMsK0JBQStCO1FBQUVMO1FBQU1DO0lBQU07SUFDekQsT0FBTztRQUFFRDtRQUFNQztJQUFNO0FBQ3ZCO0FBRUEsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDekIsZUFBZWdXLFlBQVkvVSxRQUFpQjtJQUNqRGQsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ2E7SUFFdEQsSUFBSXlELFFBQVFyRixTQUNUWSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFFLGdGQU9SaUIsS0FBSyxDQUFDLGdCQUFnQjtRQUFFd0QsV0FBVztJQUFNO0lBRTVDLElBQUkxRCxVQUFVO1FBQ1p5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQ2hDO0lBRUEsTUFBTSxFQUFFbEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNMEU7SUFFOUJ2RSxRQUFRQyxHQUFHLENBQUMseUJBQXlCO1FBQUVMO1FBQU1DO0lBQU07SUFDbkQsT0FBT0EsUUFBUTtRQUFFRCxNQUFNLEVBQUU7UUFBRUM7SUFBTSxJQUFJO1FBQUVELE1BQU1BLFFBQVEsRUFBRTtRQUFFQyxPQUFPO0lBQUs7QUFDdkU7QUFFQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUN6QixlQUFlaVcscUJBQXFCaFYsUUFBaUI7SUFDMURkLFFBQVFDLEdBQUcsQ0FBQyxtREFBbURhO0lBRS9ELElBQUl5RCxRQUFRckYsU0FBU1ksSUFBSSxDQUFDLFlBQVlDLE1BQU0sQ0FBQztJQUU3QyxJQUFJZSxVQUFVO1FBQ1p5RCxRQUFRQSxNQUFNeEQsRUFBRSxDQUFDLGFBQWFEO0lBQ2hDO0lBRUEsTUFBTSxFQUFFbEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNMEU7SUFFOUIsSUFBSTFFLE9BQU87UUFDVEcsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQ0o7UUFDdkQsT0FBTztZQUNMRCxNQUFNO2dCQUNKbVcsZUFBZTtnQkFDZkMsdUJBQXVCO1lBQ3pCO1lBQ0FuVztRQUNGO0lBQ0Y7SUFFQSxNQUFNa1csZ0JBQWdCblcsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNa0ssTUFBTSxDQUFDLENBQUNDLEtBQUtrTSxVQUFZbE0sTUFBT2tNLENBQUFBLFFBQVF2SSxNQUFNLElBQUksSUFBSSxPQUFNO0lBQ3hGLE1BQU13SSxtQkFBbUJ0VyxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1xQixNQUFNLEtBQUk7SUFDekMsTUFBTStVLHdCQUF3QkUsbUJBQW1CLElBQUluTixLQUFLb0MsS0FBSyxDQUFDNEssZ0JBQWdCRyxvQkFBb0I7SUFFcEcsTUFBTXRJLGFBQWE7UUFDakJtSTtRQUNBQztJQUNGO0lBRUFoVyxRQUFRQyxHQUFHLENBQUMsbUNBQW1DMk47SUFDL0MsT0FBTztRQUFFaE8sTUFBTWdPO1FBQVkvTixPQUFPO0lBQUs7QUFDekM7QUFFQSxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUN6QixlQUFlc1cscUJBQXFCVCxXQU0xQztJQUNDMVYsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ3lWO0lBRXRELE1BQU1VLGtCQUFrQjtRQUN0QmpWLFdBQVd1VSxZQUFZdlUsU0FBUyxJQUFJO1FBQ3BDa1YsVUFBVVgsWUFBWVcsUUFBUTtRQUM5QkMsYUFBYVosWUFBWVksV0FBVztRQUNwQzVJLFFBQVFnSSxZQUFZaEksTUFBTTtRQUMxQjZJLE9BQU9iLFlBQVlhLEtBQUssSUFBSTtRQUM1QkMsY0FBYyxJQUFJalcsT0FBT21CLFdBQVcsR0FBR2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3BEaUwsUUFBUTtRQUNSaE0sWUFBWSxJQUFJbEIsT0FBT21CLFdBQVc7SUFDcEM7SUFFQTFCLFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJtVztJQUV4QyxNQUFNLEVBQUV4VyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsWUFDTGdDLE1BQU0sQ0FBQ3NVLGlCQUNQclcsTUFBTSxHQUNOZ0MsTUFBTTtJQUVUL0IsUUFBUUMsR0FBRyxDQUFDLCtCQUErQjtRQUFFTDtRQUFNQztJQUFNO0lBRXpELElBQUlBLE9BQU87UUFDVEcsUUFBUUgsS0FBSyxDQUFDLGlCQUFpQkE7SUFDakM7SUFFQSxPQUFPQSxRQUFRO1FBQUVELE1BQU07UUFBTUM7SUFBTSxJQUFJO1FBQUVEO1FBQU1DLE9BQU87SUFBSztBQUM3RDtBQVdPLGVBQWU0VztJQUNwQixJQUFJO1FBQ0Z6VyxRQUFRQyxHQUFHLENBQUM7UUFFWixtREFBbUQ7UUFDbkQsTUFBTSxFQUFFTCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFFLHdEQUlSaUIsS0FBSyxDQUFDLGNBQWM7WUFBRXdELFdBQVc7UUFBTTtRQUUxQyxJQUFJM0UsT0FBTztZQUNURyxRQUFRSCxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxPQUFPO2dCQUFFRCxNQUFNO2dCQUFNQztZQUFNO1FBQzdCO1FBRUFHLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NMLGlCQUFBQSwyQkFBQUEsS0FBTXFCLE1BQU07UUFDNUQsT0FBTztZQUFFckI7WUFBTUMsT0FBTztRQUFLO0lBQzdCLEVBQUUsT0FBT0EsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsdUJBQXVCQTtRQUNyQyxPQUFPO1lBQUVELE1BQU07WUFBTUM7UUFBTTtJQUM3QjtBQUNGO0FBRU8sZUFBZTZXLG9CQUNwQmpCLFNBQWlCLEVBQ2pCaEksTUFBd0MsRUFDeENrSixlQUF3QjtJQUV4QixJQUFJO1FBQ0YzVyxRQUFRQyxHQUFHLENBQUMsK0JBQStCO1lBQUV3VjtZQUFXaEk7WUFBUWtKO1FBQWdCO1FBRWhGLDhDQUE4QztRQUM5QyxNQUFNM0gsYUFBa0I7WUFDdEJ2QjtZQUNBeEosWUFBWSxJQUFJMUQsT0FBT21CLFdBQVc7UUFDcEM7UUFFQSxrREFBa0Q7UUFDbEQsSUFBSStMLFdBQVcsY0FBY2tKLGlCQUFpQjtZQUM1QzNILFdBQVc0SCxnQkFBZ0IsR0FBR0Q7UUFDaEM7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSWxKLFdBQVcsY0FBY0EsV0FBVyxRQUFRO1lBQzlDdUIsV0FBVzRILGdCQUFnQixHQUFHO1FBQ2hDO1FBRUEsTUFBTSxFQUFFaFgsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUMzQlksSUFBSSxDQUFDLFlBQ0xrRSxNQUFNLENBQUNnTCxZQUNQak8sRUFBRSxDQUFDLE1BQU0wVSxXQUNUMVYsTUFBTSxDQUFDLEtBQ1BnQyxNQUFNO1FBRVQsSUFBSWxDLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsT0FBTztnQkFBRUQsTUFBTTtnQkFBTUM7WUFBTTtRQUM3QjtRQUVBRyxRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPO1lBQUVMO1lBQU1DLE9BQU87UUFBSztJQUM3QixFQUFFLE9BQU9BLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLHVCQUF1QkE7UUFDckMsT0FBTztZQUFFRCxNQUFNO1lBQU1DO1FBQU07SUFDN0I7QUFDRjtBQUVPLGVBQWVnWCw2QkFBNkIvVixRQUFpQjtJQUNsRSxJQUFJO1FBQ0YsSUFBSXlELFFBQVFyRixTQUNUWSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFDO1FBRVYsSUFBSWUsWUFBWUEsYUFBYSxPQUFPO1lBQ2xDeUQsUUFBUUEsTUFBTXhELEVBQUUsQ0FBQyxhQUFhRDtRQUNoQztRQUVBLE1BQU0sRUFBRWxCLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTTBFO1FBRTlCLElBQUkxRSxPQUFPO1lBQ1RHLFFBQVFILEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE9BQU87Z0JBQ0xpWCxPQUFPO2dCQUNQQyxTQUFTO2dCQUNUQyxVQUFVO2dCQUNWQyxVQUFVO2dCQUNWQyxNQUFNO2dCQUNOQyxhQUFhO2dCQUNiOUosZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQjhKLGdCQUFnQjtnQkFDaEJDLFlBQVk7WUFDZDtRQUNGO1FBRUEsTUFBTWpFLFFBQVE7WUFDWjBELE9BQU9sWCxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1xQixNQUFNLEtBQUk7WUFDdkI4VixTQUFTblgsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNOEosTUFBTSxDQUFDNkksQ0FBQUEsSUFBS0EsRUFBRTlFLE1BQU0sS0FBSyxXQUFXeE0sTUFBTSxLQUFJO1lBQzdEK1YsVUFBVXBYLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTThKLE1BQU0sQ0FBQzZJLENBQUFBLElBQUtBLEVBQUU5RSxNQUFNLEtBQUssWUFBWXhNLE1BQU0sS0FBSTtZQUMvRGdXLFVBQVVyWCxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU04SixNQUFNLENBQUM2SSxDQUFBQSxJQUFLQSxFQUFFOUUsTUFBTSxLQUFLLFlBQVl4TSxNQUFNLEtBQUk7WUFDL0RpVyxNQUFNdFgsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNOEosTUFBTSxDQUFDNkksQ0FBQUEsSUFBS0EsRUFBRTlFLE1BQU0sS0FBSyxRQUFReE0sTUFBTSxLQUFJO1lBQ3ZEa1csYUFBYXZYLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTWtLLE1BQU0sQ0FBQyxDQUFDQyxLQUFLd0ksSUFBTXhJLE1BQU93SSxDQUFBQSxFQUFFN0UsTUFBTSxJQUFJLElBQUksT0FBTTtZQUNuRUwsZUFBZXpOLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTThKLE1BQU0sQ0FBQzZJLENBQUFBLElBQUtBLEVBQUU5RSxNQUFNLEtBQUssV0FBVzNELE1BQU0sQ0FBQyxDQUFDQyxLQUFLd0ksSUFBTXhJLE1BQU93SSxDQUFBQSxFQUFFN0UsTUFBTSxJQUFJLElBQUksT0FBTTtZQUN6R0osZ0JBQWdCMU4sQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNOEosTUFBTSxDQUFDNkksQ0FBQUEsSUFBS0EsRUFBRTlFLE1BQU0sS0FBSyxZQUFZM0QsTUFBTSxDQUFDLENBQUNDLEtBQUt3SSxJQUFNeEksTUFBT3dJLENBQUFBLEVBQUU3RSxNQUFNLElBQUksSUFBSSxPQUFNO1lBQzNHMEosZ0JBQWdCeFgsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNOEosTUFBTSxDQUFDNkksQ0FBQUEsSUFBS0EsRUFBRTlFLE1BQU0sS0FBSyxZQUFZM0QsTUFBTSxDQUFDLENBQUNDLEtBQUt3SSxJQUFNeEksTUFBT3dJLENBQUFBLEVBQUU3RSxNQUFNLElBQUksSUFBSSxPQUFNO1lBQzNHMkosWUFBWXpYLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTThKLE1BQU0sQ0FBQzZJLENBQUFBLElBQUtBLEVBQUU5RSxNQUFNLEtBQUssUUFBUTNELE1BQU0sQ0FBQyxDQUFDQyxLQUFLd0ksSUFBTXhJLE1BQU93SSxDQUFBQSxFQUFFN0UsTUFBTSxJQUFJLElBQUksT0FBTTtRQUNyRztRQUVBLE9BQU8wRjtJQUNULEVBQUUsT0FBT3ZULE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLHFEQUFxREE7UUFDbkUsT0FBTztZQUNMaVgsT0FBTztZQUNQQyxTQUFTO1lBQ1RDLFVBQVU7WUFDVkMsVUFBVTtZQUNWQyxNQUFNO1lBQ05DLGFBQWE7WUFDYjlKLGVBQWU7WUFDZkMsZ0JBQWdCO1lBQ2hCOEosZ0JBQWdCO1lBQ2hCQyxZQUFZO1FBQ2Q7SUFDRjtBQUNGO0FBRU8sZUFBZUMsb0JBQW9CN0osTUFBYyxFQUFFM00sUUFBaUI7SUFDekUsSUFBSTtRQUNGLElBQUl5RCxRQUFRckYsU0FDVFksSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBRSx5RkFLUmdCLEVBQUUsQ0FBQyxVQUFVME0sUUFDYnpNLEtBQUssQ0FBQyxjQUFjO1lBQUV3RCxXQUFXO1FBQU07UUFFMUMsSUFBSTFELFlBQVlBLGFBQWEsT0FBTztZQUNsQ3lELFFBQVFBLE1BQU14RCxFQUFFLENBQUMsYUFBYUQ7UUFDaEM7UUFFQSxNQUFNLEVBQUVsQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU0wRTtRQUU5QixJQUFJMUUsT0FBTztZQUNURyxRQUFRSCxLQUFLLENBQUMsa0JBQXlCLE9BQVA0TixRQUFPLGVBQWE1TjtZQUNwRCxPQUFPO2dCQUFFRCxNQUFNLEVBQUU7Z0JBQUVDO1lBQU07UUFDM0I7UUFFQSxPQUFPO1lBQUVELE1BQU1BLFFBQVEsRUFBRTtZQUFFQyxPQUFPO1FBQUs7SUFDekMsRUFBRSxPQUFPQSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyxxQkFBcUJBO1FBQ25DLE9BQU87WUFBRUQsTUFBTSxFQUFFO1lBQUVDO1FBQU07SUFDM0I7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsZ0NBQWdDO0FBRXpCLGVBQWUwWDtJQUNwQnZYLFFBQVFDLEdBQUcsQ0FBQztJQUVaLE1BQU0ySCxRQUFRLElBQUlySCxPQUFPbUIsV0FBVyxHQUFHYyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFFcEQsSUFBSTtRQUNGLE1BQU0sRUFBRTVDLE1BQU00TixlQUFlLEVBQUUzTixPQUFPMlgsY0FBYyxFQUFFLEdBQUcsTUFBTXRZLFNBQzVEWSxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLEtBQ1BnQixFQUFFLENBQUMsVUFBVSxVQUNiQyxLQUFLLENBQUM7UUFFVCxJQUFJd1csZ0JBQWdCO1lBQ2xCeFgsUUFBUUgsS0FBSyxDQUFDLHlDQUF5QzJYO1lBQ3ZELE9BQU8sRUFBRTtRQUNYO1FBRUEsTUFBTSxFQUFFNVgsTUFBTTZYLGVBQWUsRUFBRTVYLE9BQU9nUSxlQUFlLEVBQUUsR0FBRyxNQUFNM1EsU0FDN0RZLElBQUksQ0FBQyxjQUNMQyxNQUFNLENBQUMsV0FDUGdCLEVBQUUsQ0FBQyxRQUFRNkc7UUFFZCxJQUFJaUksaUJBQWlCO1lBQ25CN1AsUUFBUUgsS0FBSyxDQUFDLDJDQUEyQ2dRO1lBQ3pELE9BQU8sRUFBRTtRQUNYO1FBRUEsTUFBTTZILHFCQUFxQixJQUFJN0wsSUFBSTRMLENBQUFBLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCOVEsR0FBRyxDQUFDLENBQUNnRSxJQUFNQSxFQUFFZixPQUFPLE1BQUssRUFBRTtRQUMvRSxNQUFNK04sa0JBQWtCbkssQ0FBQUEsNEJBQUFBLHNDQUFBQSxnQkFBaUI5RCxNQUFNLENBQUMsQ0FBQzBGLFdBQWEsQ0FBQ3NJLG1CQUFtQkUsR0FBRyxDQUFDeEksU0FBU2xPLEVBQUUsT0FBTSxFQUFFO1FBRXpHLE1BQU0yVyw2QkFBeUNGLGdCQUFnQmhSLEdBQUcsQ0FBQyxDQUFDNkMsT0FBZTtnQkFDakZ0SSxJQUFJc0ksS0FBS3RJLEVBQUU7Z0JBQ1hvRSxNQUFNa0UsS0FBS2xFLElBQUk7Z0JBQ2ZrTCxPQUFPaEgsS0FBS2dILEtBQUssSUFBSTtnQkFDckJDLE9BQU9qSCxLQUFLaUgsS0FBSyxJQUFJO2dCQUNyQkMsVUFBVWxILEtBQUtrSCxRQUFRLElBQUk7Z0JBQzNCakQsUUFBUWpFLEtBQUtpRSxNQUFNLElBQUk7Z0JBQ3ZCcUssUUFBUSw2Q0FBMkUsT0FBOUJDLG1CQUFtQnZPLEtBQUtsRSxJQUFJO2dCQUNqRjRMLFFBQVE7Z0JBQ1JOLFlBQVk7Z0JBQ1pPLGdCQUFnQjtnQkFDaEJDLHVCQUF1QjtnQkFDdkJDLGdCQUFnQjtnQkFDaEJDLGFBQWE7Z0JBQ2JDLGVBQWU7Z0JBQ2ZDLFVBQVU7Z0JBQ1ZDLGVBQWU7Z0JBQ2ZDLGNBQWM7Z0JBQ2RDLGFBQWE7Z0JBQ2JDLGVBQWU7Z0JBQ2ZmLGdCQUFnQjtnQkFDaEJtSCxVQUFVeE8sS0FBSy9ILFVBQVU7Z0JBQ3pCb1EsZUFBZTtnQkFDZkMsYUFBYTtnQkFDYkMsZ0JBQWdCO2dCQUNoQmhCLEtBQUt2SCxLQUFLdUgsR0FBRyxJQUFJO1lBQ25CO1FBRUEvUSxRQUFRQyxHQUFHLENBQUMsZ0NBQWdDNFgsMkJBQTJCNVcsTUFBTTtRQUM3RSxPQUFPNFc7SUFDVCxFQUFFLE9BQU9oWSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQywwQ0FBMENBO1FBQ3hELE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUN6QixlQUFlb1ksNkJBQTZCN1QsSUFBYTtJQUM5RCxJQUFJRyxRQUFRckYsU0FDVFksSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBRSxrT0FlUmlCLEtBQUssQ0FBQyxRQUFRO1FBQUV3RCxXQUFXO0lBQU0sR0FDakN4RCxLQUFLLENBQUMsY0FBYztRQUFFd0QsV0FBVztJQUFNO0lBRTFDLElBQUlKLE1BQU07UUFDUkcsUUFBUUEsTUFBTXhELEVBQUUsQ0FBQyxRQUFRcUQ7SUFDM0I7SUFFQSxNQUFNLEVBQUV4RSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU0wRTtJQUU5QixJQUFJMUUsT0FBTztRQUNURyxRQUFRSCxLQUFLLENBQUMsNENBQTRDQTtRQUMxRCxPQUFPO1lBQUVELE1BQU0sRUFBRTtZQUFFQztRQUFNO0lBQzNCO0lBRUEsT0FBTztRQUFFRCxNQUFNQSxRQUFRLEVBQUU7UUFBRUMsT0FBTztJQUFLO0FBQ3pDO0FBbUJBLDBCQUEwQjtBQUNuQixNQUFNcVksaUJBQWlCLE9BQU9DO0lBQ25DLElBQUk7UUFDRixNQUFNLEVBQUV2WSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBQyxLQUNQZ0IsRUFBRSxDQUFDLGFBQWFvWCxVQUNoQm5YLEtBQUssQ0FBQyxjQUFjO1lBQUV3RCxXQUFXO1FBQU07UUFFMUMsSUFBSTNFLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTztnQkFBRUQsTUFBTTtnQkFBTUM7WUFBTTtRQUM3QjtRQUVBLE9BQU87WUFBRUQ7WUFBTUMsT0FBTztRQUFLO0lBQzdCLEVBQUUsT0FBT0EsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsdUNBQXVDQTtRQUNyRCxPQUFPO1lBQUVELE1BQU07WUFBTUM7UUFBTTtJQUM3QjtBQUNGLEVBQUU7QUFFRiwyQ0FBMkM7QUFDcEMsTUFBTXVZLG9CQUFvQixPQUMvQkQsVUFDQTVQLFdBQ0FPO0lBRUEsSUFBSTtRQUNGLHVEQUF1RDtRQUN2RCxNQUFNLEVBQUVsSixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsZ0JBQ0wwRCxNQUFNLENBQUM7WUFDTjZVLFdBQVdGO1lBQ1h0UixZQUFZMEI7WUFDWitQLGdCQUFnQnhQO1lBQ2hCdEgsV0FBVztZQUNYK1cscUJBQXFCO1lBQ3JCdFUsWUFBWSxJQUFJMUQsT0FBT21CLFdBQVc7UUFDcEMsR0FBRztZQUNEOFcsWUFBWTtRQUNkLEdBQ0N6WSxNQUFNLEdBQ05nQyxNQUFNO1FBRVQsSUFBSWxDLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTztnQkFBRUQsTUFBTTtnQkFBTUM7WUFBTTtRQUM3QjtRQUVBLE9BQU87WUFBRUQ7WUFBTUMsT0FBTztRQUFLO0lBQzdCLEVBQUUsT0FBT0EsT0FBTztRQUNkRyxRQUFRSCxLQUFLLENBQUMsMENBQTBDQTtRQUN4RCxPQUFPO1lBQUVELE1BQU07WUFBTUM7UUFBTTtJQUM3QjtBQUNGLEVBQUU7QUFFRiwwQ0FBMEM7QUFDbkMsTUFBTTRZLG9CQUFvQjtJQUMvQixJQUFJO1FBQ0YseUNBQXlDO1FBQ3pDLE1BQU0sRUFBRTdZLE1BQU04WSxRQUFRLEVBQUU3WSxPQUFPK0ksVUFBVSxFQUFFLEdBQUcsTUFBTTFKLFNBQ2pEWSxJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBQyxLQUNQZ0IsRUFBRSxDQUFDLGFBQWE7UUFFbkIsSUFBSTZILFlBQVk7WUFDZDVJLFFBQVFILEtBQUssQ0FBQyxnQ0FBZ0MrSTtZQUM5QyxPQUFPO2dCQUFFaEosTUFBTTtnQkFBTUMsT0FBTytJO1lBQVc7UUFDekM7UUFFQSxnQ0FBZ0M7UUFDaEMsTUFBTStQLFdBQVcsQ0FBQ0QsWUFBWSxFQUFFLEVBQUVoUCxNQUFNLENBQUM5QyxDQUFBQSxPQUN2Q0EsS0FBSzBSLGNBQWMsSUFBSTFSLEtBQUsyUixtQkFBbUI7UUFHakQsT0FBTztZQUFFM1ksTUFBTStZO1lBQVU5WSxPQUFPO1FBQUs7SUFDdkMsRUFBRSxPQUFPQSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQywwQ0FBMENBO1FBQ3hELE9BQU87WUFBRUQsTUFBTTtZQUFNQztRQUFNO0lBQzdCO0FBQ0YsRUFBRTtBQUVGLDJDQUEyQztBQUMzQyxtREFBbUQ7QUFDNUMsTUFBTStZLG9CQUFvQixPQUMvQlQsVUFDQTVQLFdBQ0FHO0lBRUEsSUFBSTtRQUNGLG9CQUFvQjtRQUNwQixNQUFNLEVBQUU5SSxNQUFNaUosWUFBWSxFQUFFaEosT0FBTytJLFVBQVUsRUFBRSxHQUFHLE1BQU0xSixTQUNyRFksSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUMsa0JBQ1BnQixFQUFFLENBQUMsYUFBYW9YLFVBQ2hCcFgsRUFBRSxDQUFDLGNBQWN3SCxXQUNqQnhHLE1BQU07UUFFVCxJQUFJNkcsWUFBWTtZQUNkNUksUUFBUUgsS0FBSyxDQUFDLGlDQUFpQytJO1lBQy9DLE9BQU87Z0JBQUVoSixNQUFNO2dCQUFNQyxPQUFPK0k7WUFBVztRQUN6QztRQUVBLE1BQU1FLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNILENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY3lQLGNBQWMsS0FBSSxLQUFLNVA7UUFFbkUsZUFBZTtRQUNmLE1BQU0sRUFBRTlJLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FDM0JZLElBQUksQ0FBQyxnQkFDTGtFLE1BQU0sQ0FBQztZQUNOc1UsZ0JBQWdCeFA7WUFDaEI3RSxZQUFZLElBQUkxRCxPQUFPbUIsV0FBVztRQUNwQyxHQUNDWCxFQUFFLENBQUMsYUFBYW9YLFVBQ2hCcFgsRUFBRSxDQUFDLGNBQWN3SCxXQUNqQnhJLE1BQU0sQ0FBRSwwR0FLUmdDLE1BQU07UUFFVCxJQUFJbEMsT0FBTztZQUNURyxRQUFRSCxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxPQUFPO2dCQUFFRCxNQUFNO2dCQUFNQztZQUFNO1FBQzdCO1FBRUEsT0FBTztZQUFFRDtZQUFNQyxPQUFPO1FBQUs7SUFDN0IsRUFBRSxPQUFPQSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQywwQ0FBMENBO1FBQ3hELE9BQU87WUFBRUQsTUFBTTtZQUFNQztRQUFNO0lBQzdCO0FBQ0YsRUFBRTtBQUVGLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsZ0NBQWdDO0FBRXpCLE1BQU1nWixtQkFBbUIsT0FBTzNaLFVBQWU0WixhQUFrQkM7SUFDdEUsTUFBTSxFQUFFblosSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUFTWSxJQUFJLENBQUMsWUFBWUMsTUFBTSxDQUFDO0lBQy9ELElBQUlGLE9BQU87UUFDVEcsUUFBUUgsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekM7SUFDRjtJQUNBaVosWUFBWWxaO0lBQ1osSUFBSUEsS0FBS3FCLE1BQU0sR0FBRyxHQUFHO1FBQ25COFgsa0JBQWtCblosSUFBSSxDQUFDLEVBQUUsQ0FBQzBGLElBQUk7SUFDaEM7QUFDRixFQUFDO0FBRU0sTUFBTTBULGlCQUFpQixPQUFPOVosVUFBZStaLG9CQUF5QkM7SUFDM0VsWixRQUFRQyxHQUFHLENBQUM7SUFDWixJQUFJO1FBQ0YsTUFBTSxFQUFFTCxNQUFNdVosWUFBWSxFQUFFdFosT0FBT3VaLGFBQWEsRUFBRSxHQUFHLE1BQU1sYSxTQUN4RFksSUFBSSxDQUFDLHFCQUNMQyxNQUFNLENBQUMsS0FDUGdCLEVBQUUsQ0FBQyxhQUFhLE1BQ2hCZ0IsTUFBTTtRQUVULElBQUlxWCxlQUFlO1lBQ2pCcFosUUFBUUgsS0FBSyxDQUFDLG1DQUFtQ3VaO1FBQ25ELE9BQU87WUFDTHBaLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NrWjtZQUM1Q0YsbUJBQW1CRTtRQUNyQjtRQUVBblosUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPSixPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQywyQ0FBMkNBO0lBQzNEO0FBQ0YsRUFBQztBQUVNLE1BQU13WixxQkFBcUIsT0FDaENuYSxVQUNBc0csVUFDQThULGdCQUNBQyxNQUNBQyxhQUNBQyxlQUNBQyxjQUNBQyxnQkFDQUMsZUFDQUMsbUJBQ0FDO0lBRUEsTUFBTUMscUJBQXFCdlUsU0FBU3dVLElBQUksQ0FBQyxDQUFDcFAsSUFBTUEsRUFBRXRGLElBQUksS0FBS2dVO0lBRTNELElBQUksRUFBQ1MsK0JBQUFBLHlDQUFBQSxtQkFBb0I3WSxFQUFFLEdBQUU7UUFDM0IsTUFBTSxJQUFJakMsTUFBTTtJQUNsQjtJQUVBLE1BQU1nYixnQkFBZ0IsR0FBOEJqSSxPQUEzQixJQUFJelIsT0FBTzZKLFdBQVcsSUFBMEQ0SCxPQUFyREEsT0FBTyxJQUFJelIsT0FBTzJKLFFBQVEsS0FBSyxHQUFHOUIsUUFBUSxDQUFDLEdBQUcsTUFBdUQ0SixPQUFoREEsT0FBTyxJQUFJelIsT0FBT0ssT0FBTyxJQUFJd0gsUUFBUSxDQUFDLEdBQUcsTUFBaUUsT0FBMUQ0SixPQUFPakosS0FBS21SLEtBQUssQ0FBQ25SLEtBQUtvUixNQUFNLEtBQUssT0FBTy9SLFFBQVEsQ0FBQyxHQUFHO0lBRTlNLE1BQU14RCxrQkFBa0I7UUFDdEJpQixnQkFBZ0JvVTtRQUNoQjlZLFdBQVc0WSxtQkFBbUI3WSxFQUFFO1FBQ2hDZ0YsY0FBYzBUO1FBQ2R2VCxpQkFBaUJ3VDtRQUNqQk8sY0FBY047UUFDZDFULGdCQUFnQnFUO1FBQ2hCWSxlQUFlWCxnQkFBZ0I7UUFDL0JuRCxPQUFPb0Qsa0JBQWtCO0lBQzNCO0lBRUEzWixRQUFRQyxHQUFHLENBQUMscURBQXFEMkU7SUFDakUsT0FBT0E7QUFDVCxFQUFDO0FBRUQsZ0NBQWdDO0FBQ2hDLDhEQUE4RDtBQUM5RCxnQ0FBZ0M7QUFDekIsTUFBTTBWLDRCQUE0QixDQUFDQztJQUN4QyxNQUFNQyxVQUFVdGIsU0FDYnNiLE9BQU8sQ0FBQyx1QkFDUkMsRUFBRSxDQUFDLG9CQUNGO1FBQ0VDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxPQUFPO0lBQ1QsR0FDQSxDQUFDQztRQUNDN2EsUUFBUUMsR0FBRyxDQUFDLGdDQUFnQzRhO1FBQzVDTjtJQUNGLEdBRURFLEVBQUUsQ0FBQyxvQkFDRjtRQUNFQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsT0FBTztJQUNULEdBQ0EsQ0FBQ0M7UUFDQzdhLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUM0YTtRQUNqRE47SUFDRixHQUVETyxTQUFTLENBQUMsQ0FBQ3JOO1FBQ1Z6TixRQUFRQyxHQUFHLENBQUMsaUNBQWlDd047SUFDL0M7SUFFRixPQUFPK007QUFDVCxFQUFFO0FBRUYsOENBQThDO0FBQ3ZDLE1BQU1PLHNCQUFzQixDQUFDUjtJQUNsQyxNQUFNQyxVQUFVdGIsU0FDYnNiLE9BQU8sQ0FBQyxpQkFDUkMsRUFBRSxDQUFDLG9CQUNGO1FBQ0VDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxPQUFPO0lBQ1QsR0FDQSxDQUFDQztRQUNDN2EsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQzRhO1FBQ2hETjtJQUNGLEdBRURPLFNBQVMsQ0FBQyxDQUFDck47UUFDVnpOLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0J3TjtJQUM3QztJQUVGLE9BQU8rTTtBQUNULEVBQUU7QUFFRiw0REFBNEQ7QUFDckQsTUFBTVEsNEJBQTRCLE9BQU9DLFdBQW1CSjtJQUNqRSxJQUFJO1FBQ0YsTUFBTTNiLFNBQVNzYixPQUFPLENBQUMsaUJBQWlCVSxJQUFJLENBQUM7WUFDM0MvWCxNQUFNO1lBQ051WCxPQUFPTztZQUNQSixTQUFTQTtRQUNYO1FBQ0E3YSxRQUFRQyxHQUFHLENBQUMsb0JBQThCLE9BQVZnYixXQUFVO0lBQzVDLEVBQUUsT0FBT3BiLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDZCQUE2QkE7SUFDN0M7QUFDRixFQUFFO0FBRUYsNkNBQTZDO0FBQ3RDLE1BQU1zYiw0QkFBNEIsQ0FBQ1o7SUFDeEMsTUFBTUMsVUFBVXRiLFNBQVNzYixPQUFPLENBQUMsMEJBQzlCQyxFQUFFLENBQUMsYUFBYTtRQUFFQyxPQUFPO0lBQUksR0FBRyxDQUFDRztRQUNoQzdhLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEI0YTtRQUN0Q04sU0FBU00sUUFBUUgsS0FBSyxFQUFFRyxRQUFRQSxPQUFPO0lBQ3pDLEdBQ0NDLFNBQVM7SUFFWixPQUFPTjtBQUNULEVBQUU7QUFFRixzQ0FBc0M7QUFDL0IsTUFBTVksb0JBQW9CLENBQUNiO0lBQ2hDLE1BQU1DLFVBQVV0YixTQUFTc2IsT0FBTyxDQUFDLDBCQUM5QkMsRUFBRSxDQUFDLGFBQWE7UUFBRUMsT0FBTztJQUFJLEdBQUcsQ0FBQ0c7UUFDaEM3YSxRQUFRQyxHQUFHLENBQUMsMEJBQTBCNGE7UUFDdENOLFNBQVNNLFFBQVFILEtBQUssRUFBRUcsUUFBUUEsT0FBTztJQUN6QyxHQUNDQyxTQUFTO0lBRVosT0FBT047QUFDVCxFQUFFO0FBRUYsZ0NBQWdDO0FBQ2hDLDZEQUE2RDtBQUM3RCxnQ0FBZ0M7QUFDekIsTUFBTWEsd0JBQXdCLENBQUNkO0lBQ3BDdmEsUUFBUUMsR0FBRyxDQUFDO0lBRVosTUFBTXVhLFVBQVV0YixTQUNic2IsT0FBTyxDQUFDLG9CQUNSQyxFQUFFLENBQUMsb0JBQ0Y7UUFDRUMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLE9BQU87SUFDVCxHQUNBLENBQUNDO1FBQ0M3YSxRQUFRQyxHQUFHLENBQUMsNkJBQTZCNGE7UUFDekNOO0lBQ0YsR0FFREUsRUFBRSxDQUFDLG9CQUNGO1FBQ0VDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxPQUFPO0lBQ1QsR0FDQSxDQUFDQztRQUNDN2EsUUFBUUMsR0FBRyxDQUFDLG9EQUFvRDRhO1FBQ2hFTjtJQUNGLEdBRURFLEVBQUUsQ0FBQyxvQkFDRjtRQUNFQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsT0FBTztJQUNULEdBQ0EsQ0FBQ0M7UUFDQzdhLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0I0YTtRQUMzQ047SUFDRixHQUVETyxTQUFTLENBQUMsQ0FBQ3JOO1FBQ1Z6TixRQUFRQyxHQUFHLENBQUMsMENBQTBDd047SUFDeEQ7SUFFRixPQUFPK007QUFDVCxFQUFFO0FBRUssZUFBZWM7SUFDcEIsSUFBSTtRQUNGdGIsUUFBUUMsR0FBRyxDQUFDO1FBRVosTUFBTSxFQUFFTCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFFLHdEQUlSeUwsRUFBRSxDQUFDLFVBQVU7WUFBQztZQUFZO1NBQU8sRUFDakN4SyxLQUFLLENBQUMsY0FBYztZQUFFd0QsV0FBVztRQUFNO1FBRTFDLElBQUkzRSxPQUFPO1lBQ1RHLFFBQVFILEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELE9BQU87Z0JBQUVELE1BQU0sRUFBRTtnQkFBRUM7WUFBTTtRQUMzQjtRQUVBRyxRQUFRQyxHQUFHLENBQUMsNkNBQTZDTCxpQkFBQUEsMkJBQUFBLEtBQU1xQixNQUFNO1FBQ3JFLE9BQU87WUFBRXJCO1lBQU1DLE9BQU87UUFBSztJQUM3QixFQUFFLE9BQU9BLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLHVCQUF1QkE7UUFDckMsT0FBTztZQUFFRCxNQUFNLEVBQUU7WUFBRUM7UUFBTTtJQUMzQjtBQUNGO0FBQ0EseUNBQXlDO0FBQ2xDLE1BQU0wYixjQUFjO0lBQ3pCLElBQUk7UUFDRixNQUFNLEVBQUUzYixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1YLFNBQzNCWSxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLE9BQ1BnQixFQUFFLENBQUMsWUFBWSxTQUNmZ0IsTUFBTTtRQUVULElBQUlsQyxTQUFTLENBQUNELE1BQU07WUFDbEJJLFFBQVFILEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE9BQU8sSUFBSSxtQ0FBbUM7UUFDaEQ7UUFFQSxPQUFPRCxLQUFLbVIsR0FBRyxJQUFJO0lBQ3JCLEVBQUUsT0FBT2xSLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLG9DQUFvQ0E7UUFDbEQsT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUNGLHlDQUF5QztBQUNsQyxNQUFNMmIsZ0JBQWdCLE9BQU9yWCxRQUFnQnNYO0lBQ2xELElBQUk7UUFDRix1QkFBdUI7UUFDdkIsSUFBSUEsT0FBT3hhLE1BQU0sS0FBSyxLQUFLLENBQUMsUUFBUXlhLElBQUksQ0FBQ0QsU0FBUztZQUNoRHpiLFFBQVFILEtBQUssQ0FBQztZQUNkLE9BQU87UUFDVDtRQUVBLE1BQU0sRUFBRUEsS0FBSyxFQUFFLEdBQUcsTUFBTVgsU0FDckJZLElBQUksQ0FBQyxTQUNMa0UsTUFBTSxDQUFDO1lBQUUrTSxLQUFLMEs7UUFBTyxHQUNyQjFhLEVBQUUsQ0FBQyxNQUFNb0Q7UUFFWixJQUFJdEUsT0FBTztZQUNURyxRQUFRSCxLQUFLLENBQUMsdUJBQXVCQTtZQUNyQyxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1QsRUFBRSxPQUFPQSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF5dWVcXERlc2t0b3BcXHBpZ3Rvd25iYXJiZXJzaG9wXFxsaWJcXHN1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIlxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gS29uZmlndXJhc2kgU3VwYWJhc2VcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgXCJodHRwczovL3RrcnJqdmNndml3bmxpaW5vdmlrLnN1cGFiYXNlLmNvXCJcclxuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID1cclxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSB8fFxyXG4gIFwiZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnBjM01pT2lKemRYQmhZbUZ6WlNJc0luSmxaaUk2SW5ScmNuSnFkbU5uZG1sM2JteHBhVzV2ZG1scklpd2ljbTlzWlNJNkltRnViMjRpTENKcFlYUWlPakUzTlRVeE1ERTRNalFzSW1WNGNDSTZNakEzTURZM056Z3lOSDAudWY3UjA2R2Q2TWdmXzNadjNRMTg0SFdQcXpvNmticmZoUTFCa2tkTTlpTVwiXHJcblxyXG5pZiAoIXN1cGFiYXNlVXJsKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUuXCIpXHJcbn1cclxuaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIGVudmlyb25tZW50IHZhcmlhYmxlLlwiKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xyXG4gIGF1dGg6IHtcclxuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxyXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcclxuICB9LFxyXG4gIHJlYWx0aW1lOiB7XHJcbiAgICBwYXJhbXM6IHtcclxuICAgICAgZXZlbnRzUGVyU2Vjb25kOiAxMCxcclxuICAgIH0sXHJcbiAgfSxcclxuICBnbG9iYWw6IHtcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ3gtYXBwbGljYXRpb24tbmFtZSc6ICdwaWd0b3duLWJhcmJlcnNob3AnLFxyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZXN0U3VwYWJhc2VDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwicG9pbnRzXCIpLnNlbGVjdCgnKiwgdXNlcnMhaW5uZXIobmFtZSwgYnJhbmNoX2lkLCBicmFuY2hlczpicmFuY2hfaWQobmFtZSkpJylcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJTdXBhYmFzZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxcIilcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJTdXBhYmFzZSBjb25uZWN0aW9uIGVycm9yOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBIaXR1bmcgSGFyaSBLZXJqYVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5mdW5jdGlvbiBnZXRCdXNpbmVzc0RheXNDb3VudChzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpOiBudW1iZXIge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IGN1ckRhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUuZ2V0VGltZSgpKTtcclxuICAgIFxyXG4gICAgd2hpbGUgKGN1ckRhdGUgPD0gZW5kRGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IGN1ckRhdGUuZ2V0RGF5KCk7XHJcbiAgICAgICAgLy8gMCA9IE1pbmdndSwgNiA9IFNhYnR1ICh0aWRhayBkaWhpdHVuZyBzZWJhZ2FpIGhhcmkga2VyamEpXHJcbiAgICAgICAgaWYgKGRheU9mV2VlayAhPT0gMCAmJiBkYXlPZldlZWsgIT09IDYpIHtcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyRGF0ZS5zZXREYXRlKGN1ckRhdGUuZ2V0RGF0ZSgpICsgMSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBjb3VudDtcclxufVxyXG5cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEludGVyZmFjZXNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbi8vIC0tLSBVc2VyICYgQnJhbmNoIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkOiBzdHJpbmdcclxuICBlbWFpbD86IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIHBvc2l0aW9uPzogc3RyaW5nXHJcbiAgYnJhbmNoX2lkPzogc3RyaW5nXHJcbiAgcGhvbmU/OiBzdHJpbmdcclxuICBhZGRyZXNzPzogc3RyaW5nXHJcbiAgc3RhdHVzPzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnJhbmNoIHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgYWRkcmVzcz86IHN0cmluZ1xyXG4gIHBob25lPzogc3RyaW5nXHJcbiAgc3RhdHVzPzogc3RyaW5nXHJcbiAgbWFuYWdlcl9pZD86IHN0cmluZ1xyXG4gIG1hbmFnZXJfbmFtZT86IHN0cmluZ1xyXG4gIG9wZXJhdGluZ19ob3Vycz86IHtcclxuICAgIG9wZW46IHN0cmluZ1xyXG4gICAgY2xvc2U6IHN0cmluZ1xyXG4gIH1cclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICBzaGlmdHM/OiBCcmFuY2hTaGlmdFtdXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZSB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXHJcbiAgcHJpY2U6IG51bWJlclxyXG4gIGR1cmF0aW9uPzogbnVtYmVyXHJcbiAgY2F0ZWdvcnk/OiBzdHJpbmdcclxuICBzdGF0dXM/OiBzdHJpbmdcclxuICBzdG9jaz86IG51bWJlclxyXG4gIHR5cGU/OiBcInNlcnZpY2VcIiB8IFwicHJvZHVjdFwiXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUNhdGVnb3J5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcclxuICBpc19hY3RpdmU6IGJvb2xlYW5cclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICB1cGRhdGVkX2F0OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlV2l0aENhdGVnb3J5IGV4dGVuZHMgU2VydmljZSB7XHJcbiAgY2F0ZWdvcnlfaWQ/OiBzdHJpbmdcclxuICBpc19hY3RpdmU/OiBib29sZWFuXHJcbiAgY29tbWlzc2lvbl9yYXRlPzogbnVtYmVyXHJcbiAgc2VydmljZV9jYXRlZ29yaWVzPzogU2VydmljZUNhdGVnb3J5XHJcbn1cclxuXHJcbi8vIC0tLSBUcmFuc2FjdGlvbiAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbiB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHRyYW5zYWN0aW9uX251bWJlcjogc3RyaW5nXHJcbiAgY3VzdG9tZXJfbmFtZTogc3RyaW5nXHJcbiAgdG90YWxfYW1vdW50OiBudW1iZXJcclxuICBwYXltZW50X21ldGhvZDogc3RyaW5nXHJcbiAgcGF5bWVudF9zdGF0dXM6IHN0cmluZ1xyXG4gIG5vdGVzPzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgY2FzaGllcl9pZD86IHN0cmluZ1xyXG4gIGNhc2hpZXJfbmFtZT86IHN0cmluZ1xyXG4gIGJyYW5jaF9pZD86IHN0cmluZ1xyXG4gIGJyYW5jaF9uYW1lPzogc3RyaW5nXHJcbiAgc2VydmVyX2lkPzogc3RyaW5nXHJcbiAgc2VydmVyX25hbWU/OiBzdHJpbmdcclxuICBjYXNoaWVyPzoge1xyXG4gICAgbmFtZTogc3RyaW5nXHJcbiAgfVxyXG4gIGJyYW5jaD86IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gIH1cclxuICB0cmFuc2FjdGlvbl9pdGVtcz86IHtcclxuICAgIHF1YW50aXR5OiBudW1iZXJcclxuICAgIHVuaXRfcHJpY2U6IG51bWJlclxyXG4gICAgdG90YWxfcHJpY2U6IG51bWJlclxyXG4gICAgc2VydmljZV9pZDogc3RyaW5nXHJcbiAgICBzZXJ2aWNlPzoge1xyXG4gICAgICBuYW1lOiBzdHJpbmdcclxuICAgIH1cclxuICB9W11cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbldpdGhJdGVtcyBleHRlbmRzIFRyYW5zYWN0aW9uIHtcclxuICByZWNlaXB0X251bWJlcj86IHN0cmluZ1xyXG4gIGZpbmFsX2Ftb3VudD86IG51bWJlclxyXG4gIHN1YnRvdGFsPzogbnVtYmVyXHJcbiAgZGlzY291bnRfYW1vdW50PzogbnVtYmVyXHJcbiAgdHJhbnNhY3Rpb25faXRlbXM/OiBUcmFuc2FjdGlvbkl0ZW1XaXRoU2VydmljZVtdXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JdGVtIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdHJhbnNhY3Rpb25faWQ6IHN0cmluZ1xyXG4gIHNlcnZpY2VfaWQ6IHN0cmluZ1xyXG4gIHF1YW50aXR5OiBudW1iZXJcclxuICB1bml0X3ByaWNlOiBudW1iZXJcclxuICB0b3RhbF9wcmljZTogbnVtYmVyXHJcbiAgc2VydmljZT86IHsgbmFtZTogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JdGVtV2l0aFNlcnZpY2UgZXh0ZW5kcyBUcmFuc2FjdGlvbkl0ZW0ge1xyXG4gIHNlcnZpY2U/OiBTZXJ2aWNlV2l0aENhdGVnb3J5XHJcbn1cclxuXHJcbi8vIC0tLSBBdHRlbmRhbmNlIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVuZGFuY2Uge1xyXG4gIGlkOiBzdHJpbmdcclxuICB1c2VyX2lkOiBzdHJpbmdcclxuICBicmFuY2hfaWQ/OiBzdHJpbmdcclxuICBzaGlmdF90eXBlOiBcInBhZ2lcIiB8IFwic2lhbmdcIiB8IFwibWFsYW1cIlxyXG4gIGNoZWNrX2luX3RpbWU/OiBzdHJpbmdcclxuICBjaGVja19vdXRfdGltZT86IHN0cmluZ1xyXG4gIGJyZWFrX3N0YXJ0X3RpbWU/OiBzdHJpbmdcclxuICBicmVha19lbmRfdGltZT86IHN0cmluZ1xyXG4gIHRvdGFsX2hvdXJzPzogbnVtYmVyXHJcbiAgYnJlYWtfZHVyYXRpb24/OiBudW1iZXJcclxuICBzdGF0dXM6IFwiY2hlY2tlZF9pblwiIHwgXCJvbl9icmVha1wiIHwgXCJjaGVja2VkX291dFwiIHwgXCJhYnNlbnRcIlxyXG4gIGNoZWNrX2luX3Bob3RvPzogc3RyaW5nXHJcbiAgY2hlY2tfb3V0X3Bob3RvPzogc3RyaW5nXHJcbiAgZGF0ZTogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVuZGFuY2VXaXRoRGV0YWlscyBleHRlbmRzIEF0dGVuZGFuY2Uge1xyXG4gIHVzZXJzPzogRW1wbG95ZWVcclxuICBicmFuY2hlcz86IEJyYW5jaFxyXG59XHJcblxyXG4vLyAtLS0gTWVudSAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBNZW51Q2F0ZWdvcnkge1xyXG4gIGlkOiBzdHJpbmdcclxuICBuYW1lOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xyXG4gIGljb246IHN0cmluZ1xyXG4gIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiaW5hY3RpdmVcIlxyXG4gIHNvcnRfb3JkZXI6IG51bWJlclxyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVJdGVtIHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcclxuICBwcmljZTogbnVtYmVyXHJcbiAgY2F0ZWdvcnlfaWQ6IHN0cmluZ1xyXG4gIGR1cmF0aW9uPzogbnVtYmVyXHJcbiAgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJpbmFjdGl2ZVwiXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVjZWlwdFRlbXBsYXRlIHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgaGVhZGVyX3RleHQ/OiBzdHJpbmdcclxuICBmb290ZXJfdGV4dD86IHN0cmluZ1xyXG4gIGxvZ29fdXJsPzogc3RyaW5nXHJcbiAgaXNfYWN0aXZlPzogYm9vbGVhblxyXG4gIHNob3dfbG9nbz86IGJvb2xlYW5cclxuICBzaG93X2FkZHJlc3M/OiBib29sZWFuXHJcbiAgc2hvd19waG9uZT86IGJvb2xlYW5cclxuICBzaG93X2RhdGU/OiBib29sZWFuXHJcbiAgc2hvd19iYXJiZXI/OiBib29sZWFuXHJcbiAgY3JlYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlY2VpcHRUZW1wbGF0ZVdpdGhCcmFuY2ggZXh0ZW5kcyBSZWNlaXB0VGVtcGxhdGUge1xyXG4gIGJyYW5jaF9pZD86IHN0cmluZ1xyXG4gIHRlbXBsYXRlX25hbWU/OiBzdHJpbmdcclxuICBwYXBlcl93aWR0aD86IG51bWJlclxyXG59XHJcblxyXG4vLyAtLS0gUG9pbnRzIFN5c3RlbSAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHVzZXJfaWQ6IHN0cmluZ1xyXG4gIHBvaW50c19lYXJuZWQ6IG51bWJlclxyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICBwb2ludHNfdHlwZTogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJXaXRoUG9pbnRzIGV4dGVuZHMgVXNlciB7XHJcbiAgdG90YWxfcG9pbnRzPzogbnVtYmVyXHJcbiAgbW9udGhseV9wb2ludHM/OiBudW1iZXJcclxuICByYW5rPzogbnVtYmVyXHJcbiAgcG9pbnRzPzogUG9pbnRbXVxyXG4gIGJyYW5jaGVzOiB7XHJcbiAgICBuYW1lOiBzdHJpbmdcclxuICB9IHwgbnVsbFxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBLYXNib24gSW50ZXJmYWNlc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgaW50ZXJmYWNlIEthc2JvbiB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHVzZXJfaWQ6IHN0cmluZ1xyXG4gIGFtb3VudDogbnVtYmVyXHJcbiAgcmVhc29uOiBzdHJpbmdcclxuICBzdGF0dXM6IFwicGVuZGluZ1wiIHwgXCJhcHByb3ZlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJwYWlkXCJcclxuICByZXF1ZXN0X2RhdGU6IHN0cmluZ1xyXG4gIGR1ZV9kYXRlPzogc3RyaW5nXHJcbiAgbm90ZXM/OiBzdHJpbmdcclxuICBhcHByb3ZlZF9ieT86IHN0cmluZ1xyXG4gIGFwcHJvdmVkX2F0Pzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEthc2JvbldpdGhVc2VyIGV4dGVuZHMgS2FzYm9uIHtcclxuICB1c2VyPzogVXNlclxyXG4gIGFwcHJvdmVyPzoge1xyXG4gICAgaWQ6IHN0cmluZ1xyXG4gICAgbmFtZTogc3RyaW5nXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJXaXRoS2FzYm9uIGV4dGVuZHMgVXNlciB7XHJcbiAgdG90YWxfa2FzYm9uPzogbnVtYmVyXHJcbiAgYWN0aXZlX2thc2Jvbj86IG51bWJlclxyXG4gIGthc2Jvbl9oaXN0b3J5PzogS2FzYm9uW11cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRXhwZW5zZSBNYW5hZ2VtZW50IEludGVyZmFjZXNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGludGVyZmFjZSBFeHBlbnNlIHtcclxuICBpZDogc3RyaW5nXHJcbiAgYnJhbmNoX2lkPzogc3RyaW5nXHJcbiAgY2F0ZWdvcnk6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICBhbW91bnQ6IG51bWJlclxyXG4gIHN0YXR1czogXCJwZW5kaW5nXCIgfCBcImFwcHJvdmVkXCIgfCBcInJlamVjdGVkXCIgfCBcInBhaWRcIlxyXG4gIHJlcXVlc3RfZGF0ZTogc3RyaW5nXHJcbiAgZHVlX2RhdGU/OiBzdHJpbmdcclxuICByZWNlaXB0X3VybD86IHN0cmluZ1xyXG4gIG5vdGVzPzogc3RyaW5nXHJcbiAgcmVxdWVzdGVkX2J5OiBzdHJpbmdcclxuICBhcHByb3ZlZF9ieT86IHN0cmluZ1xyXG4gIGFwcHJvdmVkX2F0Pzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVuc2VXaXRoVXNlciBleHRlbmRzIEV4cGVuc2Uge1xyXG4gIHVzZXJzPzogVXNlclxyXG4gIGJyYW5jaGVzPzogQnJhbmNoXHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEJyYW5jaCBTaGlmdCBNYW5hZ2VtZW50XHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBpbnRlcmZhY2UgQnJhbmNoU2hpZnQge1xyXG4gIGlkOiBzdHJpbmdcclxuICBicmFuY2hfaWQ6IHN0cmluZ1xyXG4gIHNoaWZ0X25hbWU6IHN0cmluZ1xyXG4gIHNoaWZ0X3R5cGU6IFwicGFnaVwiIHwgXCJzaWFuZ1wiIHwgXCJtYWxhbVwiXHJcbiAgc3RhcnRfdGltZTogc3RyaW5nXHJcbiAgZW5kX3RpbWU6IHN0cmluZ1xyXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJhbmNoU2hpZnRzKGJyYW5jaElkOiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gZ2V0QnJhbmNoU2hpZnRzIGNhbGxlZCB3aXRoIGJyYW5jaElkOlwiLCBicmFuY2hJZClcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYnJhbmNoX3NoaWZ0c1wiKVxyXG4gICAgLnNlbGVjdChcIipcIilcclxuICAgIC5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZClcclxuICAgIC5lcShcImlzX2FjdGl2ZVwiLCB0cnVlKVxyXG4gICAgLm9yZGVyKFwic3RhcnRfdGltZVwiKVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gQnJhbmNoIHNoaWZ0cyByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuXHJcbiAgaWYgKGVycm9yIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gTm8gc2hpZnRzIGZvdW5kLCByZXR1cm5pbmcgZGVmYXVsdCBzaGlmdHNcIilcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogYGRlZmF1bHQtcGFnaS0ke2JyYW5jaElkfWAsXHJcbiAgICAgICAgICBicmFuY2hfaWQ6IGJyYW5jaElkLFxyXG4gICAgICAgICAgc2hpZnRfbmFtZTogXCJTaGlmdCBQYWdpXCIsXHJcbiAgICAgICAgICBzaGlmdF90eXBlOiBcInBhZ2lcIiBhcyBjb25zdCxcclxuICAgICAgICAgIHN0YXJ0X3RpbWU6IFwiMDg6MDBcIixcclxuICAgICAgICAgIGVuZF90aW1lOiBcIjE2OjAwXCIsXHJcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogYGRlZmF1bHQtc2lhbmctJHticmFuY2hJZH1gLFxyXG4gICAgICAgICAgYnJhbmNoX2lkOiBicmFuY2hJZCxcclxuICAgICAgICAgIHNoaWZ0X25hbWU6IFwiU2hpZnQgU2lhbmdcIixcclxuICAgICAgICAgIHNoaWZ0X3R5cGU6IFwic2lhbmdcIiBhcyBjb25zdCxcclxuICAgICAgICAgIHN0YXJ0X3RpbWU6IFwiMTI6MDBcIixcclxuICAgICAgICAgIGVuZF90aW1lOiBcIjIwOjAwXCIsXHJcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogYGRlZmF1bHQtbWFsYW0tJHticmFuY2hJZH1gLFxyXG4gICAgICAgICAgYnJhbmNoX2lkOiBicmFuY2hJZCxcclxuICAgICAgICAgIHNoaWZ0X25hbWU6IFwiU2hpZnQgTWFsYW1cIixcclxuICAgICAgICAgIHNoaWZ0X3R5cGU6IFwibWFsYW1cIiBhcyBjb25zdCxcclxuICAgICAgICAgIHN0YXJ0X3RpbWU6IFwiMjA6MDBcIixcclxuICAgICAgICAgIGVuZF90aW1lOiBcIjA0OjAwXCIsXHJcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVCcmFuY2hTaGlmdChzaGlmdERhdGE6IE9taXQ8QnJhbmNoU2hpZnQsIFwiaWRcIiB8IFwiY3JlYXRlZF9hdFwiPikge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBjcmVhdGVCcmFuY2hTaGlmdCBjYWxsZWQgd2l0aDpcIiwgc2hpZnREYXRhKVxyXG5cclxuICBjb25zdCBzaGlmdFRvSW5zZXJ0ID0ge1xyXG4gICAgLi4uc2hpZnREYXRhLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImJyYW5jaF9zaGlmdHNcIikuaW5zZXJ0KFtzaGlmdFRvSW5zZXJ0XSkuc2VsZWN0KCkuc2luZ2xlKClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIENyZWF0ZSBicmFuY2ggc2hpZnQgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZ1bmdzaSBoZWxwZXIgQXR0ZW5kYW5jZVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGhvdG9Ub1N1cGFiYXNlKGJhc2U2NDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGZ1bmN0aW9uIGJhc2U2NFRvQmxvYihiYXNlNjREYXRhOiBzdHJpbmcsIGNvbnRlbnRUeXBlID0gXCJpbWFnZS9qcGVnXCIpIHtcclxuICAgICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGJhc2U2NERhdGEuc3BsaXQoXCIsXCIpWzFdKVxyXG4gICAgICBjb25zdCBieXRlQXJyYXlzID0gW11cclxuICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYnl0ZUNoYXJhY3RlcnMubGVuZ3RoOyBvZmZzZXQgKz0gNTEyKSB7XHJcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBieXRlQ2hhcmFjdGVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIDUxMilcclxuICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykgYnl0ZU51bWJlcnNbaV0gPSBzbGljZS5jaGFyQ29kZUF0KGkpXHJcbiAgICAgICAgYnl0ZUFycmF5cy5wdXNoKG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBjb250ZW50VHlwZSB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJsb2IgPSBiYXNlNjRUb0Jsb2IoYmFzZTY0KVxyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZS5mcm9tKFwiYXR0ZW5kYW5jZS1waG90b3NcIikudXBsb2FkKGZpbGVuYW1lLCBibG9iLCB7XHJcbiAgICAgIGNhY2hlQ29udHJvbDogXCIzNjAwXCIsXHJcbiAgICAgIHVwc2VydDogdHJ1ZSxcclxuICAgICAgY29udGVudFR5cGU6IFwiaW1hZ2UvanBlZ1wiLFxyXG4gICAgfSlcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHB1YmxpY1VybERhdGEgfSA9IHN1cGFiYXNlLnN0b3JhZ2UuZnJvbShcImF0dGVuZGFuY2UtcGhvdG9zXCIpLmdldFB1YmxpY1VybChmaWxlbmFtZSlcclxuICAgIHJldHVybiBwdWJsaWNVcmxEYXRhPy5wdWJsaWNVcmwgfHwgbnVsbFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiUGhvdG8gdXBsb2FkIGZhaWxlZDpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF0dGVuZGFuY2VSZWNvcmQoYXR0ZW5kYW5jZURhdGE6IFBhcnRpYWw8QXR0ZW5kYW5jZT4pIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYXR0ZW5kYW5jZVwiKS5pbnNlcnQoW2F0dGVuZGFuY2VEYXRhXSkuc2VsZWN0KCkuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUF0dGVuZGFuY2VSZWNvcmQoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxBdHRlbmRhbmNlPikge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImF0dGVuZGFuY2VcIilcclxuICAgIC51cGRhdGUoeyAuLi51cGRhdGVzLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgIC5lcShcImlkXCIsIGlkKVxyXG4gICAgLnNlbGVjdCgpXHJcbiAgICAuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEF0dGVuZGFuY2VCeURhdGUodXNlcklkOiBzdHJpbmcsIGRhdGU6IHN0cmluZykge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJhdHRlbmRhbmNlXCIpLnNlbGVjdChcIipcIikuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZCkuZXEoXCJkYXRlXCIsIGRhdGUpLnNpbmdsZSgpXHJcbiAgcmV0dXJuIGVycm9yICYmIGVycm9yLmNvZGUgIT09IFwiUEdSU1QxMTZcIiA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQXR0ZW5kYW5jZVJlY29yZHMoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAuc2VsZWN0KGAqLFxyXG4gICAgICB1c2Vyczp1c2VyX2lkICggaWQsIG5hbWUsIGVtYWlsICksXHJcbiAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoIGlkLCBuYW1lIClcclxuICAgIGApXHJcbiAgICAub3JkZXIoXCJkYXRlXCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICBpZiAoYnJhbmNoSWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZ1bmdzaSBoZWxwZXIgUE9TXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXJ2aWNlc1dpdGhDYXRlZ29yaWVzKCkge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInNlcnZpY2VzXCIpXHJcbiAgICAuc2VsZWN0KGAqLFxyXG4gICAgc2VydmljZV9jYXRlZ29yaWVzICggaWQsIG5hbWUsIGRlc2NyaXB0aW9uIClcclxuICBgKVxyXG4gICAgLm9yZGVyKFwibmFtZVwiKVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogW10sIGVycm9yIH0gOiB7IGRhdGE6IGRhdGEgfHwgW10sIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlcnZpY2VDYXRlZ29yaWVzKCkge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJzZXJ2aWNlX2NhdGVnb3JpZXNcIikuc2VsZWN0KFwiKlwiKS5vcmRlcihcIm5hbWVcIilcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkRhdGE6IFBhcnRpYWw8VHJhbnNhY3Rpb25XaXRoSXRlbXM+KSB7XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25OdW1iZXIgPSBhd2FpdCBnZW5lcmF0ZVRyYW5zYWN0aW9uTnVtYmVyKClcclxuICBsZXQgeyBjYXNoaWVyX2lkLCBicmFuY2hfaWQsIHNlcnZlcl9pZCB9ID0gdHJhbnNhY3Rpb25EYXRhXHJcblxyXG4gIC8vIEdldCBjYXNoaWVyLCBicmFuY2gsIHNlcnZlciBkYXRhIHVudHVrIHNuYXBzaG90XHJcbiAgbGV0IGNhc2hpZXJOYW1lID0gJ1Vua25vd24nXHJcbiAgbGV0IGJyYW5jaE5hbWUgPSAnVW5rbm93bidcclxuICBsZXQgc2VydmVyTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkXHJcblxyXG4gIGlmICghY2FzaGllcl9pZCkge1xyXG4gICAgY29uc3QgeyBkYXRhOiB1c2VycyB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInVzZXJzXCIpLnNlbGVjdChcImlkLCBuYW1lXCIpLmxpbWl0KDEpLnNpbmdsZSgpXHJcbiAgICBjYXNoaWVyX2lkID0gdXNlcnM/LmlkXHJcbiAgICBjYXNoaWVyTmFtZSA9IHVzZXJzPy5uYW1lIHx8ICdVbmtub3duJ1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGNhc2hpZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCJuYW1lXCIpLmVxKFwiaWRcIiwgY2FzaGllcl9pZCkuc2luZ2xlKClcclxuICAgIGNhc2hpZXJOYW1lID0gY2FzaGllcj8ubmFtZSB8fCAnVW5rbm93bidcclxuICB9XHJcblxyXG4gIGlmICghYnJhbmNoX2lkKSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGJyYW5jaGVzIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYnJhbmNoZXNcIikuc2VsZWN0KFwiaWQsIG5hbWVcIikubGltaXQoMSkuc2luZ2xlKClcclxuICAgIGJyYW5jaF9pZCA9IGJyYW5jaGVzPy5pZFxyXG4gICAgYnJhbmNoTmFtZSA9IGJyYW5jaGVzPy5uYW1lIHx8ICdVbmtub3duJ1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGJyYW5jaCB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImJyYW5jaGVzXCIpLnNlbGVjdChcIm5hbWVcIikuZXEoXCJpZFwiLCBicmFuY2hfaWQpLnNpbmdsZSgpXHJcbiAgICBicmFuY2hOYW1lID0gYnJhbmNoPy5uYW1lIHx8ICdVbmtub3duJ1xyXG4gIH1cclxuXHJcbiAgaWYgKHNlcnZlcl9pZCkge1xyXG4gICAgY29uc3QgeyBkYXRhOiBzZXJ2ZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCJuYW1lXCIpLmVxKFwiaWRcIiwgc2VydmVyX2lkKS5zaW5nbGUoKVxyXG4gICAgc2VydmVyTmFtZSA9IHNlcnZlcj8ubmFtZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25Ub0luc2VydCA9IHtcclxuICAgIC4uLnRyYW5zYWN0aW9uRGF0YSxcclxuICAgIHRyYW5zYWN0aW9uX251bWJlcjogdHJhbnNhY3Rpb25OdW1iZXIsXHJcbiAgICByZWNlaXB0X251bWJlcjogdHJhbnNhY3Rpb25OdW1iZXIsXHJcbiAgICBjYXNoaWVyX2lkLFxyXG4gICAgY2FzaGllcl9uYW1lOiBjYXNoaWVyTmFtZSxcclxuICAgIGJyYW5jaF9pZCxcclxuICAgIGJyYW5jaF9uYW1lOiBicmFuY2hOYW1lLFxyXG4gICAgc2VydmVyX2lkLFxyXG4gICAgc2VydmVyX25hbWU6IHNlcnZlck5hbWUsXHJcbiAgICBzdWJ0b3RhbDogdHJhbnNhY3Rpb25EYXRhLnN1YnRvdGFsIHx8IHRyYW5zYWN0aW9uRGF0YS50b3RhbF9hbW91bnQgfHwgMCxcclxuICAgIHBheW1lbnRfc3RhdHVzOiB0cmFuc2FjdGlvbkRhdGEucGF5bWVudF9zdGF0dXMgfHwgXCJjb21wbGV0ZWRcIixcclxuICAgIHBheW1lbnRfbWV0aG9kOiB0cmFuc2FjdGlvbkRhdGEucGF5bWVudF9tZXRob2QgfHwgXCJjYXNoXCIsXHJcbiAgICB0b3RhbF9hbW91bnQ6IHRyYW5zYWN0aW9uRGF0YS50b3RhbF9hbW91bnQgfHwgMCxcclxuICAgIGRpc2NvdW50X2Ftb3VudDogdHJhbnNhY3Rpb25EYXRhLmRpc2NvdW50X2Ftb3VudCB8fCAwLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInRyYW5zYWN0aW9uc1wiKS5pbnNlcnQoW3RyYW5zYWN0aW9uVG9JbnNlcnRdKS5zZWxlY3QoKS5zaW5nbGUoKVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25JdGVtcyhpdGVtczogUGFydGlhbDxUcmFuc2FjdGlvbkl0ZW0+W10pIHtcclxuICAvLyBFbnJpY2ggaXRlbXMgZGVuZ2FuIHNuYXBzaG90IGRhdGEgZGFyaSBzZXJ2aWNlc1xyXG4gIGNvbnN0IGVucmljaGVkSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHtcclxuICAgIGlmIChpdGVtLnNlcnZpY2VfaWQpIHtcclxuICAgICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwic2VydmljZXNcIilcclxuICAgICAgICAuc2VsZWN0KFwibmFtZSwgdHlwZSwgc2VydmljZV9jYXRlZ29yaWVzKG5hbWUpXCIpXHJcbiAgICAgICAgLmVxKFwiaWRcIiwgaXRlbS5zZXJ2aWNlX2lkKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5pdGVtLFxyXG4gICAgICAgIHNlcnZpY2VfbmFtZTogc2VydmljZT8ubmFtZSB8fCAnVW5rbm93biBTZXJ2aWNlJyxcclxuICAgICAgICBzZXJ2aWNlX3R5cGU6IHNlcnZpY2U/LnR5cGUsXHJcbiAgICAgICAgc2VydmljZV9jYXRlZ29yeTogc2VydmljZT8uc2VydmljZV9jYXRlZ29yaWVzPy5uYW1lXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtXHJcbiAgfSkpXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ0cmFuc2FjdGlvbl9pdGVtc1wiKS5pbnNlcnQoZW5yaWNoZWRJdGVtcykuc2VsZWN0KClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlaXB0VGVtcGxhdGUoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKFwicmVjZWlwdF90ZW1wbGF0ZXNcIikuc2VsZWN0KFwiKlwiKVxyXG4gIGlmIChicmFuY2hJZCkgcXVlcnkgPSBxdWVyeS5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZClcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeS5zaW5nbGUoKVxyXG4gIHJldHVybiBlcnJvciAmJiBlcnJvci5jb2RlICE9PSBcIlBHUlNUMTE2XCIgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2ZVJlY2VpcHRUZW1wbGF0ZShicmFuY2hJZD86IHN0cmluZykge1xyXG4gIC8vIFByaW9yaXR5IDE6IFRyeSB0byBnZXQgYWN0aXZlIHRlbXBsYXRlIChpc19hY3RpdmUgPSB0cnVlKVxyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oXCJyZWNlaXB0X3RlbXBsYXRlc1wiKS5zZWxlY3QoXCIqXCIpLmVxKFwiaXNfYWN0aXZlXCIsIHRydWUpXHJcbiAgaWYgKGJyYW5jaElkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKVxyXG4gIGNvbnN0IHsgZGF0YTogYWN0aXZlRGF0YSwgZXJyb3I6IGFjdGl2ZUVycm9yIH0gPSBhd2FpdCBxdWVyeS5zaW5nbGUoKVxyXG4gIFxyXG4gIGlmIChhY3RpdmVEYXRhICYmICFhY3RpdmVFcnJvcikge1xyXG4gICAgcmV0dXJuIHsgZGF0YTogYWN0aXZlRGF0YSwgZXJyb3I6IG51bGwgfVxyXG4gIH1cclxuICBcclxuICAvLyBQcmlvcml0eSAyOiBJZiBubyBhY3RpdmUgdGVtcGxhdGUsIGdldCBkZWZhdWx0IHRlbXBsYXRlIChpc19kZWZhdWx0ID0gdHJ1ZSlcclxuICBsZXQgZGVmYXVsdFF1ZXJ5ID0gc3VwYWJhc2UuZnJvbShcInJlY2VpcHRfdGVtcGxhdGVzXCIpLnNlbGVjdChcIipcIikuZXEoXCJpc19kZWZhdWx0XCIsIHRydWUpXHJcbiAgaWYgKGJyYW5jaElkKSBkZWZhdWx0UXVlcnkgPSBkZWZhdWx0UXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgY29uc3QgeyBkYXRhOiBkZWZhdWx0RGF0YSwgZXJyb3I6IGRlZmF1bHRFcnJvciB9ID0gYXdhaXQgZGVmYXVsdFF1ZXJ5LnNpbmdsZSgpXHJcbiAgXHJcbiAgaWYgKGRlZmF1bHREYXRhICYmICFkZWZhdWx0RXJyb3IpIHtcclxuICAgIHJldHVybiB7IGRhdGE6IGRlZmF1bHREYXRhLCBlcnJvcjogbnVsbCB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFByaW9yaXR5IDM6IEZhbGxiYWNrIHRvIGFueSB0ZW1wbGF0ZVxyXG4gIHJldHVybiBhd2FpdCBnZXRSZWNlaXB0VGVtcGxhdGUoYnJhbmNoSWQpXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcmFuY2hlcygpIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYnJhbmNoZXNcIikuc2VsZWN0KFwiKlwiKS5vcmRlcihcIm5hbWVcIilcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zYWN0aW9uTnVtYmVyKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYyhcImdlbmVyYXRlX3JlY2VpcHRfbnVtYmVyXCIpXHJcbiAgICBpZiAoIWVycm9yICYmIGRhdGEpIHJldHVybiBkYXRhXHJcblxyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXHJcbiAgICBjb25zdCBkYXRlU3RyID0gdG9kYXkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCkucmVwbGFjZSgvLS9nLCBcIlwiKVxyXG4gICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbnMgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidHJhbnNhY3Rpb25zXCIpXHJcbiAgICAgIC5zZWxlY3QoXCJ0cmFuc2FjdGlvbl9udW1iZXJcIilcclxuICAgICAgLmd0ZShcImNyZWF0ZWRfYXRcIiwgYCR7dG9kYXkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCl9VDAwOjAwOjAwLjAwMFpgKVxyXG4gICAgICAubHQoXCJjcmVhdGVkX2F0XCIsIGAke3RvZGF5LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApfVQyMzo1OTo1OS45OTlaYClcclxuICAgIGNvbnN0IGNvdW50ZXIgPSAodHJhbnNhY3Rpb25zPy5sZW5ndGggfHwgMCkgKyAxXHJcbiAgICByZXR1cm4gYCR7ZGF0ZVN0cn0ke2NvdW50ZXIudG9TdHJpbmcoKS5wYWRTdGFydCgzLCBcIjBcIil9YFxyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGAke0RhdGUubm93KCl9YFxyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRnVuZ3NpIGhlbHBlciBTdG9jayBNYW5hZ2VtZW50XHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1NlcnZpY2VTdG9jayhzZXJ2aWNlSWQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInNlcnZpY2VzXCIpLnNlbGVjdChcInN0b2NrXCIpLmVxKFwiaWRcIiwgc2VydmljZUlkKS5zaW5nbGUoKVxyXG4gIHJldHVybiBlcnJvciA/IDAgOiBkYXRhPy5zdG9jayB8fCAwXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWR1Y2VTZXJ2aWNlU3RvY2soc2VydmljZUlkOiBzdHJpbmcsIHF1YW50aXR5OiBudW1iZXIpIHtcclxuICBjb25zdCB7IGRhdGE6IGN1cnJlbnRTZXJ2aWNlLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwic2VydmljZXNcIilcclxuICAgIC5zZWxlY3QoXCJzdG9ja1wiKVxyXG4gICAgLmVxKFwiaWRcIiwgc2VydmljZUlkKVxyXG4gICAgLnNpbmdsZSgpXHJcbiAgaWYgKGZldGNoRXJyb3IpIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBmZXRjaEVycm9yIH1cclxuXHJcbiAgY29uc3QgY3VycmVudFN0b2NrID0gY3VycmVudFNlcnZpY2Uuc3RvY2sgfHwgMFxyXG4gIGNvbnN0IG5ld1N0b2NrID0gTWF0aC5tYXgoMCwgY3VycmVudFN0b2NrIC0gcXVhbnRpdHkpXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInNlcnZpY2VzXCIpXHJcbiAgICAudXBkYXRlKHsgc3RvY2s6IG5ld1N0b2NrIH0pXHJcbiAgICAuZXEoXCJpZFwiLCBzZXJ2aWNlSWQpXHJcbiAgICAuc2VsZWN0KFwic3RvY2tcIilcclxuICAgIC5zaW5nbGUoKVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU2VydmljZVN0b2NrKHNlcnZpY2VJZDogc3RyaW5nLCBuZXdTdG9jazogbnVtYmVyKSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwic2VydmljZXNcIilcclxuICAgIC51cGRhdGUoeyBzdG9jazogbmV3U3RvY2ssIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxyXG4gICAgLmVxKFwiaWRcIiwgc2VydmljZUlkKVxyXG4gICAgLnNlbGVjdCgpXHJcbiAgICAuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRnVuZ3NpIGhlbHBlciBQb2ludHMgU3lzdGVtXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2Vyc1dpdGhQb2ludHMoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MV0gZ2V0VXNlcnNXaXRoUG9pbnRzIGNhbGxlZCB3aXRoIGJyYW5jaElkOlwiLCBicmFuY2hJZCk7XHJcblxyXG4gIGxldCB1c2Vyc1F1ZXJ5ID0gc3VwYWJhc2UuZnJvbShcInVzZXJzXCIpLnNlbGVjdChcIiosIGJyYW5jaGVzOmJyYW5jaF9pZChuYW1lKVwiKS5vcmRlcihcIm5hbWVcIik7XHJcbiAgaWYgKGJyYW5jaElkICYmIGJyYW5jaElkICE9PSBcImFsbFwiKSB7XHJcbiAgICB1c2Vyc1F1ZXJ5ID0gdXNlcnNRdWVyeS5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGE6IHVzZXJzLCBlcnJvcjogdXNlcnNFcnJvciB9ID0gYXdhaXQgdXNlcnNRdWVyeTtcclxuICBpZiAodXNlcnNFcnJvcikgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiB1c2Vyc0Vycm9yIH07XHJcbiAgaWYgKCF1c2VycykgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBudWxsIH07XHJcblxyXG4gIGNvbnN0IHsgZGF0YTogYWxsUG9pbnRzLCBlcnJvcjogcG9pbnRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInBvaW50c1wiKVxyXG4gICAgLnNlbGVjdChcInVzZXJfaWQsIHBvaW50c19lYXJuZWQsIGNyZWF0ZWRfYXRcIik7XHJcbiAgaWYgKHBvaW50c0Vycm9yKSByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IHBvaW50c0Vycm9yIH07XHJcblxyXG4gIGNvbnN0IHVzZXJzV2l0aENhbGN1bGF0ZWRQb2ludHMgPSB1c2Vycy5tYXAoKHVzZXI6IGFueSkgPT4ge1xyXG4gICAgY29uc3QgdXNlclBvaW50cyA9IGFsbFBvaW50cz8uZmlsdGVyKChwb2ludCkgPT4gcG9pbnQudXNlcl9pZCA9PT0gdXNlci5pZCkgfHwgW107XHJcbiAgICBjb25zdCB0b3RhbFBvaW50cyA9IHVzZXJQb2ludHMucmVkdWNlKChzdW0sIHBvaW50KSA9PiBzdW0gKyAocG9pbnQucG9pbnRzX2Vhcm5lZCB8fCAwKSwgMCk7XHJcblxyXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xyXG4gICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XHJcblxyXG4gICAgY29uc3QgbW9udGhseVBvaW50cyA9IHVzZXJQb2ludHMucmVkdWNlKChzdW0sIHBvaW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHBvaW50RGF0ZSA9IG5ldyBEYXRlKHBvaW50LmNyZWF0ZWRfYXQpO1xyXG4gICAgICBpZiAocG9pbnREYXRlLmdldE1vbnRoKCkgPT09IGN1cnJlbnRNb250aCAmJiBwb2ludERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudFllYXIpIHtcclxuICAgICAgICByZXR1cm4gc3VtICsgKHBvaW50LnBvaW50c19lYXJuZWQgfHwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH0sIDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnVzZXIsXHJcbiAgICAgIHRvdGFsX3BvaW50czogdG90YWxQb2ludHMsXHJcbiAgICAgIG1vbnRobHlfcG9pbnRzOiBtb250aGx5UG9pbnRzLFxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgY29uc3Qgc29ydGVkVXNlcnMgPSB1c2Vyc1dpdGhDYWxjdWxhdGVkUG9pbnRzXHJcbiAgICAuc29ydCgoYSwgYikgPT4gKGIudG90YWxfcG9pbnRzIHx8IDApIC0gKGEudG90YWxfcG9pbnRzIHx8IDApKVxyXG4gICAgLm1hcCgodXNlciwgaW5kZXgpID0+ICh7XHJcbiAgICAgIC4uLnVzZXIsXHJcbiAgICAgIHJhbms6IGluZGV4ICsgMSxcclxuICAgIH0pKTtcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjFdIEZpbmFsIHNvcnRlZCB1c2VyczpcIiwgc29ydGVkVXNlcnMpO1xyXG4gIHJldHVybiB7IGRhdGE6IHNvcnRlZFVzZXJzLCBlcnJvcjogbnVsbCB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UG9pbnRzU3RhdGlzdGljcyhicmFuY2hJZD86IHN0cmluZykge1xyXG4gIGNvbnN0IHsgZGF0YTogdXNlcnMsIGVycm9yIH0gPSBhd2FpdCBnZXRVc2Vyc1dpdGhQb2ludHMoYnJhbmNoSWQpXHJcblxyXG4gIGlmIChlcnJvcikgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxyXG5cclxuICBjb25zdCB0b3RhbEVtcGxveWVlcyA9IHVzZXJzLmxlbmd0aFxyXG4gIGNvbnN0IHRvcFBlcmZvcm1lciA9IHVzZXJzWzBdIHx8IG51bGxcclxuICBjb25zdCB0b3RhbFBvaW50cyA9IHVzZXJzLnJlZHVjZSgoc3VtLCB1c2VyKSA9PiBzdW0gKyAodXNlci50b3RhbF9wb2ludHMgfHwgMCksIDApXHJcbiAgY29uc3QgYXZlcmFnZVBvaW50cyA9IHRvdGFsRW1wbG95ZWVzID4gMCA/IE1hdGgucm91bmQodG90YWxQb2ludHMgLyB0b3RhbEVtcGxveWVlcykgOiAwXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkYXRhOiB7XHJcbiAgICAgIHRvdGFsRW1wbG95ZWVzLFxyXG4gICAgICB0b3BQZXJmb3JtZXIsXHJcbiAgICAgIGF2ZXJhZ2VQb2ludHMsXHJcbiAgICAgIHRvdGFsUG9pbnRzLFxyXG4gICAgfSxcclxuICAgIGVycm9yOiBudWxsLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBvaW50VHJhbnNhY3Rpb25zKGJyYW5jaElkPzogc3RyaW5nLCBsaW1pdCA9IDUwKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjMgRmluYWxdIGdldFBvaW50VHJhbnNhY3Rpb25zIGNhbGxlZCB3aXRoIGJyYW5jaElkOlwiLCBicmFuY2hJZCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBGaXJzdCwgZ2V0IHBvaW50IHRyYW5zYWN0aW9uc1xyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwb2ludHNcIilcclxuICAgICAgLnNlbGVjdChcIipcIilcclxuICAgICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLmxpbWl0KGxpbWl0KTtcclxuXHJcbiAgICBpZiAoYnJhbmNoSWQgJiYgYnJhbmNoSWQgIT09IFwiYWxsXCIpIHtcclxuICAgICAgLy8gRmlsdGVyIGJ5IHVzZXIncyBicmFuY2hfaWRcclxuICAgICAgY29uc3QgeyBkYXRhOiB1c2Vyc0luQnJhbmNoLCBlcnJvcjogdXNlcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImlkXCIpXHJcbiAgICAgICAgLmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKTtcclxuICAgICAgXHJcbiAgICAgIGlmICh1c2Vyc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHVzZXJzIGluIGJyYW5jaDpcIiwgdXNlcnNFcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiB1c2Vyc0Vycm9yIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh1c2Vyc0luQnJhbmNoICYmIHVzZXJzSW5CcmFuY2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZHMgPSB1c2Vyc0luQnJhbmNoLm1hcCh1ID0+IHUuaWQpO1xyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuaW4oXCJ1c2VyX2lkXCIsIHVzZXJJZHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIHVzZXJzIGluIHRoaXMgYnJhbmNoLCByZXR1cm4gZW1wdHlcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHVzZXJzIGZvdW5kIGluIGJyYW5jaDpcIiwgYnJhbmNoSWQpO1xyXG4gICAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiBwb2ludHNEYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBwb2ludCB0cmFuc2FjdGlvbnM6XCIsIGVycm9yKTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb2RlOlwiLCBlcnJvci5jb2RlKTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1lc3NhZ2U6XCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBvaW50c0RhdGEgfHwgcG9pbnRzRGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXCJObyBwb2ludCB0cmFuc2FjdGlvbnMgZm91bmRcIik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB1c2VyIGRldGFpbHMgZm9yIGFsbCBwb2ludHNcclxuICAgIGNvbnN0IHVzZXJJZHMgPSBbLi4ubmV3IFNldChwb2ludHNEYXRhLm1hcChwID0+IHAudXNlcl9pZCkuZmlsdGVyKEJvb2xlYW4pKV07XHJcbiAgICBsZXQgdXNlcnNNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICAgIFxyXG4gICAgaWYgKHVzZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWQsIG5hbWUsIGJyYW5jaF9pZFwiKVxyXG4gICAgICAgIC5pbihcImlkXCIsIHVzZXJJZHMpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzKSB7XHJcbiAgICAgICAgdXNlcnNNYXAgPSB1c2Vycy5yZWR1Y2UoKGFjYywgdSkgPT4gKHsgLi4uYWNjLCBbdS5pZF06IHUgfSksIHt9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBhbGwgdW5pcXVlIGJyYW5jaF9pZHNcclxuICAgIGNvbnN0IGJyYW5jaElkcyA9IFsuLi5uZXcgU2V0KE9iamVjdC52YWx1ZXModXNlcnNNYXApLm1hcCgodTogYW55KSA9PiB1LmJyYW5jaF9pZCkuZmlsdGVyKEJvb2xlYW4pKV07XHJcbiAgICBcclxuICAgIC8vIEZldGNoIGJyYW5jaCBkZXRhaWxzXHJcbiAgICBsZXQgYnJhbmNoZXNNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICAgIGlmIChicmFuY2hJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCB7IGRhdGE6IGJyYW5jaGVzIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwiYnJhbmNoZXNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWQsIG5hbWVcIilcclxuICAgICAgICAuaW4oXCJpZFwiLCBicmFuY2hJZHMpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGJyYW5jaGVzKSB7XHJcbiAgICAgICAgYnJhbmNoZXNNYXAgPSBicmFuY2hlcy5yZWR1Y2UoKGFjYywgYikgPT4gKHsgLi4uYWNjLCBbYi5pZF06IGIgfSksIHt9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIHVzZXIgYW5kIGJyYW5jaCBpbmZvIGludG8gcG9pbnRzXHJcbiAgICBjb25zdCBlbnJpY2hlZERhdGEgPSBwb2ludHNEYXRhPy5tYXAocG9pbnQgPT4gKHtcclxuICAgICAgLi4ucG9pbnQsXHJcbiAgICAgIHVzZXJzOiBwb2ludC51c2VyX2lkID8ge1xyXG4gICAgICAgIC4uLnVzZXJzTWFwW3BvaW50LnVzZXJfaWRdLFxyXG4gICAgICAgIGJyYW5jaGVzOiB1c2Vyc01hcFtwb2ludC51c2VyX2lkXT8uYnJhbmNoX2lkID8gYnJhbmNoZXNNYXBbdXNlcnNNYXBbcG9pbnQudXNlcl9pZF0uYnJhbmNoX2lkXSA6IG51bGxcclxuICAgICAgfSA6IG51bGxcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlBvaW50IHRyYW5zYWN0aW9ucyBmZXRjaGVkIHN1Y2Nlc3NmdWxseTpcIiwgZW5yaWNoZWREYXRhPy5sZW5ndGggfHwgMCwgXCJyZWNvcmRzXCIpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogZW5yaWNoZWREYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBlcnJvciBpbiBnZXRQb2ludFRyYW5zYWN0aW9uczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBlcnJvciBhcyBhbnkgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRQb2ludFRyYW5zYWN0aW9uKHBvaW50RGF0YToge1xyXG4gIHVzZXJfaWQ6IHN0cmluZ1xyXG4gIHBvaW50czogbnVtYmVyXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIHR5cGU6IFwiZWFybmVkXCIgfCBcImRlZHVjdGVkXCIgfCBcImJvbnVzXCIgfCBcInBlbmFsdHlcIlxyXG59KSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwicG9pbnRzXCIpXHJcbiAgICAuaW5zZXJ0KFtcclxuICAgICAge1xyXG4gICAgICAgIC4uLnBvaW50RGF0YSxcclxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIH0sXHJcbiAgICBdKVxyXG4gICAgLnNlbGVjdCgpXHJcbiAgICAuc2luZ2xlKClcclxuXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyUG9pbnRzKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwicG9pbnRzXCIpXHJcbiAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgLmVxKFwidXNlcl9pZFwiLCB1c2VySWQpXHJcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEthc2JvbiBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEthc2JvblJlcXVlc3RzKGJyYW5jaElkPzogc3RyaW5nLCBzdGF0dXNGaWx0ZXI/OiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gZ2V0S2FzYm9uUmVxdWVzdHMgY2FsbGVkIHdpdGg6XCIsIHsgYnJhbmNoSWQsIHN0YXR1c0ZpbHRlciB9KVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRmlyc3QsIGdldCBrYXNib24gcmVxdWVzdHNcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwia2FzYm9uXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgaWYgKGJyYW5jaElkICYmIGJyYW5jaElkICE9PSBcImFsbFwiKSB7XHJcbiAgICAgIC8vIEZpbHRlciBieSB1c2VyJ3MgYnJhbmNoX2lkXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlcnNJbkJyYW5jaCwgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAgIC5zZWxlY3QoXCJpZFwiKVxyXG4gICAgICAgIC5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VycyBpbiBicmFuY2g6XCIsIHVzZXJzRXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogdXNlcnNFcnJvciB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnNJbkJyYW5jaCAmJiB1c2Vyc0luQnJhbmNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB1c2VySWRzID0gdXNlcnNJbkJyYW5jaC5tYXAodSA9PiB1LmlkKTtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmluKFwidXNlcl9pZFwiLCB1c2VySWRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHVzZXJzIGZvdW5kIGluIGJyYW5jaDpcIiwgYnJhbmNoSWQpO1xyXG4gICAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXR1c0ZpbHRlciAmJiBzdGF0dXNGaWx0ZXIgIT09IFwiYWxsXCIpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5lcShcInN0YXR1c1wiLCBzdGF0dXNGaWx0ZXIpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiBrYXNib25EYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gS2FzYm9uIHJlcXVlc3RzIGVycm9yOlwiLCBlcnJvcilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWthc2JvbkRhdGEgfHwga2FzYm9uRGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIE5vIGthc2JvbiByZXF1ZXN0cyBmb3VuZFwiKVxyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB1c2VyIGRldGFpbHNcclxuICAgIGNvbnN0IHVzZXJJZHMgPSBbLi4ubmV3IFNldChrYXNib25EYXRhLm1hcChrID0+IGsudXNlcl9pZCkuZmlsdGVyKEJvb2xlYW4pKV07XHJcbiAgICBsZXQgdXNlcnNNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICAgIFxyXG4gICAgaWYgKHVzZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWQsIG5hbWUsIGVtYWlsLCBwb3NpdGlvbiwgYnJhbmNoX2lkXCIpXHJcbiAgICAgICAgLmluKFwiaWRcIiwgdXNlcklkcyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnMpIHtcclxuICAgICAgICB1c2Vyc01hcCA9IHVzZXJzLnJlZHVjZSgoYWNjLCB1KSA9PiAoeyAuLi5hY2MsIFt1LmlkXTogdSB9KSwge30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGFwcHJvdmVyIGRldGFpbHNcclxuICAgIGNvbnN0IGFwcHJvdmVySWRzID0gWy4uLm5ldyBTZXQoa2FzYm9uRGF0YS5tYXAoayA9PiBrLmFwcHJvdmVkX2J5KS5maWx0ZXIoQm9vbGVhbikpXTtcclxuICAgIGxldCBhcHByb3ZlcnNNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICAgIFxyXG4gICAgaWYgKGFwcHJvdmVySWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgeyBkYXRhOiBhcHByb3ZlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAgIC5zZWxlY3QoXCJpZCwgbmFtZVwiKVxyXG4gICAgICAgIC5pbihcImlkXCIsIGFwcHJvdmVySWRzKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChhcHByb3ZlcnMpIHtcclxuICAgICAgICBhcHByb3ZlcnNNYXAgPSBhcHByb3ZlcnMucmVkdWNlKChhY2MsIHUpID0+ICh7IC4uLmFjYywgW3UuaWRdOiB1IH0pLCB7fSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNZXJnZSB1c2VyIGFuZCBhcHByb3ZlciBpbmZvXHJcbiAgICBjb25zdCBlbnJpY2hlZERhdGEgPSBrYXNib25EYXRhLm1hcChrYXNib24gPT4gKHtcclxuICAgICAgLi4ua2FzYm9uLFxyXG4gICAgICB1c2VyOiBrYXNib24udXNlcl9pZCA/IHVzZXJzTWFwW2thc2Jvbi51c2VyX2lkXSA6IG51bGwsXHJcbiAgICAgIGFwcHJvdmVyOiBrYXNib24uYXBwcm92ZWRfYnkgPyBhcHByb3ZlcnNNYXBba2FzYm9uLmFwcHJvdmVkX2J5XSA6IG51bGxcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gS2FzYm9uIHJlcXVlc3RzIHJlc3VsdDpcIiwgZW5yaWNoZWREYXRhPy5sZW5ndGggfHwgMCwgXCJyZWNvcmRzXCIpXHJcbiAgICByZXR1cm4geyBkYXRhOiBlbnJpY2hlZERhdGEgfHwgW10sIGVycm9yOiBudWxsIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gVW5leHBlY3RlZCBlcnJvciBpbiBnZXRLYXNib25SZXF1ZXN0czpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBlcnJvciBhcyBhbnkgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRLYXNib25TdGF0aXN0aWNzKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGdldEthc2JvblN0YXRpc3RpY3MgY2FsbGVkIHdpdGggYnJhbmNoSWQ6XCIsIGJyYW5jaElkKVxyXG5cclxuICB0cnkge1xyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UuZnJvbShcImthc2JvblwiKS5zZWxlY3QoXCJhbW91bnQsIHN0YXR1cywgdXNlcl9pZFwiKVxyXG5cclxuICAgIGlmIChicmFuY2hJZCAmJiBicmFuY2hJZCAhPT0gXCJhbGxcIikge1xyXG4gICAgICAvLyBGaWx0ZXIgYnkgdXNlcidzIGJyYW5jaF9pZFxyXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJzSW5CcmFuY2gsIGVycm9yOiB1c2Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWRcIilcclxuICAgICAgICAuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlcnMgaW4gYnJhbmNoOlwiLCB1c2Vyc0Vycm9yKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBwZW5kaW5nQW1vdW50OiAwLFxyXG4gICAgICAgICAgICBhcHByb3ZlZEFtb3VudDogMCxcclxuICAgICAgICAgICAgdG90YWxQYWlkOiAwLFxyXG4gICAgICAgICAgICBhY3RpdmVFbXBsb3llZXM6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IHVzZXJzRXJyb3IsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnNJbkJyYW5jaCAmJiB1c2Vyc0luQnJhbmNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB1c2VySWRzID0gdXNlcnNJbkJyYW5jaC5tYXAodSA9PiB1LmlkKTtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmluKFwidXNlcl9pZFwiLCB1c2VySWRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBwZW5kaW5nQW1vdW50OiAwLFxyXG4gICAgICAgICAgICBhcHByb3ZlZEFtb3VudDogMCxcclxuICAgICAgICAgICAgdG90YWxQYWlkOiAwLFxyXG4gICAgICAgICAgICBhY3RpdmVFbXBsb3llZXM6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIEVycm9yIGZldGNoaW5nIGthc2JvbiBzdGF0aXN0aWNzOlwiLCBlcnJvcilcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBwZW5kaW5nQW1vdW50OiAwLFxyXG4gICAgICAgICAgYXBwcm92ZWRBbW91bnQ6IDAsXHJcbiAgICAgICAgICB0b3RhbFBhaWQ6IDAsXHJcbiAgICAgICAgICBhY3RpdmVFbXBsb3llZXM6IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBlbmRpbmdBbW91bnQgPSBkYXRhPy5maWx0ZXIoKGspID0+IGsuc3RhdHVzID09PSBcInBlbmRpbmdcIikucmVkdWNlKChzdW0sIGspID0+IHN1bSArIChrLmFtb3VudCB8fCAwKSwgMCkgfHwgMFxyXG4gICAgY29uc3QgYXBwcm92ZWRBbW91bnQgPSBkYXRhPy5maWx0ZXIoKGspID0+IGsuc3RhdHVzID09PSBcImFwcHJvdmVkXCIpLnJlZHVjZSgoc3VtLCBrKSA9PiBzdW0gKyAoay5hbW91bnQgfHwgMCksIDApIHx8IDBcclxuICAgIGNvbnN0IHRvdGFsUGFpZCA9IGRhdGE/LmZpbHRlcigoaykgPT4gay5zdGF0dXMgPT09IFwicGFpZFwiKS5yZWR1Y2UoKHN1bSwgaykgPT4gc3VtICsgKGsuYW1vdW50IHx8IDApLCAwKSB8fCAwXHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiB1c2Vyc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCJpZFwiKS5lcShcInN0YXR1c1wiLCBcImFjdGl2ZVwiKVxyXG4gICAgY29uc3QgYWN0aXZlRW1wbG95ZWVzID0gdXNlcnNEYXRhPy5sZW5ndGggfHwgMFxyXG5cclxuICAgIGNvbnN0IHN0YXRpc3RpY3MgPSB7XHJcbiAgICAgIHBlbmRpbmdBbW91bnQsXHJcbiAgICAgIGFwcHJvdmVkQW1vdW50LFxyXG4gICAgICB0b3RhbFBhaWQsXHJcbiAgICAgIGFjdGl2ZUVtcGxveWVlcyxcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gS2FzYm9uIHN0YXRpc3RpY3MgcmVzdWx0OlwiLCBzdGF0aXN0aWNzKVxyXG4gICAgcmV0dXJuIHsgZGF0YTogc3RhdGlzdGljcywgZXJyb3I6IG51bGwgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBVbmV4cGVjdGVkIGVycm9yIGluIGdldEthc2JvblN0YXRpc3RpY3M6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBwZW5kaW5nQW1vdW50OiAwLFxyXG4gICAgICAgIGFwcHJvdmVkQW1vdW50OiAwLFxyXG4gICAgICAgIHRvdGFsUGFpZDogMCxcclxuICAgICAgICBhY3RpdmVFbXBsb3llZXM6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yOiBlcnJvciBhcyBhbnksXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcnNXaXRoS2FzYm9uKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGdldFVzZXJzV2l0aEthc2JvbiBjYWxsZWQgd2l0aCBicmFuY2hJZDpcIiwgYnJhbmNoSWQpXHJcblxyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCIqXCIpLm9yZGVyKFwibmFtZVwiKVxyXG5cclxuICBpZiAoYnJhbmNoSWQgJiYgYnJhbmNoSWQgIT09IFwiYWxsXCIpIHtcclxuICAgIHF1ZXJ5ID0gcXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGE6IHVzZXJzLCBlcnJvcjogdXNlcnNFcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuXHJcbiAgaWYgKHVzZXJzRXJyb3IpIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogdXNlcnNFcnJvciB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YTogYWxsS2FzYm9uLCBlcnJvcjoga2FzYm9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImthc2JvblwiKVxyXG4gICAgLnNlbGVjdChcIipcIilcclxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gIGlmIChrYXNib25FcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEthc2JvbiBlcnJvciwgcmV0dXJuaW5nIHVzZXJzIHdpdGhvdXQga2FzYm9uIGRhdGE6XCIsIGthc2JvbkVycm9yKVxyXG4gICAgY29uc3QgdXNlcnNXaXRob3V0S2FzYm9uID1cclxuICAgICAgdXNlcnM/Lm1hcCgodXNlcjogYW55KSA9PiAoe1xyXG4gICAgICAgIC4uLnVzZXIsXHJcbiAgICAgICAgdG90YWxfa2FzYm9uOiAwLFxyXG4gICAgICAgIGFjdGl2ZV9rYXNib246IDAsXHJcbiAgICAgICAga2FzYm9uX2hpc3Rvcnk6IFtdLFxyXG4gICAgICB9KSkgfHwgW11cclxuICAgIHJldHVybiB7IGRhdGE6IHVzZXJzV2l0aG91dEthc2JvbiwgZXJyb3I6IG51bGwgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdXNlcnNXaXRoS2FzYm9uRGF0YSA9XHJcbiAgICB1c2Vycz8ubWFwKCh1c2VyOiBhbnkpID0+IHtcclxuICAgICAgY29uc3QgdXNlckthc2JvbiA9IGFsbEthc2Jvbj8uZmlsdGVyKChrYXNib246IGFueSkgPT4ga2FzYm9uLnVzZXJfaWQgPT09IHVzZXIuaWQpIHx8IFtdXHJcbiAgICAgIGNvbnN0IHRvdGFsS2FzYm9uID0gdXNlckthc2Jvbi5yZWR1Y2UoKHN1bTogbnVtYmVyLCBrYXNib246IGFueSkgPT4gc3VtICsgKGthc2Jvbi5hbW91bnQgfHwgMCksIDApXHJcbiAgICAgIGNvbnN0IGFjdGl2ZUthc2JvbiA9IHVzZXJLYXNib25cclxuICAgICAgICAuZmlsdGVyKChrYXNib246IGFueSkgPT4ga2FzYm9uLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiIHx8IGthc2Jvbi5zdGF0dXMgPT09IFwicGVuZGluZ1wiKVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bTogbnVtYmVyLCBrYXNib246IGFueSkgPT4gc3VtICsgKGthc2Jvbi5hbW91bnQgfHwgMCksIDApXHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnVzZXIsXHJcbiAgICAgICAgdG90YWxfa2FzYm9uOiB0b3RhbEthc2JvbixcclxuICAgICAgICBhY3RpdmVfa2FzYm9uOiBhY3RpdmVLYXNib24sXHJcbiAgICAgICAga2FzYm9uX2hpc3Rvcnk6IHVzZXJLYXNib24sXHJcbiAgICAgIH1cclxuICAgIH0pIHx8IFtdXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBVc2VycyB3aXRoIGthc2JvbiBkYXRhOlwiLCB1c2Vyc1dpdGhLYXNib25EYXRhKVxyXG4gIHJldHVybiB7IGRhdGE6IHVzZXJzV2l0aEthc2JvbkRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUthc2JvblJlcXVlc3Qoa2FzYm9uRGF0YToge1xyXG4gIHVzZXJfaWQ6IHN0cmluZ1xyXG4gIGFtb3VudDogbnVtYmVyXHJcbiAgcmVhc29uOiBzdHJpbmdcclxuICBkdWVfZGF0ZT86IHN0cmluZ1xyXG4gIG5vdGVzPzogc3RyaW5nXHJcbn0pIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gY3JlYXRlS2FzYm9uUmVxdWVzdCBjYWxsZWQgd2l0aDpcIiwga2FzYm9uRGF0YSlcclxuXHJcbiAgLy8gR2V0IHVzZXIgbmFtZSBmb3Igc25hcHNob3RcclxuICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAuc2VsZWN0KFwibmFtZVwiKVxyXG4gICAgLmVxKFwiaWRcIiwga2FzYm9uRGF0YS51c2VyX2lkKVxyXG4gICAgLnNpbmdsZSgpXHJcblxyXG4gIGlmICh1c2VyRXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbY3JlYXRlS2FzYm9uUmVxdWVzdF0gRXJyb3IgZ2V0dGluZyB1c2VyIG5hbWU6XCIsIHVzZXJFcnJvcilcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfVxyXG4gIH1cclxuXHJcbiAgY29uc3Qga2FzYm9uVG9JbnNlcnQgPSB7XHJcbiAgICAuLi5rYXNib25EYXRhLFxyXG4gICAgdXNlcl9uYW1lOiB1c2VyPy5uYW1lIHx8IFwiVW5rbm93blwiLFxyXG4gICAgc3RhdHVzOiBcInBlbmRpbmdcIiBhcyBjb25zdCxcclxuICAgIHJlcXVlc3RfZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImthc2JvblwiKS5pbnNlcnQoW2thc2JvblRvSW5zZXJ0XSkuc2VsZWN0KCkuc2luZ2xlKClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIENyZWF0ZSBrYXNib24gcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVLYXNib25TdGF0dXMoXHJcbiAga2FzYm9uSWQ6IHN0cmluZyxcclxuICBzdGF0dXM6IFwiYXBwcm92ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwicGFpZFwiLFxyXG4gIGFwcHJvdmVkQnk6IHN0cmluZyxcclxuKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIHVwZGF0ZUthc2JvblN0YXR1cyBjYWxsZWQgd2l0aDpcIiwgeyBrYXNib25JZCwgc3RhdHVzLCBhcHByb3ZlZEJ5IH0pXHJcblxyXG4gIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcclxuICAgIHN0YXR1cyxcclxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9XHJcblxyXG4gIGlmIChzdGF0dXMgPT09IFwiYXBwcm92ZWRcIikge1xyXG4gICAgdXBkYXRlRGF0YS5hcHByb3ZlZF9ieSA9IGFwcHJvdmVkQnlcclxuICAgIHVwZGF0ZURhdGEuYXBwcm92ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJrYXNib25cIikudXBkYXRlKHVwZGF0ZURhdGEpLmVxKFwiaWRcIiwga2FzYm9uSWQpLnNlbGVjdCgpLnNpbmdsZSgpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBVcGRhdGUga2FzYm9uIHN0YXR1cyByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRW1wbG95ZWUgTWFuYWdlbWVudCBJbnRlcmZhY2VzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBpbnRlcmZhY2UgRW1wbG95ZWUge1xyXG4gIHRvdGFsQm9udXM6IG51bWJlclxyXG4gIHRvdGFsUGVuYWx0eTogbnVtYmVyXHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGVtYWlsOiBzdHJpbmdcclxuICBwaG9uZT86IHN0cmluZ1xyXG4gIHBvc2l0aW9uPzogc3RyaW5nXHJcbiAgc3RhdHVzPzogc3RyaW5nXHJcbiAgYXZhdGFyPzogc3RyaW5nXHJcbiAgcmF0aW5nPzogbnVtYmVyXHJcbiAgYmFzZVNhbGFyeT86IG51bWJlclxyXG4gIGF0dGVuZGFuY2VSYXRlPzogbnVtYmVyXHJcbiAgY3VycmVudE1vbnRoQ3VzdG9tZXJzPzogbnVtYmVyXHJcbiAgdG90YWxDdXN0b21lcnM/OiBudW1iZXJcclxuICBwcmVzZW50RGF5cz86IG51bWJlclxyXG4gIHRvdGFsV29ya0RheXM/OiBudW1iZXJcclxuICBsYXRlRGF5cz86IG51bWJlclxyXG4gIG92ZXJ0aW1lSG91cnM/OiBudW1iZXJcclxuICBvdmVydGltZVJhdGU/OiBudW1iZXJcclxuICBib251c1BvaW50cz86IG51bWJlclxyXG4gIHBlbmFsdHlQb2ludHM/OiBudW1iZXJcclxuICBjb21taXNzaW9uUmF0ZT86IG51bWJlclxyXG4gIGpvaW5EYXRlPzogc3RyaW5nXHJcbiAga2FzYm9uQmFsYW5jZT86IG51bWJlclxyXG4gIGthc2JvbkxpbWl0PzogbnVtYmVyXHJcbiAgbW9udGhseVJldmVudWU/OiBzdHJpbmdcclxuICBwaW4/OiBzdHJpbmdcclxuICBtYXhfYWJzZW50X2RheXM/OiBudW1iZXJcclxuICBjdXJyZW50X2Fic2VudF9kYXlzPzogbnVtYmVyXHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZVTkdTSSBTRURFUkhBTkE6IEhJVFVORyBIQVJJIFRJREFLIEhBRElSXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZUFic2VuY2VJbmZvKGVtcGxveWVlSWQ6IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW1NJTVBMRV0gZ2V0RW1wbG95ZWVBYnNlbmNlSW5mbyBjYWxsZWQgZm9yOlwiLCBlbXBsb3llZUlkKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIDEuIEdldCBlbXBsb3llZSBkYXRhIHRlcm1hc3VrIHNldHRpbmdhbiBsaWJ1clxyXG4gICAgY29uc3QgeyBkYXRhOiBlbXBsb3llZSwgZXJyb3I6IGVtcEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCJtYXhfYWJzZW50X2RheXNcIilcclxuICAgICAgLmVxKFwiaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChlbXBFcnJvciB8fCAhZW1wbG95ZWUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZW1wbG95ZWU6XCIsIGVtcEVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgbWF4QWJzZW50RGF5czogNCwgXHJcbiAgICAgICAgY3VycmVudEFic2VudERheXM6IDAsIFxyXG4gICAgICAgIHJlbWFpbmluZ0RheXM6IDQsXHJcbiAgICAgICAgZXhjZXNzRGF5czogMCBcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyLiBIaXR1bmcgaGFyaSB0aWRhayBoYWRpciBidWxhbiBpbmlcclxuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCksIGN1cnJlbnREYXRlLmdldE1vbnRoKCksIDEpO1xyXG4gICAgY29uc3QgbGFzdERheU9mTW9udGggPSBuZXcgRGF0ZShjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMSwgMCk7XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiBhdHRlbmRhbmNlRGF0YSwgZXJyb3I6IGF0dGVuZGFuY2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAgIC5zZWxlY3QoXCJzdGF0dXMsIGRhdGVcIilcclxuICAgICAgLmVxKFwidXNlcl9pZFwiLCBlbXBsb3llZUlkKVxyXG4gICAgICAuZ3RlKFwiZGF0ZVwiLCBmaXJzdERheU9mTW9udGgudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKVxyXG4gICAgICAubHRlKFwiZGF0ZVwiLCBsYXN0RGF5T2ZNb250aC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pO1xyXG5cclxuICAgIGlmIChhdHRlbmRhbmNlRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgYXR0ZW5kYW5jZSBkYXRhOlwiLCBhdHRlbmRhbmNlRXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBcclxuICAgICAgICBtYXhBYnNlbnREYXlzOiBlbXBsb3llZS5tYXhfYWJzZW50X2RheXMgfHwgNCwgXHJcbiAgICAgICAgY3VycmVudEFic2VudERheXM6IDAsIFxyXG4gICAgICAgIHJlbWFpbmluZ0RheXM6IGVtcGxveWVlLm1heF9hYnNlbnRfZGF5cyB8fCA0LFxyXG4gICAgICAgIGV4Y2Vzc0RheXM6IDAgXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGl0dW5nIGhhcmkgdGlkYWsgaGFkaXIgKHN0YXR1cyBhYnNlbnQgYXRhdSB0aWRhayBhZGEgZGF0YSBhdHRlbmRhbmNlKVxyXG4gICAgY29uc3QgY3VycmVudEFic2VudERheXMgPSBhdHRlbmRhbmNlRGF0YT8uZmlsdGVyKHJlY29yZCA9PiBcclxuICAgICAgcmVjb3JkLnN0YXR1cyA9PT0gXCJhYnNlbnRcIiB8fCByZWNvcmQuc3RhdHVzID09PSBudWxsXHJcbiAgICApLmxlbmd0aCB8fCAwO1xyXG5cclxuICAgIGNvbnN0IG1heEFic2VudERheXMgPSBlbXBsb3llZS5tYXhfYWJzZW50X2RheXMgfHwgNDtcclxuICAgIGNvbnN0IHJlbWFpbmluZ0RheXMgPSBNYXRoLm1heCgwLCBtYXhBYnNlbnREYXlzIC0gY3VycmVudEFic2VudERheXMpO1xyXG4gICAgY29uc3QgZXhjZXNzRGF5cyA9IE1hdGgubWF4KDAsIGN1cnJlbnRBYnNlbnREYXlzIC0gbWF4QWJzZW50RGF5cyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbU0lNUExFXSBBYnNlbmNlIGluZm86XCIsIHsgXHJcbiAgICAgIG1heEFic2VudERheXMsIFxyXG4gICAgICBjdXJyZW50QWJzZW50RGF5cywgXHJcbiAgICAgIHJlbWFpbmluZ0RheXMsIFxyXG4gICAgICBleGNlc3NEYXlzIFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIG1heEFic2VudERheXMsIFxyXG4gICAgICBjdXJyZW50QWJzZW50RGF5cywgXHJcbiAgICAgIHJlbWFpbmluZ0RheXMsIFxyXG4gICAgICBleGNlc3NEYXlzIFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBnZXRFbXBsb3llZUFic2VuY2VJbmZvOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBcclxuICAgICAgbWF4QWJzZW50RGF5czogNCwgXHJcbiAgICAgIGN1cnJlbnRBYnNlbnREYXlzOiAwLCBcclxuICAgICAgcmVtYWluaW5nRGF5czogNCxcclxuICAgICAgZXhjZXNzRGF5czogMCBcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBGVU5HU0kgVVBEQVRFIEpVTUxBSCBIQVJJIExJQlVSXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVNYXhBYnNlbnREYXlzKGVtcGxveWVlSWQ6IHN0cmluZywgbWF4RGF5czogbnVtYmVyKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgLnVwZGF0ZSh7IG1heF9hYnNlbnRfZGF5czogbWF4RGF5cyB9KVxyXG4gICAgICAuZXEoXCJpZFwiLCBlbXBsb3llZUlkKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgbWF4IGFic2VudCBkYXlzOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJNYXggYWJzZW50IGRheXMgdXBkYXRlZDpcIiwgZGF0YSk7XHJcbiAgICByZXR1cm4geyBkYXRhIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlcHRpb24gdXBkYXRpbmcgbWF4IGFic2VudCBkYXlzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBlcnJvciB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFbXBsb3llZVN0YXRzIHtcclxuICB0b3RhbFRyYW5zYWN0aW9uczogbnVtYmVyXHJcbiAgdG90YWxSZXZlbnVlOiBudW1iZXJcclxuICB0b3RhbENvbW1pc3Npb246IG51bWJlclxyXG4gIGF2ZXJhZ2VUcmFuc2FjdGlvbjogbnVtYmVyXHJcbiAgYm9udXNQb2ludHM/OiBudW1iZXJcclxuICBwZW5hbHR5UG9pbnRzPzogbnVtYmVyXHJcbiAgdG90YWxCb251cz86IG51bWJlclxyXG4gIHRvdGFsUGVuYWx0eT86IG51bWJlclxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBFbXBsb3llZSBNYW5hZ2VtZW50IEZ1bmN0aW9uc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVtcGxveWVlcygpIHtcclxuICBjb25zb2xlLmxvZyhcIltNT0RFUk5dIGdldEVtcGxveWVlcyBjYWxsZWQgLSBmZXRjaGluZyBhbGwgZW1wbG95ZWVzIGluY2x1ZGluZyBpbmFjdGl2ZVwiKTtcclxuXHJcbiAgY29uc3QgeyBkYXRhOiB1c2VycywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAuc2VsZWN0KGBcclxuICAgICAgaWQsXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGVtYWlsLFxyXG4gICAgICBwaG9uZSxcclxuICAgICAgcG9zaXRpb24sXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgY3JlYXRlZF9hdCxcclxuICAgICAgc2FsYXJ5LFxyXG4gICAgICBjb21taXNzaW9uX3JhdGUsXHJcbiAgICAgIG1heF9hYnNlbnRfZGF5cyxcclxuICAgICAgcGluLFxyXG4gICAgICByYXRpbmcsXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlLFxyXG4gICAgICBjdXJyZW50TW9udGhDdXN0b21lcnMsXHJcbiAgICAgIHRvdGFsQ3VzdG9tZXJzLFxyXG4gICAgICBwcmVzZW50RGF5cyxcclxuICAgICAgdG90YWxXb3JrRGF5cyxcclxuICAgICAgbGF0ZURheXMsXHJcbiAgICAgIG92ZXJ0aW1lSG91cnMsXHJcbiAgICAgIG92ZXJ0aW1lUmF0ZSxcclxuICAgICAgYm9udXNQb2ludHMsXHJcbiAgICAgIHBlbmFsdHlQb2ludHMsXHJcbiAgICAgIGthc2JvbkJhbGFuY2UsXHJcbiAgICAgIGthc2JvbkxpbWl0LFxyXG4gICAgICBtb250aGx5UmV2ZW51ZVxyXG4gICAgYClcclxuICAgIC5vcmRlcihcIm5hbWVcIik7ICAvLyBUYW1waWxrYW4gU0VNVUEga2FyeWF3YW4gKGFrdGlmIGRhbiB0aWRhayBha3RpZilcclxuXHJcbiAgY29uc29sZS5sb2coXCJbTU9ERVJOXSBSZXN1bHQ6XCIsIHsgXHJcbiAgICB1c2Vyc0NvdW50OiB1c2Vycz8ubGVuZ3RoLCBcclxuICAgIGhhc0Vycm9yOiAhIXVzZXJzRXJyb3IsXHJcbiAgICBmaXJzdFVzZXI6IHVzZXJzPy5bMF1cclxuICB9KTtcclxuXHJcbiAgLy8gUEVOVElORzogSGFueWEgcmV0dXJuIGVycm9yIGppa2EgYmVuYXItYmVuYXIgYWRhIGVycm9yIERBTiB0aWRhayBhZGEgZGF0YVxyXG4gIGlmICh1c2Vyc0Vycm9yICYmICF1c2Vycykge1xyXG4gICAgY29uc29sZS5lcnJvcihcIltNT0RFUk5dIEVycm9yIGZldGNoaW5nIGVtcGxveWVlczpcIiwgdXNlcnNFcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IHVzZXJzRXJyb3IgfTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybWFzaSBkYXRhIC0gZ3VuYWthbiBkYXRhIGRhcmkgZGF0YWJhc2VcclxuICBjb25zdCBlbXBsb3llZXMgPSAodXNlcnMgfHwgW10pLm1hcCgodXNlcjogYW55KSA9PiAoe1xyXG4gICAgaWQ6IHVzZXIuaWQsXHJcbiAgICBuYW1lOiB1c2VyLm5hbWUsXHJcbiAgICBlbWFpbDogdXNlci5lbWFpbCB8fCAnJyxcclxuICAgIHBob25lOiB1c2VyLnBob25lIHx8ICcnLFxyXG4gICAgcG9zaXRpb246IHVzZXIucG9zaXRpb24gfHwgJycsXHJcbiAgICBzdGF0dXM6IHVzZXIuc3RhdHVzIHx8ICdhY3RpdmUnLFxyXG4gICAgc2FsYXJ5OiB1c2VyLnNhbGFyeSB8fCAzMDAwMDAwLCAvLyBUYW1iYWhrYW4gc2FsYXJ5IHVudHVrIGRpdGFtcGlsa2FuIGRpIGthcnR1XHJcbiAgICBiYXNlU2FsYXJ5OiB1c2VyLnNhbGFyeSB8fCAzMDAwMDAwLFxyXG4gICAgY29tbWlzc2lvblJhdGU6IHVzZXIuY29tbWlzc2lvbl9yYXRlIHx8IDAsXHJcbiAgICBwaW46IHVzZXIucGluIHx8ICcnLFxyXG4gICAgbWF4X2Fic2VudF9kYXlzOiB1c2VyLm1heF9hYnNlbnRfZGF5cyB8fCA0LFxyXG4gICAgY3JlYXRlZF9hdDogdXNlci5jcmVhdGVkX2F0LFxyXG4gICAgdG90YWxCb251czogMCxcclxuICAgIHRvdGFsUGVuYWx0eTogMCxcclxuICAgIHJhdGluZzogdXNlci5yYXRpbmcgfHwgMCxcclxuICAgIGF0dGVuZGFuY2VSYXRlOiB1c2VyLmF0dGVuZGFuY2VSYXRlIHx8IDAsXHJcbiAgICBjdXJyZW50TW9udGhDdXN0b21lcnM6IHVzZXIuY3VycmVudE1vbnRoQ3VzdG9tZXJzIHx8IDAsXHJcbiAgICB0b3RhbEN1c3RvbWVyczogdXNlci50b3RhbEN1c3RvbWVycyB8fCAwLFxyXG4gICAgcHJlc2VudERheXM6IHVzZXIucHJlc2VudERheXMgfHwgMCxcclxuICAgIHRvdGFsV29ya0RheXM6IHVzZXIudG90YWxXb3JrRGF5cyB8fCAwLFxyXG4gICAgbGF0ZURheXM6IHVzZXIubGF0ZURheXMgfHwgMCxcclxuICAgIG92ZXJ0aW1lSG91cnM6IHVzZXIub3ZlcnRpbWVIb3VycyB8fCAwLFxyXG4gICAgb3ZlcnRpbWVSYXRlOiB1c2VyLm92ZXJ0aW1lUmF0ZSB8fCAwLFxyXG4gICAgYm9udXNQb2ludHM6IHVzZXIuYm9udXNQb2ludHMgfHwgMCxcclxuICAgIHBlbmFsdHlQb2ludHM6IHVzZXIucGVuYWx0eVBvaW50cyB8fCAwLFxyXG4gICAga2FzYm9uQmFsYW5jZTogdXNlci5rYXNib25CYWxhbmNlIHx8IDAsXHJcbiAgICBrYXNib25MaW1pdDogdXNlci5rYXNib25MaW1pdCB8fCAwLFxyXG4gICAgbW9udGhseVJldmVudWU6IFN0cmluZyh1c2VyLm1vbnRobHlSZXZlbnVlIHx8ICcwJylcclxuICB9KSk7XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW01PREVSTl0gRmluYWwgZW1wbG95ZWVzOlwiLCBlbXBsb3llZXMubGVuZ3RoKTtcclxuICByZXR1cm4geyBkYXRhOiBlbXBsb3llZXMsIGVycm9yOiBudWxsIH07XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRFbXBsb3llZShlbXBsb3llZTogUGFydGlhbDxFbXBsb3llZT4pIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MTFdIGFkZEVtcGxveWVlIGNhbGxlZCB3aXRoOlwiLCBlbXBsb3llZSlcclxuXHJcbiAgLy8gSnVzdCBjcmVhdGUgdXNlciBwcm9maWxlIGluIHVzZXJzIHRhYmxlXHJcbiAgLy8gQWRtaW4gd2lsbCBtYW51YWxseSBjcmVhdGUgYXV0aCB1c2VyIGluIFN1cGFiYXNlIERhc2hib2FyZCBpZiBuZWVkZWRcclxuICBjb25zdCB1c2VyRGF0YSA9IHtcclxuICAgIG5hbWU6IGVtcGxveWVlLm5hbWUsXHJcbiAgICBlbWFpbDogZW1wbG95ZWUuZW1haWwsXHJcbiAgICBwaG9uZTogZW1wbG95ZWUucGhvbmUgfHwgbnVsbCxcclxuICAgIHN0YXR1czogZW1wbG95ZWUuc3RhdHVzIHx8IFwiYWN0aXZlXCIsXHJcbiAgICBwaW46IGVtcGxveWVlLnBpbixcclxuICAgIHBvc2l0aW9uOiBlbXBsb3llZS5wb3NpdGlvbixcclxuICAgIHNhbGFyeTogZW1wbG95ZWUuc2FsYXJ5IHx8IGVtcGxveWVlLmJhc2VTYWxhcnkgfHwgMCxcclxuICAgIGNvbW1pc3Npb25fcmF0ZTogZW1wbG95ZWUuY29tbWlzc2lvblJhdGUgfHwgMCxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5pbnNlcnQoW3VzZXJEYXRhXSkuc2VsZWN0KCkuc2luZ2xlKClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjExXSBhZGRFbXBsb3llZSByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVFbXBsb3llZShpZDogc3RyaW5nLCBlbXBsb3llZTogUGFydGlhbDxFbXBsb3llZT4pIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MTFdIHVwZGF0ZUVtcGxveWVlIGNhbGxlZCB3aXRoOlwiLCBpZClcclxuXHJcbiAgY29uc3QgdXNlckRhdGEgPSB7XHJcbiAgICBuYW1lOiBlbXBsb3llZS5uYW1lLFxyXG4gICAgZW1haWw6IGVtcGxveWVlLmVtYWlsLFxyXG4gICAgcGhvbmU6IGVtcGxveWVlLnBob25lLFxyXG4gICAgc3RhdHVzOiBlbXBsb3llZS5zdGF0dXMsXHJcbiAgICBwaW46IGVtcGxveWVlLnBpbixcclxuICAgIHBvc2l0aW9uOiBlbXBsb3llZS5wb3NpdGlvbixcclxuICAgIHNhbGFyeTogZW1wbG95ZWUuYmFzZVNhbGFyeSxcclxuICAgIGNvbW1pc3Npb25fcmF0ZTogZW1wbG95ZWUuY29tbWlzc2lvblJhdGUsXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikudXBkYXRlKHVzZXJEYXRhKS5lcShcImlkXCIsIGlkKS5zZWxlY3QoKS5zaW5nbGUoKVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MTFdIHVwZGF0ZUVtcGxveWVlIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUVtcGxveWVlKGlkOiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIltkZWxldGVFbXBsb3llZV0gU3RhcnRpbmcgZGVsZXRpb24gZm9yIGlkOlwiLCBpZClcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENlayBhcGFrYWggdXNlciBhZGFcclxuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VyLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAuZXEoXCJpZFwiLCBpZClcclxuICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgaWYgKGNoZWNrRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltkZWxldGVFbXBsb3llZV0gRXJyb3IgY2hlY2tpbmcgdXNlcjpcIiwgY2hlY2tFcnJvcilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoZWNrRXJyb3IgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhpc3RpbmdVc2VyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbZGVsZXRlRW1wbG95ZWVdIFVzZXIgbm90IGZvdW5kXCIpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6IFwiS2FyeWF3YW4gdGlkYWsgZGl0ZW11a2FuXCIgfSBhcyBhbnkgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2RlbGV0ZUVtcGxveWVlXSBVc2VyIGV4aXN0czpcIiwgZXhpc3RpbmdVc2VyKVxyXG5cclxuICAgIC8vIFNPRlQgREVMRVRFIC0gdWJhaCBzdGF0dXMgamFkaSAnaW5hY3RpdmUnIGFnYXIgZGF0YSB0ZXRhcCBhZGEgdW50dWsgdHJhbnNha3NpXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdpbmFjdGl2ZScgfSlcclxuICAgICAgLmVxKFwiaWRcIiwgaWQpXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKClcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIltkZWxldGVFbXBsb3llZV0gU29mdCBkZWxldGUgcmVzcG9uc2U6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltkZWxldGVFbXBsb3llZV0gU29mdCBkZWxldGUgZXJyb3I6XCIsIGVycm9yKVxyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZGVsZXRlRW1wbG95ZWVdIFNvZnQgZGVsZXRlIHN1Y2Nlc3NmdWwgLSBzdGF0dXMgY2hhbmdlZCB0byBpbmFjdGl2ZVwiKVxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG4gICAgXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIltkZWxldGVFbXBsb3llZV0gRXhjZXB0aW9uOlwiLCBlKVxyXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogU3RyaW5nKGUpIH0gYXMgYW55IH1cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBFUkJBSUtBTiBGVU5HU0kgR0VUIEVNUExPWUVFIFNUQVRTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZVN0YXRzKGVtcGxveWVlSWQ6IHN0cmluZyk6IFByb21pc2U8RW1wbG95ZWVTdGF0cz4ge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YxMy1GSVhFRF0gZ2V0RW1wbG95ZWVTdGF0cyBjYWxsZWQgZm9yOlwiLCBlbXBsb3llZUlkKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIDEuIEhpdHVuZyB0cmFuc2Frc2kgZGFuIHJldmVudWUgLSBndW5ha2FuIHNlcnZlcl9pZCAoeWFuZyBtZWxheWFuaSksIGJ1a2FuIGNhc2hpZXJfaWRcclxuICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zLCBlcnJvcjogdHJhbnNhY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidHJhbnNhY3Rpb25zXCIpXHJcbiAgICAgIC5zZWxlY3QoXCJ0b3RhbF9hbW91bnQsIGNyZWF0ZWRfYXRcIilcclxuICAgICAgLmVxKFwic2VydmVyX2lkXCIsIGVtcGxveWVlSWQpXHJcbiAgICAgIC5ndGUoXCJjcmVhdGVkX2F0XCIsIG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgbmV3IERhdGUoKS5nZXRNb250aCgpLCAxKS50b0lTT1N0cmluZygpKTtcclxuXHJcbiAgICBpZiAodHJhbnNhY3Rpb25zRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlt2MTMtRklYRURdIEVycm9yIGZldGNoaW5nIHRyYW5zYWN0aW9uczpcIiwgdHJhbnNhY3Rpb25zRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvdGFsVHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zPy5sZW5ndGggfHwgMDtcclxuICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IHRyYW5zYWN0aW9ucz8ucmVkdWNlKChzdW0sIHQpID0+IHN1bSArICh0LnRvdGFsX2Ftb3VudCB8fCAwKSwgMCkgfHwgMDtcclxuICAgIGNvbnN0IGF2ZXJhZ2VUcmFuc2FjdGlvbiA9IHRvdGFsVHJhbnNhY3Rpb25zID4gMCA/IHRvdGFsUmV2ZW51ZSAvIHRvdGFsVHJhbnNhY3Rpb25zIDogMDtcclxuXHJcbiAgICAvLyAyLiBIaXR1bmcga29taXNpIGRhcmkgY29tbWlzc2lvbl9hbW91bnQgeWFuZyBzdWRhaCB0ZXJzaW1wYW4gZGkgdHJhbnNhY3Rpb25faXRlbXNcclxuICAgIGxldCB0b3RhbENvbW1pc3Npb24gPSAwO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVTdGF0c10gQ2FsY3VsYXRpbmcgY29tbWlzc2lvbiBmb3IgZW1wbG95ZWU6XCIsIGVtcGxveWVlSWQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhOiBjb21taXNzaW9uRGF0YSwgZXJyb3I6IGNvbW1pc3Npb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInRyYW5zYWN0aW9uX2l0ZW1zXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImNvbW1pc3Npb25fYW1vdW50LCBjb21taXNzaW9uX3N0YXR1c1wiKVxyXG4gICAgICAgIC5lcShcImJhcmJlcl9pZFwiLCBlbXBsb3llZUlkKVxyXG4gICAgICAgIC5lcShcImNvbW1pc3Npb25fc3RhdHVzXCIsIFwiY3JlZGl0ZWRcIilcclxuICAgICAgICAuZ3RlKFwiY3JlYXRlZF9hdFwiLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIG5ldyBEYXRlKCkuZ2V0TW9udGgoKSwgMSkudG9JU09TdHJpbmcoKSk7XHJcblxyXG4gICAgICBpZiAoIWNvbW1pc3Npb25FcnJvciAmJiBjb21taXNzaW9uRGF0YSkge1xyXG4gICAgICAgIHRvdGFsQ29tbWlzc2lvbiA9IGNvbW1pc3Npb25EYXRhLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gc3VtICsgKGl0ZW0uY29tbWlzc2lvbl9hbW91bnQgfHwgMCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVTdGF0c10gQ29tbWlzc2lvbiBpdGVtcyBmb3VuZDpcIiwgY29tbWlzc2lvbkRhdGEubGVuZ3RoLCBcIlRvdGFsOlwiLCB0b3RhbENvbW1pc3Npb24pO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbW1pc3Npb25FcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjEzLUZJWEVEXSBFcnJvciBjYWxjdWxhdGluZyBjb21taXNzaW9uOlwiLCBjb21taXNzaW9uRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChjb21taXNzaW9uRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlt2MTMtRklYRURdIFVuZXhwZWN0ZWQgZXJyb3IgY2FsY3VsYXRpbmcgY29tbWlzc2lvbjpcIiwgY29tbWlzc2lvbkVycm9yKTtcclxuICAgICAgdG90YWxDb21taXNzaW9uID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAzLiBIaXR1bmcgcG9pbnRzIHVudHVrIGJvbnVzL3BlbmFsdHlcclxuICAgIGNvbnN0IHsgZGF0YTogcG9pbnRzRGF0YSwgZXJyb3I6IHBvaW50c0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInBvaW50c1wiKVxyXG4gICAgICAuc2VsZWN0KFwicG9pbnRzX2Vhcm5lZCwgcG9pbnRzX3R5cGVcIilcclxuICAgICAgLmVxKFwidXNlcl9pZFwiLCBlbXBsb3llZUlkKVxyXG4gICAgICAuZ3RlKFwiY3JlYXRlZF9hdFwiLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIG5ldyBEYXRlKCkuZ2V0TW9udGgoKSwgMSkudG9JU09TdHJpbmcoKSk7XHJcblxyXG4gICAgbGV0IGJvbnVzUG9pbnRzID0gMDtcclxuICAgIGxldCBwZW5hbHR5UG9pbnRzID0gMDtcclxuICAgIFxyXG4gICAgaWYgKCFwb2ludHNFcnJvciAmJiBwb2ludHNEYXRhKSB7XHJcbiAgICAgIHBvaW50c0RhdGEuZm9yRWFjaChwb2ludCA9PiB7XHJcbiAgICAgICAgaWYgKHBvaW50LnBvaW50c19lYXJuZWQgPiAwKSB7XHJcbiAgICAgICAgICBib251c1BvaW50cyArPSBwb2ludC5wb2ludHNfZWFybmVkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwZW5hbHR5UG9pbnRzICs9IE1hdGguYWJzKHBvaW50LnBvaW50c19lYXJuZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdHM6IEVtcGxveWVlU3RhdHMgPSB7XHJcbiAgICAgIHRvdGFsVHJhbnNhY3Rpb25zLFxyXG4gICAgICB0b3RhbFJldmVudWUsXHJcbiAgICAgIHRvdGFsQ29tbWlzc2lvbixcclxuICAgICAgYXZlcmFnZVRyYW5zYWN0aW9uLFxyXG4gICAgICBib251c1BvaW50cyxcclxuICAgICAgcGVuYWx0eVBvaW50cyxcclxuICAgICAgdG90YWxCb251czogYm9udXNQb2ludHMsXHJcbiAgICAgIHRvdGFsUGVuYWx0eTogcGVuYWx0eVBvaW50c1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MTMtRklYRURdIEVtcGxveWVlIHN0YXRzOlwiLCBzdGF0cyk7XHJcbiAgICByZXR1cm4gc3RhdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjEzLUZJWEVEXSBVbmV4cGVjdGVkIGVycm9yIGluIGdldEVtcGxveWVlU3RhdHM6XCIsIGVycm9yKTtcclxuICAgIFxyXG4gICAgLy8gUmV0dXJuIGRlZmF1bHQgc3RhdHMgamlrYSB0ZXJqYWRpIGVycm9yXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbFRyYW5zYWN0aW9uczogMCxcclxuICAgICAgdG90YWxSZXZlbnVlOiAwLFxyXG4gICAgICB0b3RhbENvbW1pc3Npb246IDAsXHJcbiAgICAgIGF2ZXJhZ2VUcmFuc2FjdGlvbjogMCxcclxuICAgICAgYm9udXNQb2ludHM6IDAsXHJcbiAgICAgIHBlbmFsdHlQb2ludHM6IDAsXHJcbiAgICAgIHRvdGFsQm9udXM6IDAsXHJcbiAgICAgIHRvdGFsUGVuYWx0eTogMFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZUNvbW1pc3Npb25zKGVtcGxveWVlSWQ6IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YxMi1GSVhFRF0gZ2V0RW1wbG95ZWVDb21taXNzaW9ucyAobm93IHJ1bGVzKSBjYWxsZWQgZm9yOlwiLCBlbXBsb3llZUlkKVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJjb21taXNzaW9uX3J1bGVzXCIpXHJcbiAgICAuc2VsZWN0KGAqLCBzZXJ2aWNlcyAobmFtZSwgcHJpY2UpYClcclxuICAgIC5lcShcInVzZXJfaWRcIiwgZW1wbG95ZWVJZClcclxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICBpZiAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjEyLUZJWEVEXSBFcnJvciBmZXRjaGluZyBjb21taXNzaW9uIHJ1bGVzOlwiLCBlcnJvcik7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MTItRklYRURdIEVtcGxveWVlIGNvbW1pc3Npb24gcnVsZXMgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQRVJCQUlLQU4gRlVOR1NJIEdFVCBFTVBMT1lFRSBBVFRFTkRBTkNFXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZUF0dGVuZGFuY2UoZW1wbG95ZWVJZDogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjEzLUZJWEVEXSBnZXRFbXBsb3llZUF0dGVuZGFuY2UgY2FsbGVkIGZvcjpcIiwgZW1wbG95ZWVJZCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCk7XHJcbiAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcclxuICAgIGNvbnN0IGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCBjdXJyZW50TW9udGgsIDEpO1xyXG4gICAgY29uc3QgbGFzdERheU9mTW9udGggPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoICsgMSwgMCk7XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgLmd0ZShcImRhdGVcIiwgZmlyc3REYXlPZk1vbnRoLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSlcclxuICAgICAgLmx0ZShcImRhdGVcIiwgbGFzdERheU9mTW9udGgudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKVxyXG4gICAgICAub3JkZXIoXCJkYXRlXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YxMy1GSVhFRF0gRXJyb3IgZmV0Y2hpbmcgYXR0ZW5kYW5jZTpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGF0dGVuZGFuY2VSYXRlOiAwLFxyXG4gICAgICAgIHByZXNlbnREYXlzOiAwLFxyXG4gICAgICAgIGxhdGVEYXlzOiAwLFxyXG4gICAgICAgIG92ZXJ0aW1lSG91cnM6IDAsXHJcbiAgICAgICAgdG90YWxXb3JrRGF5czogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvdGFsV29ya0RheXMgPSBnZXRCdXNpbmVzc0RheXNDb3VudChmaXJzdERheU9mTW9udGgsIGxhc3REYXlPZk1vbnRoKTtcclxuICAgIGNvbnN0IHByZXNlbnREYXlzID0gZGF0YS5maWx0ZXIocmVjb3JkID0+IFxyXG4gICAgICByZWNvcmQuc3RhdHVzID09PSBcImNoZWNrZWRfb3V0XCIgfHwgcmVjb3JkLnN0YXR1cyA9PT0gXCJjaGVja2VkX2luXCJcclxuICAgICkubGVuZ3RoO1xyXG5cclxuICAgIGNvbnN0IGxhdGVEYXlzID0gZGF0YS5maWx0ZXIocmVjb3JkID0+IHtcclxuICAgICAgaWYgKCFyZWNvcmQuY2hlY2tfaW5fdGltZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBjb25zdCBjaGVja0luVGltZSA9IHJlY29yZC5jaGVja19pbl90aW1lO1xyXG4gICAgICByZXR1cm4gY2hlY2tJblRpbWUgPiBcIjA4OjMwOjAwXCI7XHJcbiAgICB9KS5sZW5ndGg7XHJcblxyXG4gICAgY29uc3QgdG90YWxIb3VycyA9IGRhdGEucmVkdWNlKChzdW0sIHJlY29yZCkgPT4gc3VtICsgKHJlY29yZC50b3RhbF9ob3VycyB8fCAwKSwgMCk7XHJcbiAgICBjb25zdCByZWd1bGFySG91cnMgPSBwcmVzZW50RGF5cyAqIDg7XHJcbiAgICBjb25zdCBvdmVydGltZUhvdXJzID0gTWF0aC5tYXgoMCwgdG90YWxIb3VycyAtIHJlZ3VsYXJIb3Vycyk7XHJcbiAgICBjb25zdCBhdHRlbmRhbmNlUmF0ZSA9IHRvdGFsV29ya0RheXMgPiAwID8gTWF0aC5yb3VuZCgocHJlc2VudERheXMgLyB0b3RhbFdvcmtEYXlzKSAqIDEwMCkgOiAwO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW3YxMy1GSVhFRF0gRW1wbG95ZWUgYXR0ZW5kYW5jZSByZXN1bHQ6XCIsIHsgXHJcbiAgICAgIHRvdGFsV29ya0RheXMsIFxyXG4gICAgICBwcmVzZW50RGF5cywgXHJcbiAgICAgIGxhdGVEYXlzLCBcclxuICAgICAgb3ZlcnRpbWVIb3VyczogTWF0aC5tYXgoMCwgb3ZlcnRpbWVIb3VycyksXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlIFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogZGF0YSB8fCBbXSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlLFxyXG4gICAgICBwcmVzZW50RGF5cyxcclxuICAgICAgbGF0ZURheXMsXHJcbiAgICAgIG92ZXJ0aW1lSG91cnM6IE1hdGgubWF4KDAsIG92ZXJ0aW1lSG91cnMpLFxyXG4gICAgICB0b3RhbFdvcmtEYXlzXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YxMy1GSVhFRF0gVW5leHBlY3RlZCBlcnJvciBpbiBnZXRFbXBsb3llZUF0dGVuZGFuY2U6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IFtdLFxyXG4gICAgICBlcnJvcjogZXJyb3IgYXMgYW55LFxyXG4gICAgICBhdHRlbmRhbmNlUmF0ZTogMCxcclxuICAgICAgcHJlc2VudERheXM6IDAsXHJcbiAgICAgIGxhdGVEYXlzOiAwLFxyXG4gICAgICBvdmVydGltZUhvdXJzOiAwLFxyXG4gICAgICB0b3RhbFdvcmtEYXlzOiAwXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8g8J+UpSBGVU5HU0kgQkFSVSBZQU5HIERJVEFNQkFIS0FOIC0gZ2V0RW1wbG95ZWVQaG90b3NcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVtcGxveWVlUGhvdG9zKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVQaG90b3NdIENhbGxlZCB3aXRoIHVzZXJJZDpcIiwgdXNlcklkKVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgdXNlcnM6dXNlcl9pZCAoIGlkLCBuYW1lLCBlbWFpbCwgcG9zaXRpb24sIGJyYW5jaF9pZCApLFxyXG4gICAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoIGlkLCBuYW1lLCBhZGRyZXNzIClcclxuICAgICAgYClcclxuICAgICAgLmVxKFwidXNlcl9pZFwiLCB1c2VySWQpXHJcbiAgICAgIC5vcihcImNoZWNrX2luX3Bob3RvLm5vdC5pcy5udWxsLGNoZWNrX291dF9waG90by5ub3QuaXMubnVsbFwiKVxyXG4gICAgICAub3JkZXIoXCJkYXRlXCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAubGltaXQoNTApXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVQaG90b3NdIFF1ZXJ5IHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW2dldEVtcGxveWVlUGhvdG9zXSBFcnJvcjpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdHRlbmRhbmNlV2l0aERldGFpbHM6IEF0dGVuZGFuY2VXaXRoRGV0YWlsc1tdID0gKGRhdGEgfHwgW10pLm1hcCgocmVjb3JkOiBhbnkpID0+ICh7XHJcbiAgICAgIGlkOiByZWNvcmQuaWQsXHJcbiAgICAgIHVzZXJfaWQ6IHJlY29yZC51c2VyX2lkLFxyXG4gICAgICBicmFuY2hfaWQ6IHJlY29yZC5icmFuY2hfaWQsXHJcbiAgICAgIHNoaWZ0X3R5cGU6IHJlY29yZC5zaGlmdF90eXBlLFxyXG4gICAgICBjaGVja19pbl90aW1lOiByZWNvcmQuY2hlY2tfaW5fdGltZSxcclxuICAgICAgY2hlY2tfb3V0X3RpbWU6IHJlY29yZC5jaGVja19vdXRfdGltZSxcclxuICAgICAgYnJlYWtfc3RhcnRfdGltZTogcmVjb3JkLmJyZWFrX3N0YXJ0X3RpbWUsXHJcbiAgICAgIGJyZWFrX2VuZF90aW1lOiByZWNvcmQuYnJlYWtfZW5kX3RpbWUsXHJcbiAgICAgIHRvdGFsX2hvdXJzOiByZWNvcmQudG90YWxfaG91cnMsXHJcbiAgICAgIGJyZWFrX2R1cmF0aW9uOiByZWNvcmQuYnJlYWtfZHVyYXRpb24sXHJcbiAgICAgIHN0YXR1czogcmVjb3JkLnN0YXR1cyxcclxuICAgICAgY2hlY2tfaW5fcGhvdG86IHJlY29yZC5jaGVja19pbl9waG90byxcclxuICAgICAgY2hlY2tfb3V0X3Bob3RvOiByZWNvcmQuY2hlY2tfb3V0X3Bob3RvLFxyXG4gICAgICBkYXRlOiByZWNvcmQuZGF0ZSxcclxuICAgICAgY3JlYXRlZF9hdDogcmVjb3JkLmNyZWF0ZWRfYXQsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IHJlY29yZC51cGRhdGVkX2F0LFxyXG4gICAgICB1c2VyczogcmVjb3JkLnVzZXJzID8ge1xyXG4gICAgICAgIGlkOiByZWNvcmQudXNlcnMuaWQsXHJcbiAgICAgICAgbmFtZTogcmVjb3JkLnVzZXJzLm5hbWUsXHJcbiAgICAgICAgZW1haWw6IHJlY29yZC51c2Vycy5lbWFpbCxcclxuICAgICAgICBwb3NpdGlvbjogcmVjb3JkLnVzZXJzLnBvc2l0aW9uLFxyXG4gICAgICAgIGJyYW5jaF9pZDogcmVjb3JkLnVzZXJzLmJyYW5jaF9pZCxcclxuICAgICAgICBjcmVhdGVkX2F0OiByZWNvcmQudXNlcnMuY3JlYXRlZF9hdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgYnJhbmNoZXM6IHJlY29yZC5icmFuY2hlcyA/IHtcclxuICAgICAgICBpZDogcmVjb3JkLmJyYW5jaGVzLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC5icmFuY2hlcy5uYW1lLFxyXG4gICAgICAgIGFkZHJlc3M6IHJlY29yZC5icmFuY2hlcy5hZGRyZXNzLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IHJlY29yZC5icmFuY2hlcy5jcmVhdGVkX2F0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9IDogdW5kZWZpbmVkXHJcbiAgICB9KSlcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIltnZXRFbXBsb3llZVBob3Rvc10gUmV0dXJuaW5nOlwiLCBhdHRlbmRhbmNlV2l0aERldGFpbHMubGVuZ3RoLCBcInJlY29yZHNcIilcclxuICAgIHJldHVybiB7IGRhdGE6IGF0dGVuZGFuY2VXaXRoRGV0YWlscywgZXJyb3I6IG51bGwgfVxyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIltnZXRFbXBsb3llZVBob3Rvc10gRXhjZXB0aW9uOlwiLCBlcnJvcilcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIPCflKUgRlVOR1NJIEJBUlUgWUFORyBESVRBTUJBSEtBTiAtIGdldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3NcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3ModXNlcklkOiBzdHJpbmcsIGRheXM6IG51bWJlciA9IDMwKSB7XHJcbiAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3Rvc10gQ2FsbGVkIHdpdGggdXNlcklkOlwiLCB1c2VySWQsIFwiZGF5czpcIiwgZGF5cylcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICBzdGFydERhdGUuc2V0RGF0ZShlbmREYXRlLmdldERhdGUoKSAtIGRheXMpXHJcblxyXG4gICAgY29uc3Qgc3RhcnREYXRlU3RyID0gc3RhcnREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxyXG4gICAgY29uc3QgZW5kRGF0ZVN0ciA9IGVuZERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3Rvc10gRGF0ZSByYW5nZTpcIiwgc3RhcnREYXRlU3RyLCBcInRvXCIsIGVuZERhdGVTdHIpXHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgdXNlcnM6dXNlcl9pZCAoIGlkLCBuYW1lLCBlbWFpbCwgcG9zaXRpb24sIGJyYW5jaF9pZCApLFxyXG4gICAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoIGlkLCBuYW1lLCBhZGRyZXNzIClcclxuICAgICAgYClcclxuICAgICAgLmVxKFwidXNlcl9pZFwiLCB1c2VySWQpXHJcbiAgICAgIC5ndGUoXCJkYXRlXCIsIHN0YXJ0RGF0ZVN0cilcclxuICAgICAgLmx0ZShcImRhdGVcIiwgZW5kRGF0ZVN0cilcclxuICAgICAgLm9yZGVyKFwiZGF0ZVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIltnZXRFbXBsb3llZUF0dGVuZGFuY2VXaXRoUGhvdG9zXSBRdWVyeSByZXN1bHQ6XCIsIHsgZGF0YUxlbmd0aDogZGF0YT8ubGVuZ3RoLCBlcnJvciB9KVxyXG5cclxuICAgIC8vIElnbm9yZSBlbXB0eSBlcnJvciBvYmplY3RzXHJcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2UpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltnZXRFbXBsb3llZUF0dGVuZGFuY2VXaXRoUGhvdG9zXSBFcnJvcjpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogW10sXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgYXR0ZW5kYW5jZVJhdGU6IDAsXHJcbiAgICAgICAgcHJlc2VudERheXM6IDAsXHJcbiAgICAgICAgbGF0ZURheXM6IDAsXHJcbiAgICAgICAgdG90YWxXb3JrRGF5czogZGF5cyxcclxuICAgICAgICBvdmVydGltZUhvdXJzOiAwLFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXR0ZW5kYW5jZVJlY29yZHM6IEF0dGVuZGFuY2VXaXRoRGV0YWlsc1tdID0gKGRhdGEgfHwgW10pLm1hcCgocmVjb3JkOiBhbnkpID0+ICh7XHJcbiAgICAgIGlkOiByZWNvcmQuaWQsXHJcbiAgICAgIHVzZXJfaWQ6IHJlY29yZC51c2VyX2lkLFxyXG4gICAgICBicmFuY2hfaWQ6IHJlY29yZC5icmFuY2hfaWQsXHJcbiAgICAgIHNoaWZ0X3R5cGU6IHJlY29yZC5zaGlmdF90eXBlLFxyXG4gICAgICBjaGVja19pbl90aW1lOiByZWNvcmQuY2hlY2tfaW5fdGltZSxcclxuICAgICAgY2hlY2tfb3V0X3RpbWU6IHJlY29yZC5jaGVja19vdXRfdGltZSxcclxuICAgICAgYnJlYWtfc3RhcnRfdGltZTogcmVjb3JkLmJyZWFrX3N0YXJ0X3RpbWUsXHJcbiAgICAgIGJyZWFrX2VuZF90aW1lOiByZWNvcmQuYnJlYWtfZW5kX3RpbWUsXHJcbiAgICAgIHRvdGFsX2hvdXJzOiByZWNvcmQudG90YWxfaG91cnMsXHJcbiAgICAgIGJyZWFrX2R1cmF0aW9uOiByZWNvcmQuYnJlYWtfZHVyYXRpb24sXHJcbiAgICAgIHN0YXR1czogcmVjb3JkLnN0YXR1cyxcclxuICAgICAgY2hlY2tfaW5fcGhvdG86IHJlY29yZC5jaGVja19pbl9waG90byxcclxuICAgICAgY2hlY2tfb3V0X3Bob3RvOiByZWNvcmQuY2hlY2tfb3V0X3Bob3RvLFxyXG4gICAgICBkYXRlOiByZWNvcmQuZGF0ZSxcclxuICAgICAgY3JlYXRlZF9hdDogcmVjb3JkLmNyZWF0ZWRfYXQsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IHJlY29yZC51cGRhdGVkX2F0LFxyXG4gICAgICB1c2VyczogcmVjb3JkLnVzZXJzID8ge1xyXG4gICAgICAgIGlkOiByZWNvcmQudXNlcnMuaWQsXHJcbiAgICAgICAgbmFtZTogcmVjb3JkLnVzZXJzLm5hbWUsXHJcbiAgICAgICAgZW1haWw6IHJlY29yZC51c2Vycy5lbWFpbCxcclxuICAgICAgICBwb3NpdGlvbjogcmVjb3JkLnVzZXJzLnBvc2l0aW9uLFxyXG4gICAgICAgIGJyYW5jaF9pZDogcmVjb3JkLnVzZXJzLmJyYW5jaF9pZCxcclxuICAgICAgICBjcmVhdGVkX2F0OiByZWNvcmQudXNlcnMuY3JlYXRlZF9hdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgYnJhbmNoZXM6IHJlY29yZC5icmFuY2hlcyA/IHtcclxuICAgICAgICBpZDogcmVjb3JkLmJyYW5jaGVzLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC5icmFuY2hlcy5uYW1lLFxyXG4gICAgICAgIGFkZHJlc3M6IHJlY29yZC5icmFuY2hlcy5hZGRyZXNzLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IHJlY29yZC5icmFuY2hlcy5jcmVhdGVkX2F0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9IDogdW5kZWZpbmVkXHJcbiAgICB9KSlcclxuXHJcbiAgICBjb25zdCBwcmVzZW50RGF5cyA9IGF0dGVuZGFuY2VSZWNvcmRzLmZpbHRlcihyID0+XHJcbiAgICAgIHIuc3RhdHVzICE9PSAnYWJzZW50JyAmJiAoci5jaGVja19pbl90aW1lIHx8IHIuY2hlY2tfb3V0X3RpbWUpXHJcbiAgICApLmxlbmd0aFxyXG5cclxuICAgIGNvbnN0IGxhdGVEYXlzID0gYXR0ZW5kYW5jZVJlY29yZHMuZmlsdGVyKHIgPT4ge1xyXG4gICAgICBpZiAoIXIuY2hlY2tfaW5fdGltZSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgIGNvbnN0IGNoZWNrSW5UaW1lID0gci5jaGVja19pbl90aW1lXHJcbiAgICAgIHJldHVybiBjaGVja0luVGltZSA+IFwiMDg6MzBcIlxyXG4gICAgfSkubGVuZ3RoXHJcblxyXG4gICAgY29uc3QgdG90YWxIb3VycyA9IGF0dGVuZGFuY2VSZWNvcmRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci50b3RhbF9ob3VycyB8fCAwKSwgMClcclxuICAgIGNvbnN0IHJlZ3VsYXJIb3VycyA9IHByZXNlbnREYXlzICogOFxyXG4gICAgY29uc3Qgb3ZlcnRpbWVIb3VycyA9IE1hdGgubWF4KDAsIHRvdGFsSG91cnMgLSByZWd1bGFySG91cnMpXHJcbiAgICBjb25zdCBhdHRlbmRhbmNlUmF0ZSA9IGRheXMgPiAwID8gTWF0aC5yb3VuZCgocHJlc2VudERheXMgLyBkYXlzKSAqIDEwMCkgOiAwXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3Rvc10gU3RhdGlzdGljczpcIiwge1xyXG4gICAgICBhdHRlbmRhbmNlUmF0ZSxcclxuICAgICAgcHJlc2VudERheXMsXHJcbiAgICAgIGxhdGVEYXlzLFxyXG4gICAgICB0b3RhbFdvcmtEYXlzOiBkYXlzLFxyXG4gICAgICBvdmVydGltZUhvdXJzOiBNYXRoLnJvdW5kKG92ZXJ0aW1lSG91cnMgKiAxMDApIC8gMTAwLFxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBhdHRlbmRhbmNlUmVjb3JkcyxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlLFxyXG4gICAgICBwcmVzZW50RGF5cyxcclxuICAgICAgbGF0ZURheXMsXHJcbiAgICAgIHRvdGFsV29ya0RheXM6IGRheXMsXHJcbiAgICAgIG92ZXJ0aW1lSG91cnM6IE1hdGgucm91bmQob3ZlcnRpbWVIb3VycyAqIDEwMCkgLyAxMDAsXHJcbiAgICB9XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3NdIEV4Y2VwdGlvbjpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBbXSxcclxuICAgICAgZXJyb3I6IGVycm9yIGFzIGFueSxcclxuICAgICAgYXR0ZW5kYW5jZVJhdGU6IDAsXHJcbiAgICAgIHByZXNlbnREYXlzOiAwLFxyXG4gICAgICBsYXRlRGF5czogMCxcclxuICAgICAgdG90YWxXb3JrRGF5czogZGF5cyxcclxuICAgICAgb3ZlcnRpbWVIb3VyczogMCxcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEF1dGggSGVscGVyIEZ1bmN0aW9uc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0Q3VycmVudFVzZXJdIEF1dGggdXNlcjpcIiwgdXNlcik7XHJcbiAgICBjb25zb2xlLmxvZyhcIltnZXRDdXJyZW50VXNlcl0gQXV0aCBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltnZXRDdXJyZW50VXNlcl0gRXJyb3IgZ2V0dGluZyBjdXJyZW50IHVzZXI6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVzZXI7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0Q3VycmVudFVzZXJdIFVuZXhwZWN0ZWQgZXJyb3I6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIEZ1bmdzaSB1bnR1ayBnZXQgcHJvZmlsZSBkYXJpIGF1dGggZGF0YSBzYWphXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEF1dGhVc2VyUHJvZmlsZSh1c2VySWQ6IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGF1dGhEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcclxuICAgIFxyXG4gICAgaWYgKGF1dGhEYXRhLnVzZXIgJiYgYXV0aERhdGEudXNlci5pZCA9PT0gdXNlcklkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXHJcbiAgICAgICAgZW1haWw6IGF1dGhEYXRhLnVzZXIuZW1haWwgfHwgXCJcIixcclxuICAgICAgICBuYW1lOiBhdXRoRGF0YS51c2VyLmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8IFwiVXNlclwiLFxyXG4gICAgICAgIHBpbjogXCJcIixcclxuICAgICAgICBwb3NpdGlvbjogXCJlbXBsb3llZVwiLFxyXG4gICAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcclxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0QXV0aFVzZXJQcm9maWxlXSBFcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBGdW5nc2kgdW50dWsgY3JlYXRlIHVzZXIgcHJvZmlsZSBkYXJpIGF1dGggZGF0YVxyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVVc2VyUHJvZmlsZUZyb21BdXRoKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCBhdXRoIHVzZXIgZGF0YVxyXG4gICAgY29uc3QgeyBkYXRhOiBhdXRoRGF0YSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5nZXRVc2VyQnlJZCh1c2VySWQpO1xyXG4gICAgXHJcbiAgICBpZiAoYXV0aEVycm9yIHx8ICFhdXRoRGF0YS51c2VyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY3JlYXRlVXNlclByb2ZpbGVdIENhbm5vdCBnZXQgYXV0aCB1c2VyOlwiLCBhdXRoRXJyb3IpO1xyXG4gICAgICByZXR1cm4gZ2V0QXV0aFVzZXJQcm9maWxlKHVzZXJJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHVzZXIgcHJvZmlsZVxyXG4gICAgY29uc3QgeyBkYXRhOiBuZXdVc2VyLCBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgIC5pbnNlcnQoe1xyXG4gICAgICAgIGlkOiBhdXRoRGF0YS51c2VyLmlkLFxyXG4gICAgICAgIGVtYWlsOiBhdXRoRGF0YS51c2VyLmVtYWlsLFxyXG4gICAgICAgIG5hbWU6IGF1dGhEYXRhLnVzZXIuZW1haWw/LnNwbGl0KCdAJylbMF0gfHwgJ1VzZXInLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnZW1wbG95ZWUnLFxyXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGluc2VydEVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY3JlYXRlVXNlclByb2ZpbGVdIEluc2VydCBmYWlsZWQsIHVzaW5nIGF1dGggZGF0YTpcIiwgaW5zZXJ0RXJyb3IpO1xyXG4gICAgICByZXR1cm4gZ2V0QXV0aFVzZXJQcm9maWxlKHVzZXJJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbY3JlYXRlVXNlclByb2ZpbGVdIE5ldyB1c2VyIHByb2ZpbGUgY3JlYXRlZFwiKTtcclxuICAgIHJldHVybiBuZXdVc2VyO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZVVzZXJQcm9maWxlXSBFcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGdldEF1dGhVc2VyUHJvZmlsZSh1c2VySWQpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBlbmdlbHVhcmFuIENhYmFuZ1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRXhwZW5zZVJlcXVlc3QoZXhwZW5zZUlkOiBzdHJpbmcsIGV4cGVuc2VEYXRhOiBQYXJ0aWFsPEV4cGVuc2U+KSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIHVwZGF0ZUV4cGVuc2VSZXF1ZXN0IGNhbGxlZCB3aXRoOlwiLCB7IGV4cGVuc2VJZCwgZXhwZW5zZURhdGEgfSlcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiZXhwZW5zZXNcIilcclxuICAgIC51cGRhdGUoeyBcclxuICAgICAgLi4uZXhwZW5zZURhdGEsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSlcclxuICAgIC5lcShcImlkXCIsIGV4cGVuc2VJZClcclxuICAgIC5zZWxlY3QoKVxyXG4gICAgLnNpbmdsZSgpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBVcGRhdGUgZXhwZW5zZSByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUV4cGVuc2VSZXF1ZXN0KGV4cGVuc2VJZDogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGRlbGV0ZUV4cGVuc2VSZXF1ZXN0IGNhbGxlZCB3aXRoIGlkOlwiLCBleHBlbnNlSWQpXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImV4cGVuc2VzXCIpXHJcbiAgICAuZGVsZXRlKClcclxuICAgIC5lcShcImlkXCIsIGV4cGVuc2VJZClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIERlbGV0ZSBleHBlbnNlIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUGVuZ2VsdWFyYW4gQ2FiYW5nIC0gR0VUXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFeHBlbnNlcyhicmFuY2hJZD86IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBnZXRFeHBlbnNlcyBjYWxsZWQgd2l0aCBicmFuY2hJZDpcIiwgYnJhbmNoSWQpXHJcblxyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImV4cGVuc2VzXCIpXHJcbiAgICAuc2VsZWN0KGBcclxuICAgICAgKixcclxuICAgICAgYnJhbmNoZXMhaW5uZXIgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWVcclxuICAgICAgKVxyXG4gICAgYClcclxuICAgIC5vcmRlcihcImV4cGVuc2VfZGF0ZVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgaWYgKGJyYW5jaElkKSB7XHJcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIEV4cGVuc2VzIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogW10sIGVycm9yIH0gOiB7IGRhdGE6IGRhdGEgfHwgW10sIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUGVuZ2VsdWFyYW4gQ2FiYW5nIC0gU1RBVElTVElDU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RXhwZW5zZVN0YXRpc3RpY3MoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gZ2V0RXhwZW5zZVN0YXRpc3RpY3MgY2FsbGVkIHdpdGggYnJhbmNoSWQ6XCIsIGJyYW5jaElkKVxyXG5cclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKFwiZXhwZW5zZXNcIikuc2VsZWN0KFwiYW1vdW50XCIpXHJcblxyXG4gIGlmIChicmFuY2hJZCkge1xyXG4gICAgcXVlcnkgPSBxdWVyeS5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZClcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEVycm9yIGZldGNoaW5nIGV4cGVuc2Ugc3RhdGlzdGljczpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgdG90YWxFeHBlbnNlczogMCxcclxuICAgICAgICBhdmVyYWdlUGVyVHJhbnNhY3Rpb246IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdG90YWxFeHBlbnNlcyA9IGRhdGE/LnJlZHVjZSgoc3VtLCBleHBlbnNlKSA9PiBzdW0gKyAoZXhwZW5zZS5hbW91bnQgfHwgMCksIDApIHx8IDBcclxuICBjb25zdCB0cmFuc2FjdGlvbkNvdW50ID0gZGF0YT8ubGVuZ3RoIHx8IDBcclxuICBjb25zdCBhdmVyYWdlUGVyVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbkNvdW50ID4gMCA/IE1hdGgucm91bmQodG90YWxFeHBlbnNlcyAvIHRyYW5zYWN0aW9uQ291bnQpIDogMFxyXG5cclxuICBjb25zdCBzdGF0aXN0aWNzID0ge1xyXG4gICAgdG90YWxFeHBlbnNlcyxcclxuICAgIGF2ZXJhZ2VQZXJUcmFuc2FjdGlvbixcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBFeHBlbnNlIHN0YXRpc3RpY3MgcmVzdWx0OlwiLCBzdGF0aXN0aWNzKVxyXG4gIHJldHVybiB7IGRhdGE6IHN0YXRpc3RpY3MsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUGVuZ2VsdWFyYW4gQ2FiYW5nIC0gQ1JFQVRFXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVFeHBlbnNlUmVxdWVzdChleHBlbnNlRGF0YToge1xyXG4gIGJyYW5jaF9pZD86IHN0cmluZ1xyXG4gIGNhdGVnb3J5OiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgYW1vdW50OiBudW1iZXJcclxuICBub3Rlcz86IHN0cmluZ1xyXG59KSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGNyZWF0ZUV4cGVuc2VSZXF1ZXN0IGNhbGxlZCB3aXRoOlwiLCBleHBlbnNlRGF0YSlcclxuXHJcbiAgY29uc3QgZXhwZW5zZVRvSW5zZXJ0ID0ge1xyXG4gICAgYnJhbmNoX2lkOiBleHBlbnNlRGF0YS5icmFuY2hfaWQgfHwgbnVsbCxcclxuICAgIGNhdGVnb3J5OiBleHBlbnNlRGF0YS5jYXRlZ29yeSxcclxuICAgIGRlc2NyaXB0aW9uOiBleHBlbnNlRGF0YS5kZXNjcmlwdGlvbixcclxuICAgIGFtb3VudDogZXhwZW5zZURhdGEuYW1vdW50LFxyXG4gICAgbm90ZXM6IGV4cGVuc2VEYXRhLm5vdGVzIHx8IG51bGwsXHJcbiAgICBleHBlbnNlX2RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF0sXHJcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCJEYXRhIHlhbmcgYWthbiBkaWluc2VydDpcIiwgZXhwZW5zZVRvSW5zZXJ0KVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJleHBlbnNlc1wiKVxyXG4gICAgLmluc2VydChleHBlbnNlVG9JbnNlcnQpXHJcbiAgICAuc2VsZWN0KClcclxuICAgIC5zaW5nbGUoKVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gQ3JlYXRlIGV4cGVuc2UgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRGV0YWlsIGVycm9yOlwiLCBlcnJvcilcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEtlbG9sYSBQZW5nZWx1YXJhbiBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXhwZW5zZVdpdGhEZXRhaWxzIGV4dGVuZHMgRXhwZW5zZSB7XHJcbiAgYnJhbmNoZXM/OiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9O1xyXG4gIFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsRXhwZW5zZXNXaXRoRGV0YWlscygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coXCLwn5SNIEZldGNoaW5nIGV4cGVuc2VzIHdpdGhvdXQgdXNlcnMgcmVsYXRpb25zaGlwLi4uXCIpO1xyXG4gICAgXHJcbiAgICAvLyBQQVNUSUtBTiBoYW55YSBzZWxlY3QgYnJhbmNoZXMgc2FqYSwgdGFucGEgdXNlcnNcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdleHBlbnNlcycpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgYnJhbmNoZXM6YnJhbmNoX2lkICgqKVxyXG4gICAgICBgKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBleHBlbnNlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCLinIUgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgZXhwZW5zZXM6XCIsIGRhdGE/Lmxlbmd0aCk7XHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUV4cGVuc2VTdGF0dXMoXHJcbiAgZXhwZW5zZUlkOiBzdHJpbmcsIFxyXG4gIHN0YXR1czogXCJhcHByb3ZlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJwYWlkXCIsXHJcbiAgcmVqZWN0aW9uUmVhc29uPzogc3RyaW5nXHJcbikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCflIQgVXBkYXRpbmcgZXhwZW5zZSBzdGF0dXM6XCIsIHsgZXhwZW5zZUlkLCBzdGF0dXMsIHJlamVjdGlvblJlYXNvbiB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIHN0YXR1cyBkYW4gcmVqZWN0aW9uX3JlYXNvbiBqaWthIGFkYVxyXG4gICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUYW1iYWhrYW4gcmVqZWN0aW9uX3JlYXNvbiBqaWthIHN0YXR1cyByZWplY3RlZFxyXG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiICYmIHJlamVjdGlvblJlYXNvbikge1xyXG4gICAgICB1cGRhdGVEYXRhLnJlamVjdGlvbl9yZWFzb24gPSByZWplY3Rpb25SZWFzb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYXIgcmVqZWN0aW9uX3JlYXNvbiBqaWthIHN0YXR1cyBhcHByb3ZlZC9wYWlkXHJcbiAgICBpZiAoc3RhdHVzID09PSBcImFwcHJvdmVkXCIgfHwgc3RhdHVzID09PSBcInBhaWRcIikge1xyXG4gICAgICB1cGRhdGVEYXRhLnJlamVjdGlvbl9yZWFzb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdleHBlbnNlcycpXHJcbiAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcclxuICAgICAgLmVxKCdpZCcsIGV4cGVuc2VJZClcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHVwZGF0aW5nIGV4cGVuc2Ugc3RhdHVzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBFeHBlbnNlIHN0YXR1cyB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RXhwZW5zZVN0YXRpc3RpY3NCeUJyYW5jaChicmFuY2hJZD86IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZXhwZW5zZXMnKVxyXG4gICAgICAuc2VsZWN0KCdzdGF0dXMsIGFtb3VudCcpO1xyXG5cclxuICAgIGlmIChicmFuY2hJZCAmJiBicmFuY2hJZCAhPT0gJ2FsbCcpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnYnJhbmNoX2lkJywgYnJhbmNoSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBleHBlbnNlIHN0YXRpc3RpY3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsOiAwLFxyXG4gICAgICAgIHBlbmRpbmc6IDAsXHJcbiAgICAgICAgYXBwcm92ZWQ6IDAsXHJcbiAgICAgICAgcmVqZWN0ZWQ6IDAsXHJcbiAgICAgICAgcGFpZDogMCxcclxuICAgICAgICB0b3RhbEFtb3VudDogMCxcclxuICAgICAgICBwZW5kaW5nQW1vdW50OiAwLFxyXG4gICAgICAgIGFwcHJvdmVkQW1vdW50OiAwLFxyXG4gICAgICAgIHJlamVjdGVkQW1vdW50OiAwLFxyXG4gICAgICAgIHBhaWRBbW91bnQ6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgdG90YWw6IGRhdGE/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICBwZW5kaW5nOiBkYXRhPy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKS5sZW5ndGggfHwgMCxcclxuICAgICAgYXBwcm92ZWQ6IGRhdGE/LmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAnYXBwcm92ZWQnKS5sZW5ndGggfHwgMCxcclxuICAgICAgcmVqZWN0ZWQ6IGRhdGE/LmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAncmVqZWN0ZWQnKS5sZW5ndGggfHwgMCxcclxuICAgICAgcGFpZDogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdwYWlkJykubGVuZ3RoIHx8IDAsXHJcbiAgICAgIHRvdGFsQW1vdW50OiBkYXRhPy5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgKGUuYW1vdW50IHx8IDApLCAwKSB8fCAwLFxyXG4gICAgICBwZW5kaW5nQW1vdW50OiBkYXRhPy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKS5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgKGUuYW1vdW50IHx8IDApLCAwKSB8fCAwLFxyXG4gICAgICBhcHByb3ZlZEFtb3VudDogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdhcHByb3ZlZCcpLnJlZHVjZSgoc3VtLCBlKSA9PiBzdW0gKyAoZS5hbW91bnQgfHwgMCksIDApIHx8IDAsXHJcbiAgICAgIHJlamVjdGVkQW1vdW50OiBkYXRhPy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykucmVkdWNlKChzdW0sIGUpID0+IHN1bSArIChlLmFtb3VudCB8fCAwKSwgMCkgfHwgMCxcclxuICAgICAgcGFpZEFtb3VudDogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdwYWlkJykucmVkdWNlKChzdW0sIGUpID0+IHN1bSArIChlLmFtb3VudCB8fCAwKSwgMCkgfHwgMFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gc3RhdHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0RXhwZW5zZVN0YXRpc3RpY3NCeUJyYW5jaDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbDogMCxcclxuICAgICAgcGVuZGluZzogMCxcclxuICAgICAgYXBwcm92ZWQ6IDAsXHJcbiAgICAgIHJlamVjdGVkOiAwLFxyXG4gICAgICBwYWlkOiAwLFxyXG4gICAgICB0b3RhbEFtb3VudDogMCxcclxuICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgYXBwcm92ZWRBbW91bnQ6IDAsXHJcbiAgICAgIHJlamVjdGVkQW1vdW50OiAwLFxyXG4gICAgICBwYWlkQW1vdW50OiAwXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEV4cGVuc2VzQnlTdGF0dXMoc3RhdHVzOiBzdHJpbmcsIGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdleHBlbnNlcycpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgYnJhbmNoZXM6YnJhbmNoX2lkICgqKSxcclxuICAgICAgICB1c2VyczpyZXF1ZXN0ZWRfYnkgKCopXHJcbiAgICAgIGApXHJcbiAgICAgIC5lcSgnc3RhdHVzJywgc3RhdHVzKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGJyYW5jaElkICYmIGJyYW5jaElkICE9PSAnYWxsJykge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdicmFuY2hfaWQnLCBicmFuY2hJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nICR7c3RhdHVzfSBleHBlbnNlczpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGRhdGE6IGRhdGEgfHwgW10sIGVycm9yOiBudWxsIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBBZGRpdGlvbmFsIEZ1bmN0aW9uc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFic2VudEVtcGxveWVlc1RvZGF5KCk6IFByb21pc2U8RW1wbG95ZWVbXT4ge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBnZXRBYnNlbnRFbXBsb3llZXNUb2RheSBjYWxsZWRcIilcclxuXHJcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdXHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2ZUVtcGxveWVlcywgZXJyb3I6IGVtcGxveWVlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5lcShcInN0YXR1c1wiLCBcImFjdGl2ZVwiKVxyXG4gICAgICAub3JkZXIoXCJuYW1lXCIpXHJcblxyXG4gICAgaWYgKGVtcGxveWVlc0Vycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIGZldGNoaW5nIGFjdGl2ZSBlbXBsb3llZXM6XCIsIGVtcGxveWVlc0Vycm9yKVxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHRvZGF5QXR0ZW5kYW5jZSwgZXJyb3I6IGF0dGVuZGFuY2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAgIC5zZWxlY3QoXCJ1c2VyX2lkXCIpXHJcbiAgICAgIC5lcShcImRhdGVcIiwgdG9kYXkpXHJcblxyXG4gICAgaWYgKGF0dGVuZGFuY2VFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBmZXRjaGluZyB0b2RheSdzIGF0dGVuZGFuY2U6XCIsIGF0dGVuZGFuY2VFcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJlc2VudEVtcGxveWVlSWRzID0gbmV3IFNldCh0b2RheUF0dGVuZGFuY2U/Lm1hcCgoYSkgPT4gYS51c2VyX2lkKSB8fCBbXSlcclxuICAgIGNvbnN0IGFic2VudEVtcGxveWVlcyA9IGFjdGl2ZUVtcGxveWVlcz8uZmlsdGVyKChlbXBsb3llZSkgPT4gIXByZXNlbnRFbXBsb3llZUlkcy5oYXMoZW1wbG95ZWUuaWQpKSB8fCBbXVxyXG5cclxuICAgIGNvbnN0IHRyYW5zZm9ybWVkQWJzZW50RW1wbG95ZWVzOiBFbXBsb3llZVtdID0gYWJzZW50RW1wbG95ZWVzLm1hcCgodXNlcjogYW55KSA9PiAoe1xyXG4gICAgICBpZDogdXNlci5pZCxcclxuICAgICAgbmFtZTogdXNlci5uYW1lLFxyXG4gICAgICBlbWFpbDogdXNlci5lbWFpbCB8fCBcIlwiLFxyXG4gICAgICBwaG9uZTogdXNlci5waG9uZSB8fCBcIlwiLFxyXG4gICAgICBwb3NpdGlvbjogdXNlci5wb3NpdGlvbiB8fCBcImVtcGxveWVlXCIsXHJcbiAgICAgIHN0YXR1czogdXNlci5zdGF0dXMgfHwgXCJhY3RpdmVcIixcclxuICAgICAgYXZhdGFyOiBgL3BsYWNlaG9sZGVyLnN2Zz9oZWlnaHQ9NDAmd2lkdGg9NDAmcXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQodXNlci5uYW1lKX1gLFxyXG4gICAgICByYXRpbmc6IDQuNSxcclxuICAgICAgYmFzZVNhbGFyeTogNTAwMDAwMCxcclxuICAgICAgYXR0ZW5kYW5jZVJhdGU6IDk1LFxyXG4gICAgICBjdXJyZW50TW9udGhDdXN0b21lcnM6IDAsXHJcbiAgICAgIHRvdGFsQ3VzdG9tZXJzOiAwLFxyXG4gICAgICBwcmVzZW50RGF5czogMCxcclxuICAgICAgdG90YWxXb3JrRGF5czogMCxcclxuICAgICAgbGF0ZURheXM6IDAsXHJcbiAgICAgIG92ZXJ0aW1lSG91cnM6IDAsXHJcbiAgICAgIG92ZXJ0aW1lUmF0ZTogMjUwMDAsXHJcbiAgICAgIGJvbnVzUG9pbnRzOiAwLFxyXG4gICAgICBwZW5hbHR5UG9pbnRzOiAwLFxyXG4gICAgICBjb21taXNzaW9uUmF0ZTogMC4wNSxcclxuICAgICAgam9pbkRhdGU6IHVzZXIuY3JlYXRlZF9hdCxcclxuICAgICAga2FzYm9uQmFsYW5jZTogMCxcclxuICAgICAga2FzYm9uTGltaXQ6IDIwMDAwMDAsXHJcbiAgICAgIG1vbnRobHlSZXZlbnVlOiBcIjBcIixcclxuICAgICAgcGluOiB1c2VyLnBpbiB8fCBcIlwiLFxyXG4gICAgfSkpXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEZvdW5kIGFic2VudCBlbXBsb3llZXM6XCIsIHRyYW5zZm9ybWVkQWJzZW50RW1wbG95ZWVzLmxlbmd0aClcclxuICAgIHJldHVybiB0cmFuc2Zvcm1lZEFic2VudEVtcGxveWVlc1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBpbiBnZXRBYnNlbnRFbXBsb3llZXNUb2RheTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEF0dGVuZGFuY2UgTWFuYWdlbWVudCBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERldGFpbGVkQXR0ZW5kYW5jZVJlY29yZHMoZGF0ZT86IHN0cmluZykge1xyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImF0dGVuZGFuY2VcIilcclxuICAgIC5zZWxlY3QoYCosXHJcbiAgICAgIHVzZXJzOnVzZXJfaWQgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgYnJhbmNoX2lkXHJcbiAgICAgICksXHJcbiAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBhZGRyZXNzLFxyXG4gICAgICAgIHNoaWZ0c1xyXG4gICAgICApXHJcbiAgICBgKVxyXG4gICAgLm9yZGVyKFwiZGF0ZVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gIGlmIChkYXRlKSB7XHJcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKFwiZGF0ZVwiLCBkYXRlKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBmZXRjaGluZyBkZXRhaWxlZCBhdHRlbmRhbmNlOlwiLCBlcnJvcilcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIE9VVExFVCBTVE9DSyBNQU5BR0VNRU5UXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE91dGxldFN0b2NrIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG91dGxldF9pZDogc3RyaW5nO1xyXG4gIHNlcnZpY2VfaWQ6IHN0cmluZztcclxuICBzdG9ja19xdWFudGl0eTogbnVtYmVyO1xyXG4gIG1pbl9zdG9ja190aHJlc2hvbGQ6IG51bWJlcjtcclxuICBpc19hY3RpdmU6IGJvb2xlYW47XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxuICBzZXJ2aWNlPzogU2VydmljZVdpdGhDYXRlZ29yeTtcclxuICBicmFuY2g/OiBCcmFuY2g7XHJcbn1cclxuXHJcbi8vIPCflKUgR0VUIHN0b2NrIHBlciBvdXRsZXRcclxuZXhwb3J0IGNvbnN0IGdldE91dGxldFN0b2NrID0gYXN5bmMgKG91dGxldElkOiBzdHJpbmcpOiBQcm9taXNlPHsgZGF0YTogT3V0bGV0U3RvY2tbXSB8IG51bGw7IGVycm9yOiBhbnkgfT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnb3V0bGV0X3N0b2NrJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5lcSgnb3V0bGV0X2lkJywgb3V0bGV0SWQpXHJcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgb3V0bGV0IHN0b2NrOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGdldE91dGxldFN0b2NrOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8g8J+UpSBVUERBVEUgc3RvY2sgcGVyIG91dGxldCAod2l0aCBVUFNFUlQpXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVPdXRsZXRTdG9jayA9IGFzeW5jIChcclxuICBvdXRsZXRJZDogc3RyaW5nLCBcclxuICBzZXJ2aWNlSWQ6IHN0cmluZywgXHJcbiAgbmV3U3RvY2s6IG51bWJlclxyXG4pOiBQcm9taXNlPHsgZGF0YTogT3V0bGV0U3RvY2sgfCBudWxsOyBlcnJvcjogYW55IH0+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gVXNlIHVwc2VydCB0byBjcmVhdGUgaWYgbm90IGV4aXN0cywgdXBkYXRlIGlmIGV4aXN0c1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ291dGxldF9zdG9jaycpXHJcbiAgICAgIC51cHNlcnQoeyBcclxuICAgICAgICBvdXRsZXRfaWQ6IG91dGxldElkLFxyXG4gICAgICAgIHNlcnZpY2VfaWQ6IHNlcnZpY2VJZCxcclxuICAgICAgICBzdG9ja19xdWFudGl0eTogbmV3U3RvY2ssXHJcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIG1pbl9zdG9ja190aHJlc2hvbGQ6IDUsIC8vIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSwge1xyXG4gICAgICAgIG9uQ29uZmxpY3Q6ICdvdXRsZXRfaWQsc2VydmljZV9pZCdcclxuICAgICAgfSlcclxuICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgb3V0bGV0IHN0b2NrOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIHVwZGF0ZU91dGxldFN0b2NrOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8g8J+UpSBHRVQgbG93IHN0b2NrIGFsZXJ0cyAoRklYRUQgVkVSU0lPTilcclxuZXhwb3J0IGNvbnN0IGdldExvd1N0b2NrQWxlcnRzID0gYXN5bmMgKCk6IFByb21pc2U8eyBkYXRhOiBPdXRsZXRTdG9ja1tdIHwgbnVsbDsgZXJyb3I6IGFueSB9PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCBhbGwgb3V0bGV0IHN0b2NrIChubyBqb2lucyBuZWVkZWQpXHJcbiAgICBjb25zdCB7IGRhdGE6IGFsbFN0b2NrLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ291dGxldF9zdG9jaycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpO1xyXG5cclxuICAgIGlmIChmZXRjaEVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG91dGxldCBzdG9jazonLCBmZXRjaEVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGZldGNoRXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXIgbWFudWFsbHkgZm9yIGxvdyBzdG9ja1xyXG4gICAgY29uc3QgbG93U3RvY2sgPSAoYWxsU3RvY2sgfHwgW10pLmZpbHRlcihpdGVtID0+IFxyXG4gICAgICBpdGVtLnN0b2NrX3F1YW50aXR5IDw9IGl0ZW0ubWluX3N0b2NrX3RocmVzaG9sZFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4geyBkYXRhOiBsb3dTdG9jaywgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBnZXRMb3dTdG9ja0FsZXJ0czonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIPCflKUgUkVEVUNFIHN0b2NrIGtldGlrYSB0ZXJqYWRpIHRyYW5zYWtzaVxyXG4vLyDwn5SlIFJFRFVDRSBzdG9jayBrZXRpa2EgdGVyamFkaSB0cmFuc2Frc2kgKEZJWEVEKVxyXG5leHBvcnQgY29uc3QgcmVkdWNlT3V0bGV0U3RvY2sgPSBhc3luYyAoXHJcbiAgb3V0bGV0SWQ6IHN0cmluZyxcclxuICBzZXJ2aWNlSWQ6IHN0cmluZyxcclxuICBxdWFudGl0eTogbnVtYmVyXHJcbik6IFByb21pc2U8eyBkYXRhOiBPdXRsZXRTdG9jayB8IG51bGw7IGVycm9yOiBhbnkgfT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBHZXQgY3VycmVudCBzdG9ja1xyXG4gICAgY29uc3QgeyBkYXRhOiBjdXJyZW50U3RvY2ssIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnb3V0bGV0X3N0b2NrJylcclxuICAgICAgLnNlbGVjdCgnc3RvY2tfcXVhbnRpdHknKVxyXG4gICAgICAuZXEoJ291dGxldF9pZCcsIG91dGxldElkKVxyXG4gICAgICAuZXEoJ3NlcnZpY2VfaWQnLCBzZXJ2aWNlSWQpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZmV0Y2hFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjdXJyZW50IHN0b2NrOicsIGZldGNoRXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZmV0Y2hFcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld1N0b2NrID0gTWF0aC5tYXgoMCwgKGN1cnJlbnRTdG9jaz8uc3RvY2tfcXVhbnRpdHkgfHwgMCkgLSBxdWFudGl0eSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHN0b2NrXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnb3V0bGV0X3N0b2NrJylcclxuICAgICAgLnVwZGF0ZSh7IFxyXG4gICAgICAgIHN0b2NrX3F1YW50aXR5OiBuZXdTdG9jayxcclxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSlcclxuICAgICAgLmVxKCdvdXRsZXRfaWQnLCBvdXRsZXRJZClcclxuICAgICAgLmVxKCdzZXJ2aWNlX2lkJywgc2VydmljZUlkKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIHNlcnZpY2U6c2VydmljZXMoKiwgc2VydmljZV9jYXRlZ29yaWVzKCopKSxcclxuICAgICAgICBicmFuY2g6b3V0bGV0X2lkKCopXHJcbiAgICAgIGApXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVkdWNpbmcgb3V0bGV0IHN0b2NrOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIHJlZHVjZU91dGxldFN0b2NrOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUE9TIEhlbHBlciBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQnJhbmNoZXNEYXRhID0gYXN5bmMgKHN1cGFiYXNlOiBhbnksIHNldEJyYW5jaGVzOiBhbnksIHNldFNlbGVjdGVkQnJhbmNoOiBhbnkpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYnJhbmNoZXNcIikuc2VsZWN0KFwiKlwiKVxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgYnJhbmNoZXM6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHNldEJyYW5jaGVzKGRhdGEpXHJcbiAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgc2V0U2VsZWN0ZWRCcmFuY2goZGF0YVswXS5uYW1lKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRCcmFuY2hEYXRhID0gYXN5bmMgKHN1cGFiYXNlOiBhbnksIHNldFJlY2VpcHRUZW1wbGF0ZTogYW55LCBzZXRCcmFuY2hJbmZvOiBhbnkpID0+IHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gTG9hZGluZyBicmFuY2ggYW5kIHRlbXBsYXRlIGRhdGEuLi5cIilcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhOiB0ZW1wbGF0ZURhdGEsIGVycm9yOiB0ZW1wbGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInJlY2VpcHRfdGVtcGxhdGVzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5lcShcImlzX2FjdGl2ZVwiLCB0cnVlKVxyXG4gICAgICAuc2luZ2xlKClcclxuXHJcbiAgICBpZiAodGVtcGxhdGVFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyByZWNlaXB0IHRlbXBsYXRlOlwiLCB0ZW1wbGF0ZUVycm9yKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIExvYWRlZCBhY3RpdmUgdGVtcGxhdGU6XCIsIHRlbXBsYXRlRGF0YSlcclxuICAgICAgc2V0UmVjZWlwdFRlbXBsYXRlKHRlbXBsYXRlRGF0YSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gQnJhbmNoIGRhdGEgbG9hZGluZyBjb21wbGV0ZWQgd2l0aG91dCBvdmVycmlkaW5nIHNlbGVjdGVkQnJhbmNoXCIpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGJyYW5jaCBhbmQgdGVtcGxhdGUgZGF0YTpcIiwgZXJyb3IpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcHJvY2Vzc1RyYW5zYWN0aW9uID0gYXN5bmMgKFxyXG4gIHN1cGFiYXNlOiBhbnksXHJcbiAgYnJhbmNoZXM6IGFueVtdLFxyXG4gIHNlbGVjdGVkQnJhbmNoOiBzdHJpbmcsXHJcbiAgY2FydDogYW55W10sXHJcbiAgY3VycmVudFVzZXI6IGFueSxcclxuICBwYXltZW50TWV0aG9kOiBzdHJpbmcsXHJcbiAgY3VzdG9tZXJOYW1lOiBzdHJpbmcsXHJcbiAgZGlzY291bnRSZWFzb246IHN0cmluZyxcclxuICBnZXRUb3RhbFByaWNlOiAoKSA9PiBudW1iZXIsXHJcbiAgZ2V0RGlzY291bnRBbW91bnQ6ICgpID0+IG51bWJlcixcclxuICBnZXRGaW5hbFRvdGFsOiAoKSA9PiBudW1iZXIsXHJcbikgPT4ge1xyXG4gIGNvbnN0IHNlbGVjdGVkQnJhbmNoRGF0YSA9IGJyYW5jaGVzLmZpbmQoKGIpID0+IGIubmFtZSA9PT0gc2VsZWN0ZWRCcmFuY2gpXHJcblxyXG4gIGlmICghc2VsZWN0ZWRCcmFuY2hEYXRhPy5pZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBjYWJhbmcgdGlkYWsgZGl0ZW11a2FuXCIpXHJcbiAgfVxyXG5cclxuICBjb25zdCByZWNlaXB0TnVtYmVyID0gYCR7bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpfSR7U3RyaW5nKG5ldyBEYXRlKCkuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke1N0cmluZyhuZXcgRGF0ZSgpLmdldERhdGUoKSkucGFkU3RhcnQoMiwgXCIwXCIpfSR7U3RyaW5nKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApKS5wYWRTdGFydCgzLCBcIjBcIil9YFxyXG5cclxuICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XHJcbiAgICByZWNlaXB0X251bWJlcjogcmVjZWlwdE51bWJlcixcclxuICAgIGJyYW5jaF9pZDogc2VsZWN0ZWRCcmFuY2hEYXRhLmlkLFxyXG4gICAgdG90YWxfYW1vdW50OiBnZXRUb3RhbFByaWNlKCksXHJcbiAgICBkaXNjb3VudF9hbW91bnQ6IGdldERpc2NvdW50QW1vdW50KCksXHJcbiAgICBmaW5hbF9hbW91bnQ6IGdldEZpbmFsVG90YWwoKSxcclxuICAgIHBheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kLFxyXG4gICAgY3VzdG9tZXJfbmFtZTogY3VzdG9tZXJOYW1lIHx8IG51bGwsXHJcbiAgICBub3RlczogZGlzY291bnRSZWFzb24gfHwgbnVsbCxcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBDcmVhdGluZyB0cmFuc2FjdGlvbiB3aXRoIGNvcnJlY3QgYnJhbmNoX2lkOlwiLCB0cmFuc2FjdGlvbkRhdGEpXHJcbiAgcmV0dXJuIHRyYW5zYWN0aW9uRGF0YVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBTZXR1cCBSZWFsdGltZSBTdWJzY3JpcHRpb24gdW50dWsgVHJhbnNha3NpXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBjb25zdCBzZXR1cFRyYW5zYWN0aW9uc1JlYWx0aW1lID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB7XHJcbiAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlXHJcbiAgICAuY2hhbm5lbCgndHJhbnNhY3Rpb25zLWdsb2JhbCcpXHJcbiAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCBcclxuICAgICAgeyBcclxuICAgICAgICBldmVudDogJyonLCBcclxuICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLCBcclxuICAgICAgICB0YWJsZTogJ3RyYW5zYWN0aW9ucycgXHJcbiAgICAgIH0sIFxyXG4gICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBjaGFuZ2UgZGV0ZWN0ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJyxcclxuICAgICAge1xyXG4gICAgICAgIGV2ZW50OiAnKicsXHJcbiAgICAgICAgc2NoZW1hOiAncHVibGljJyxcclxuICAgICAgICB0YWJsZTogJ3RyYW5zYWN0aW9uX2l0ZW1zJ1xyXG4gICAgICB9LFxyXG4gICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBpdGVtIGNoYW5nZSBkZXRlY3RlZDonLCBwYXlsb2FkKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAuc3Vic2NyaWJlKChzdGF0dXMpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ1JlYWx0aW1lIHN1YnNjcmlwdGlvbiBzdGF0dXM6Jywgc3RhdHVzKTtcclxuICAgIH0pO1xyXG5cclxuICByZXR1cm4gY2hhbm5lbDtcclxufTtcclxuXHJcbi8vIPCflKUgRlVOR1NJIEJBUlU6IFNldHVwIFJlYWx0aW1lIHVudHVrIEtvbWlzaVxyXG5leHBvcnQgY29uc3Qgc2V0dXBLb21pc2lSZWFsdGltZSA9IChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4ge1xyXG4gIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxyXG4gICAgLmNoYW5uZWwoJ2tvbWlzaS1nbG9iYWwnKVxyXG4gICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJyxcclxuICAgICAge1xyXG4gICAgICAgIGV2ZW50OiAnKicsXHJcbiAgICAgICAgc2NoZW1hOiAncHVibGljJyxcclxuICAgICAgICB0YWJsZTogJ2NvbW1pc3Npb25fcnVsZXMnXHJcbiAgICAgIH0sXHJcbiAgICAgIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbW1pc3Npb24gcnVsZSBjaGFuZ2UgZGV0ZWN0ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdLb21pc2kgc3Vic2NyaXB0aW9uIHN0YXR1czonLCBzdGF0dXMpO1xyXG4gICAgfSk7XHJcblxyXG4gIHJldHVybiBjaGFubmVsO1xyXG59O1xyXG5cclxuLy8g8J+UpSBGVU5HU0kgQkFSVTogQnJvYWRjYXN0IEV2ZW50IHVudHVrIFNpbmtyb25pc2FzaSBHbG9iYWxcclxuZXhwb3J0IGNvbnN0IGJyb2FkY2FzdFRyYW5zYWN0aW9uRXZlbnQgPSBhc3luYyAoZXZlbnRUeXBlOiBzdHJpbmcsIHBheWxvYWQ6IGFueSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBzdXBhYmFzZS5jaGFubmVsKCdnbG9iYWwtZXZlbnRzJykuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICdicm9hZGNhc3QnLFxyXG4gICAgICBldmVudDogZXZlbnRUeXBlLFxyXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKGBCcm9hZGNhc3QgZXZlbnQgJyR7ZXZlbnRUeXBlfScgc2VudCBzdWNjZXNzZnVsbHlgKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYnJvYWRjYXN0aW5nIGV2ZW50OicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBMaXN0ZW4gdW50dWsgR2xvYmFsIEV2ZW50c1xyXG5leHBvcnQgY29uc3Qgc2V0dXBHbG9iYWxFdmVudHNMaXN0ZW5lciA9IChjYWxsYmFjazogKGV2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSkgPT4gdm9pZCkgPT4ge1xyXG4gIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZS5jaGFubmVsKCdnbG9iYWwtZXZlbnRzLWxpc3RlbmVyJylcclxuICAgIC5vbignYnJvYWRjYXN0JywgeyBldmVudDogJyonIH0sIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdHbG9iYWwgZXZlbnQgcmVjZWl2ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgIGNhbGxiYWNrKHBheWxvYWQuZXZlbnQsIHBheWxvYWQucGF5bG9hZCk7XHJcbiAgICB9KVxyXG4gICAgLnN1YnNjcmliZSgpO1xyXG5cclxuICByZXR1cm4gY2hhbm5lbDtcclxufTtcclxuXHJcbi8vIPCflKUgRlVOR1NJIEJBUlU6IFN1YnNjcmliZSB0byBFdmVudHNcclxuZXhwb3J0IGNvbnN0IHN1YnNjcmliZVRvRXZlbnRzID0gKGNhbGxiYWNrOiAoZXZlbnQ6IHN0cmluZywgcGF5bG9hZDogYW55KSA9PiB2b2lkKSA9PiB7XHJcbiAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlLmNoYW5uZWwoJ2dsb2JhbC1ldmVudHMtbGlzdGVuZXInKVxyXG4gICAgLm9uKCdicm9hZGNhc3QnLCB7IGV2ZW50OiAnKicgfSwgKHBheWxvYWQpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0dsb2JhbCBldmVudCByZWNlaXZlZDonLCBwYXlsb2FkKTtcclxuICAgICAgY2FsbGJhY2socGF5bG9hZC5ldmVudCwgcGF5bG9hZC5wYXlsb2FkKTtcclxuICAgIH0pXHJcbiAgICAuc3Vic2NyaWJlKCk7XHJcblxyXG4gIHJldHVybiBjaGFubmVsO1xyXG59O1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8g8J+UpSBGVU5HU0kgQkFSVTogU2V0dXAgUmVhbHRpbWUgU3Vic2NyaXB0aW9uIHVudHVrIEVtcGxveWVlXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBjb25zdCBzZXR1cEVtcGxveWVlUmVhbHRpbWUgPSAoY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHtcclxuICBjb25zb2xlLmxvZyhcIlNldHRpbmcgdXAgZW1wbG95ZWUgcmVhbHRpbWUgc3Vic2NyaXB0aW9uXCIpO1xyXG5cclxuICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2VcclxuICAgIC5jaGFubmVsKCdlbXBsb3llZXMtZ2xvYmFsJylcclxuICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIFxyXG4gICAgICB7IFxyXG4gICAgICAgIGV2ZW50OiAnKicsIFxyXG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYycsIFxyXG4gICAgICAgIHRhYmxlOiAndXNlcnMnIFxyXG4gICAgICB9LCBcclxuICAgICAgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnRW1wbG95ZWUgY2hhbmdlIGRldGVjdGVkOicsIHBheWxvYWQpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsXHJcbiAgICAgIHtcclxuICAgICAgICBldmVudDogJyonLFxyXG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXHJcbiAgICAgICAgdGFibGU6ICdwb2ludHMnXHJcbiAgICAgIH0sXHJcbiAgICAgIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1BvaW50cyBjaGFuZ2UgZGV0ZWN0ZWQgKGFmZmVjdHMgZW1wbG95ZWUgc3RhdHMpOicsIHBheWxvYWQpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsXHJcbiAgICAgIHtcclxuICAgICAgICBldmVudDogJyonLFxyXG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXHJcbiAgICAgICAgdGFibGU6ICdhdHRlbmRhbmNlJ1xyXG4gICAgICB9LFxyXG4gICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbmRhbmNlIGNoYW5nZSBkZXRlY3RlZDonLCBwYXlsb2FkKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAuc3Vic2NyaWJlKChzdGF0dXMpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0VtcGxveWVlIHJlYWx0aW1lIHN1YnNjcmlwdGlvbiBzdGF0dXM6Jywgc3RhdHVzKTtcclxuICAgIH0pO1xyXG5cclxuICByZXR1cm4gY2hhbm5lbDtcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcHByb3ZlZEV4cGVuc2VzKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCflI0gRmV0Y2hpbmcgYXBwcm92ZWQgZXhwZW5zZXMuLi5cIik7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdleHBlbnNlcycpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgYnJhbmNoZXM6YnJhbmNoX2lkICgqKVxyXG4gICAgICBgKVxyXG4gICAgICAuaW4oJ3N0YXR1cycsIFsnYXBwcm92ZWQnLCAncGFpZCddKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBhcHByb3ZlZCBleHBlbnNlczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi4pyFIFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGFwcHJvdmVkIGV4cGVuc2VzOlwiLCBkYXRhPy5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yIH07XHJcbiAgfVxyXG59XHJcbi8vIPCflKUgVEFNQkFIS0FOIGZ1bmdzaSBpbmkgZGkgc3VwYWJhc2UudHNcclxuZXhwb3J0IGNvbnN0IGdldE93bmVyUGluID0gYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgIC5zZWxlY3QoJ3BpbicpXHJcbiAgICAgIC5lcSgncG9zaXRpb24nLCAnb3duZXInKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG93bmVyIFBJTjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiAnJzsgLy8gUmV0dXJuIGVtcHR5IHN0cmluZyBpZiBub3QgZm91bmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YS5waW4gfHwgJyc7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0T3duZXJQaW46JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufTtcclxuLy8g8J+UpSBUQU1CQUhLQU4gZnVuZ3NpIGluaSBkaSBzdXBhYmFzZS50c1xyXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclBpbiA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgbmV3UGluOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gVmFsaWRhc2kgUElOIDYgZGlnaXRcclxuICAgIGlmIChuZXdQaW4ubGVuZ3RoICE9PSA2IHx8ICEvXlxcZCskLy50ZXN0KG5ld1BpbikpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBQSU4gZm9ybWF0Jyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndXNlcnMnKVxyXG4gICAgICAudXBkYXRlKHsgcGluOiBuZXdQaW4gfSlcclxuICAgICAgLmVxKCdpZCcsIHVzZXJJZCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIFBJTjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiB1cGRhdGVVc2VyUGluOicsIGVycm9yKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07Il0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiRXJyb3IiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJyZWFsdGltZSIsInBhcmFtcyIsImV2ZW50c1BlclNlY29uZCIsImdsb2JhbCIsImhlYWRlcnMiLCJ0ZXN0U3VwYWJhc2VDb25uZWN0aW9uIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImNvbnNvbGUiLCJsb2ciLCJnZXRCdXNpbmVzc0RheXNDb3VudCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJjb3VudCIsImN1ckRhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImRheU9mV2VlayIsImdldERheSIsInNldERhdGUiLCJnZXREYXRlIiwiZ2V0QnJhbmNoU2hpZnRzIiwiYnJhbmNoSWQiLCJlcSIsIm9yZGVyIiwibGVuZ3RoIiwiaWQiLCJicmFuY2hfaWQiLCJzaGlmdF9uYW1lIiwic2hpZnRfdHlwZSIsInN0YXJ0X3RpbWUiLCJlbmRfdGltZSIsImlzX2FjdGl2ZSIsImNyZWF0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsImNyZWF0ZUJyYW5jaFNoaWZ0Iiwic2hpZnREYXRhIiwic2hpZnRUb0luc2VydCIsImluc2VydCIsInNpbmdsZSIsInVwbG9hZFBob3RvVG9TdXBhYmFzZSIsImJhc2U2NCIsImZpbGVuYW1lIiwiYmFzZTY0VG9CbG9iIiwiYmFzZTY0RGF0YSIsImNvbnRlbnRUeXBlIiwiYnl0ZUNoYXJhY3RlcnMiLCJhdG9iIiwic3BsaXQiLCJieXRlQXJyYXlzIiwib2Zmc2V0Iiwic2xpY2UiLCJieXRlTnVtYmVycyIsIkFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJwdXNoIiwiVWludDhBcnJheSIsIkJsb2IiLCJ0eXBlIiwiYmxvYiIsInN0b3JhZ2UiLCJ1cGxvYWQiLCJjYWNoZUNvbnRyb2wiLCJ1cHNlcnQiLCJwdWJsaWNVcmxEYXRhIiwiZ2V0UHVibGljVXJsIiwicHVibGljVXJsIiwiY3JlYXRlQXR0ZW5kYW5jZVJlY29yZCIsImF0dGVuZGFuY2VEYXRhIiwidXBkYXRlQXR0ZW5kYW5jZVJlY29yZCIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJ1cGRhdGVkX2F0IiwiZ2V0QXR0ZW5kYW5jZUJ5RGF0ZSIsInVzZXJJZCIsImRhdGUiLCJjb2RlIiwiZ2V0QWxsQXR0ZW5kYW5jZVJlY29yZHMiLCJxdWVyeSIsImFzY2VuZGluZyIsImdldFNlcnZpY2VzV2l0aENhdGVnb3JpZXMiLCJnZXRTZXJ2aWNlQ2F0ZWdvcmllcyIsImNyZWF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25OdW1iZXIiLCJnZW5lcmF0ZVRyYW5zYWN0aW9uTnVtYmVyIiwiY2FzaGllcl9pZCIsInNlcnZlcl9pZCIsImNhc2hpZXJOYW1lIiwiYnJhbmNoTmFtZSIsInNlcnZlck5hbWUiLCJ1c2VycyIsImxpbWl0IiwibmFtZSIsImNhc2hpZXIiLCJicmFuY2hlcyIsImJyYW5jaCIsInNlcnZlciIsInRyYW5zYWN0aW9uVG9JbnNlcnQiLCJ0cmFuc2FjdGlvbl9udW1iZXIiLCJyZWNlaXB0X251bWJlciIsImNhc2hpZXJfbmFtZSIsImJyYW5jaF9uYW1lIiwic2VydmVyX25hbWUiLCJzdWJ0b3RhbCIsInRvdGFsX2Ftb3VudCIsInBheW1lbnRfc3RhdHVzIiwicGF5bWVudF9tZXRob2QiLCJkaXNjb3VudF9hbW91bnQiLCJjcmVhdGVUcmFuc2FjdGlvbkl0ZW1zIiwiaXRlbXMiLCJlbnJpY2hlZEl0ZW1zIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsIml0ZW0iLCJzZXJ2aWNlX2lkIiwic2VydmljZSIsInNlcnZpY2VfbmFtZSIsInNlcnZpY2VfdHlwZSIsInNlcnZpY2VfY2F0ZWdvcnkiLCJzZXJ2aWNlX2NhdGVnb3JpZXMiLCJnZXRSZWNlaXB0VGVtcGxhdGUiLCJnZXRBY3RpdmVSZWNlaXB0VGVtcGxhdGUiLCJhY3RpdmVEYXRhIiwiYWN0aXZlRXJyb3IiLCJkZWZhdWx0UXVlcnkiLCJkZWZhdWx0RGF0YSIsImRlZmF1bHRFcnJvciIsImdldEJyYW5jaGVzIiwicnBjIiwidG9kYXkiLCJkYXRlU3RyIiwicmVwbGFjZSIsInRyYW5zYWN0aW9ucyIsImd0ZSIsImx0IiwiY291bnRlciIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJub3ciLCJjaGVja1NlcnZpY2VTdG9jayIsInNlcnZpY2VJZCIsInN0b2NrIiwicmVkdWNlU2VydmljZVN0b2NrIiwicXVhbnRpdHkiLCJjdXJyZW50U2VydmljZSIsImZldGNoRXJyb3IiLCJjdXJyZW50U3RvY2siLCJuZXdTdG9jayIsIk1hdGgiLCJtYXgiLCJ1cGRhdGVTZXJ2aWNlU3RvY2siLCJnZXRVc2Vyc1dpdGhQb2ludHMiLCJ1c2Vyc1F1ZXJ5IiwidXNlcnNFcnJvciIsImFsbFBvaW50cyIsInBvaW50c0Vycm9yIiwidXNlcnNXaXRoQ2FsY3VsYXRlZFBvaW50cyIsInVzZXIiLCJ1c2VyUG9pbnRzIiwiZmlsdGVyIiwicG9pbnQiLCJ1c2VyX2lkIiwidG90YWxQb2ludHMiLCJyZWR1Y2UiLCJzdW0iLCJwb2ludHNfZWFybmVkIiwiY3VycmVudE1vbnRoIiwiZ2V0TW9udGgiLCJjdXJyZW50WWVhciIsImdldEZ1bGxZZWFyIiwibW9udGhseVBvaW50cyIsInBvaW50RGF0ZSIsInRvdGFsX3BvaW50cyIsIm1vbnRobHlfcG9pbnRzIiwic29ydGVkVXNlcnMiLCJzb3J0IiwiYSIsImIiLCJpbmRleCIsInJhbmsiLCJnZXRQb2ludHNTdGF0aXN0aWNzIiwidG90YWxFbXBsb3llZXMiLCJ0b3BQZXJmb3JtZXIiLCJhdmVyYWdlUG9pbnRzIiwicm91bmQiLCJnZXRQb2ludFRyYW5zYWN0aW9ucyIsInVzZXJzSW5CcmFuY2giLCJ1c2VySWRzIiwidSIsImluIiwicG9pbnRzRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIiwiU2V0IiwicCIsIkJvb2xlYW4iLCJ1c2Vyc01hcCIsImFjYyIsImJyYW5jaElkcyIsIk9iamVjdCIsInZhbHVlcyIsImJyYW5jaGVzTWFwIiwiZW5yaWNoZWREYXRhIiwiYWRkUG9pbnRUcmFuc2FjdGlvbiIsInBvaW50RGF0YSIsImdldFVzZXJQb2ludHMiLCJnZXRLYXNib25SZXF1ZXN0cyIsInN0YXR1c0ZpbHRlciIsImthc2JvbkRhdGEiLCJrIiwiYXBwcm92ZXJJZHMiLCJhcHByb3ZlZF9ieSIsImFwcHJvdmVyc01hcCIsImFwcHJvdmVycyIsImthc2JvbiIsImFwcHJvdmVyIiwiZ2V0S2FzYm9uU3RhdGlzdGljcyIsInBlbmRpbmdBbW91bnQiLCJhcHByb3ZlZEFtb3VudCIsInRvdGFsUGFpZCIsImFjdGl2ZUVtcGxveWVlcyIsInN0YXR1cyIsImFtb3VudCIsInVzZXJzRGF0YSIsInN0YXRpc3RpY3MiLCJnZXRVc2Vyc1dpdGhLYXNib24iLCJhbGxLYXNib24iLCJrYXNib25FcnJvciIsInVzZXJzV2l0aG91dEthc2JvbiIsInRvdGFsX2thc2JvbiIsImFjdGl2ZV9rYXNib24iLCJrYXNib25faGlzdG9yeSIsInVzZXJzV2l0aEthc2JvbkRhdGEiLCJ1c2VyS2FzYm9uIiwidG90YWxLYXNib24iLCJhY3RpdmVLYXNib24iLCJjcmVhdGVLYXNib25SZXF1ZXN0IiwidXNlckVycm9yIiwia2FzYm9uVG9JbnNlcnQiLCJ1c2VyX25hbWUiLCJyZXF1ZXN0X2RhdGUiLCJ1cGRhdGVLYXNib25TdGF0dXMiLCJrYXNib25JZCIsImFwcHJvdmVkQnkiLCJ1cGRhdGVEYXRhIiwiYXBwcm92ZWRfYXQiLCJnZXRFbXBsb3llZUFic2VuY2VJbmZvIiwiZW1wbG95ZWVJZCIsImVtcGxveWVlIiwiZW1wRXJyb3IiLCJtYXhBYnNlbnREYXlzIiwiY3VycmVudEFic2VudERheXMiLCJyZW1haW5pbmdEYXlzIiwiZXhjZXNzRGF5cyIsImN1cnJlbnREYXRlIiwiZmlyc3REYXlPZk1vbnRoIiwibGFzdERheU9mTW9udGgiLCJhdHRlbmRhbmNlRXJyb3IiLCJsdGUiLCJtYXhfYWJzZW50X2RheXMiLCJyZWNvcmQiLCJ1cGRhdGVNYXhBYnNlbnREYXlzIiwibWF4RGF5cyIsImdldEVtcGxveWVlcyIsInVzZXJzQ291bnQiLCJoYXNFcnJvciIsImZpcnN0VXNlciIsImVtcGxveWVlcyIsImVtYWlsIiwicGhvbmUiLCJwb3NpdGlvbiIsInNhbGFyeSIsImJhc2VTYWxhcnkiLCJjb21taXNzaW9uUmF0ZSIsImNvbW1pc3Npb25fcmF0ZSIsInBpbiIsInRvdGFsQm9udXMiLCJ0b3RhbFBlbmFsdHkiLCJyYXRpbmciLCJhdHRlbmRhbmNlUmF0ZSIsImN1cnJlbnRNb250aEN1c3RvbWVycyIsInRvdGFsQ3VzdG9tZXJzIiwicHJlc2VudERheXMiLCJ0b3RhbFdvcmtEYXlzIiwibGF0ZURheXMiLCJvdmVydGltZUhvdXJzIiwib3ZlcnRpbWVSYXRlIiwiYm9udXNQb2ludHMiLCJwZW5hbHR5UG9pbnRzIiwia2FzYm9uQmFsYW5jZSIsImthc2JvbkxpbWl0IiwibW9udGhseVJldmVudWUiLCJTdHJpbmciLCJhZGRFbXBsb3llZSIsInVzZXJEYXRhIiwidXBkYXRlRW1wbG95ZWUiLCJkZWxldGVFbXBsb3llZSIsImV4aXN0aW5nVXNlciIsImNoZWNrRXJyb3IiLCJlIiwiZ2V0RW1wbG95ZWVTdGF0cyIsInRyYW5zYWN0aW9uc0Vycm9yIiwidG90YWxUcmFuc2FjdGlvbnMiLCJ0b3RhbFJldmVudWUiLCJ0IiwiYXZlcmFnZVRyYW5zYWN0aW9uIiwidG90YWxDb21taXNzaW9uIiwiY29tbWlzc2lvbkRhdGEiLCJjb21taXNzaW9uRXJyb3IiLCJjb21taXNzaW9uX2Ftb3VudCIsImZvckVhY2giLCJhYnMiLCJzdGF0cyIsImdldEVtcGxveWVlQ29tbWlzc2lvbnMiLCJnZXRFbXBsb3llZUF0dGVuZGFuY2UiLCJjaGVja19pbl90aW1lIiwiY2hlY2tJblRpbWUiLCJ0b3RhbEhvdXJzIiwidG90YWxfaG91cnMiLCJyZWd1bGFySG91cnMiLCJnZXRFbXBsb3llZVBob3RvcyIsIm9yIiwiYXR0ZW5kYW5jZVdpdGhEZXRhaWxzIiwiY2hlY2tfb3V0X3RpbWUiLCJicmVha19zdGFydF90aW1lIiwiYnJlYWtfZW5kX3RpbWUiLCJicmVha19kdXJhdGlvbiIsImNoZWNrX2luX3Bob3RvIiwiY2hlY2tfb3V0X3Bob3RvIiwidW5kZWZpbmVkIiwiYWRkcmVzcyIsImdldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3MiLCJkYXlzIiwic3RhcnREYXRlU3RyIiwiZW5kRGF0ZVN0ciIsImRhdGFMZW5ndGgiLCJhdHRlbmRhbmNlUmVjb3JkcyIsInIiLCJnZXRDdXJyZW50VXNlciIsImdldFVzZXIiLCJnZXRBdXRoVXNlclByb2ZpbGUiLCJhdXRoRGF0YSIsImNyZWF0ZVVzZXJQcm9maWxlRnJvbUF1dGgiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImdldFVzZXJCeUlkIiwibmV3VXNlciIsImluc2VydEVycm9yIiwidXBkYXRlRXhwZW5zZVJlcXVlc3QiLCJleHBlbnNlSWQiLCJleHBlbnNlRGF0YSIsImRlbGV0ZUV4cGVuc2VSZXF1ZXN0IiwiZGVsZXRlIiwiZ2V0RXhwZW5zZXMiLCJnZXRFeHBlbnNlU3RhdGlzdGljcyIsInRvdGFsRXhwZW5zZXMiLCJhdmVyYWdlUGVyVHJhbnNhY3Rpb24iLCJleHBlbnNlIiwidHJhbnNhY3Rpb25Db3VudCIsImNyZWF0ZUV4cGVuc2VSZXF1ZXN0IiwiZXhwZW5zZVRvSW5zZXJ0IiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsIm5vdGVzIiwiZXhwZW5zZV9kYXRlIiwiZ2V0QWxsRXhwZW5zZXNXaXRoRGV0YWlscyIsInVwZGF0ZUV4cGVuc2VTdGF0dXMiLCJyZWplY3Rpb25SZWFzb24iLCJyZWplY3Rpb25fcmVhc29uIiwiZ2V0RXhwZW5zZVN0YXRpc3RpY3NCeUJyYW5jaCIsInRvdGFsIiwicGVuZGluZyIsImFwcHJvdmVkIiwicmVqZWN0ZWQiLCJwYWlkIiwidG90YWxBbW91bnQiLCJyZWplY3RlZEFtb3VudCIsInBhaWRBbW91bnQiLCJnZXRFeHBlbnNlc0J5U3RhdHVzIiwiZ2V0QWJzZW50RW1wbG95ZWVzVG9kYXkiLCJlbXBsb3llZXNFcnJvciIsInRvZGF5QXR0ZW5kYW5jZSIsInByZXNlbnRFbXBsb3llZUlkcyIsImFic2VudEVtcGxveWVlcyIsImhhcyIsInRyYW5zZm9ybWVkQWJzZW50RW1wbG95ZWVzIiwiYXZhdGFyIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbkRhdGUiLCJnZXREZXRhaWxlZEF0dGVuZGFuY2VSZWNvcmRzIiwiZ2V0T3V0bGV0U3RvY2siLCJvdXRsZXRJZCIsInVwZGF0ZU91dGxldFN0b2NrIiwib3V0bGV0X2lkIiwic3RvY2tfcXVhbnRpdHkiLCJtaW5fc3RvY2tfdGhyZXNob2xkIiwib25Db25mbGljdCIsImdldExvd1N0b2NrQWxlcnRzIiwiYWxsU3RvY2siLCJsb3dTdG9jayIsInJlZHVjZU91dGxldFN0b2NrIiwibG9hZEJyYW5jaGVzRGF0YSIsInNldEJyYW5jaGVzIiwic2V0U2VsZWN0ZWRCcmFuY2giLCJsb2FkQnJhbmNoRGF0YSIsInNldFJlY2VpcHRUZW1wbGF0ZSIsInNldEJyYW5jaEluZm8iLCJ0ZW1wbGF0ZURhdGEiLCJ0ZW1wbGF0ZUVycm9yIiwicHJvY2Vzc1RyYW5zYWN0aW9uIiwic2VsZWN0ZWRCcmFuY2giLCJjYXJ0IiwiY3VycmVudFVzZXIiLCJwYXltZW50TWV0aG9kIiwiY3VzdG9tZXJOYW1lIiwiZGlzY291bnRSZWFzb24iLCJnZXRUb3RhbFByaWNlIiwiZ2V0RGlzY291bnRBbW91bnQiLCJnZXRGaW5hbFRvdGFsIiwic2VsZWN0ZWRCcmFuY2hEYXRhIiwiZmluZCIsInJlY2VpcHROdW1iZXIiLCJmbG9vciIsInJhbmRvbSIsImZpbmFsX2Ftb3VudCIsImN1c3RvbWVyX25hbWUiLCJzZXR1cFRyYW5zYWN0aW9uc1JlYWx0aW1lIiwiY2FsbGJhY2siLCJjaGFubmVsIiwib24iLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwicGF5bG9hZCIsInN1YnNjcmliZSIsInNldHVwS29taXNpUmVhbHRpbWUiLCJicm9hZGNhc3RUcmFuc2FjdGlvbkV2ZW50IiwiZXZlbnRUeXBlIiwic2VuZCIsInNldHVwR2xvYmFsRXZlbnRzTGlzdGVuZXIiLCJzdWJzY3JpYmVUb0V2ZW50cyIsInNldHVwRW1wbG95ZWVSZWFsdGltZSIsImdldEFwcHJvdmVkRXhwZW5zZXMiLCJnZXRPd25lclBpbiIsInVwZGF0ZVVzZXJQaW4iLCJuZXdQaW4iLCJ0ZXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.ts\n"));

/***/ })

});