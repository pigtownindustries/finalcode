"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/owner/page",{

/***/ "(app-pages-browser)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEmployee: () => (/* binding */ addEmployee),\n/* harmony export */   addPointTransaction: () => (/* binding */ addPointTransaction),\n/* harmony export */   broadcastTransactionEvent: () => (/* binding */ broadcastTransactionEvent),\n/* harmony export */   checkServiceStock: () => (/* binding */ checkServiceStock),\n/* harmony export */   createAttendanceRecord: () => (/* binding */ createAttendanceRecord),\n/* harmony export */   createBranchShift: () => (/* binding */ createBranchShift),\n/* harmony export */   createExpenseRequest: () => (/* binding */ createExpenseRequest),\n/* harmony export */   createKasbonRequest: () => (/* binding */ createKasbonRequest),\n/* harmony export */   createTransaction: () => (/* binding */ createTransaction),\n/* harmony export */   createTransactionItems: () => (/* binding */ createTransactionItems),\n/* harmony export */   deleteEmployee: () => (/* binding */ deleteEmployee),\n/* harmony export */   deleteExpenseRequest: () => (/* binding */ deleteExpenseRequest),\n/* harmony export */   generateTransactionNumber: () => (/* binding */ generateTransactionNumber),\n/* harmony export */   getAbsentEmployeesToday: () => (/* binding */ getAbsentEmployeesToday),\n/* harmony export */   getActiveReceiptTemplate: () => (/* binding */ getActiveReceiptTemplate),\n/* harmony export */   getAllAttendanceRecords: () => (/* binding */ getAllAttendanceRecords),\n/* harmony export */   getAllExpensesWithDetails: () => (/* binding */ getAllExpensesWithDetails),\n/* harmony export */   getApprovedExpenses: () => (/* binding */ getApprovedExpenses),\n/* harmony export */   getAttendanceByDate: () => (/* binding */ getAttendanceByDate),\n/* harmony export */   getBranchShifts: () => (/* binding */ getBranchShifts),\n/* harmony export */   getBranches: () => (/* binding */ getBranches),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   getDetailedAttendanceRecords: () => (/* binding */ getDetailedAttendanceRecords),\n/* harmony export */   getEmployeeAbsenceInfo: () => (/* binding */ getEmployeeAbsenceInfo),\n/* harmony export */   getEmployeeAttendance: () => (/* binding */ getEmployeeAttendance),\n/* harmony export */   getEmployeeAttendanceWithPhotos: () => (/* binding */ getEmployeeAttendanceWithPhotos),\n/* harmony export */   getEmployeeCommissions: () => (/* binding */ getEmployeeCommissions),\n/* harmony export */   getEmployeePhotos: () => (/* binding */ getEmployeePhotos),\n/* harmony export */   getEmployeeStats: () => (/* binding */ getEmployeeStats),\n/* harmony export */   getEmployees: () => (/* binding */ getEmployees),\n/* harmony export */   getExpenseStatistics: () => (/* binding */ getExpenseStatistics),\n/* harmony export */   getExpenseStatisticsByBranch: () => (/* binding */ getExpenseStatisticsByBranch),\n/* harmony export */   getExpenses: () => (/* binding */ getExpenses),\n/* harmony export */   getExpensesByStatus: () => (/* binding */ getExpensesByStatus),\n/* harmony export */   getKasbonRequests: () => (/* binding */ getKasbonRequests),\n/* harmony export */   getKasbonStatistics: () => (/* binding */ getKasbonStatistics),\n/* harmony export */   getLowStockAlerts: () => (/* binding */ getLowStockAlerts),\n/* harmony export */   getOutletStock: () => (/* binding */ getOutletStock),\n/* harmony export */   getOwnerPin: () => (/* binding */ getOwnerPin),\n/* harmony export */   getPointTransactions: () => (/* binding */ getPointTransactions),\n/* harmony export */   getPointsStatistics: () => (/* binding */ getPointsStatistics),\n/* harmony export */   getReceiptTemplate: () => (/* binding */ getReceiptTemplate),\n/* harmony export */   getServiceCategories: () => (/* binding */ getServiceCategories),\n/* harmony export */   getServicesWithCategories: () => (/* binding */ getServicesWithCategories),\n/* harmony export */   getUserPoints: () => (/* binding */ getUserPoints),\n/* harmony export */   getUsersWithKasbon: () => (/* binding */ getUsersWithKasbon),\n/* harmony export */   getUsersWithPoints: () => (/* binding */ getUsersWithPoints),\n/* harmony export */   loadBranchData: () => (/* binding */ loadBranchData),\n/* harmony export */   loadBranchesData: () => (/* binding */ loadBranchesData),\n/* harmony export */   processTransaction: () => (/* binding */ processTransaction),\n/* harmony export */   reduceOutletStock: () => (/* binding */ reduceOutletStock),\n/* harmony export */   reduceServiceStock: () => (/* binding */ reduceServiceStock),\n/* harmony export */   setupEmployeeRealtime: () => (/* binding */ setupEmployeeRealtime),\n/* harmony export */   setupGlobalEventsListener: () => (/* binding */ setupGlobalEventsListener),\n/* harmony export */   setupKomisiRealtime: () => (/* binding */ setupKomisiRealtime),\n/* harmony export */   setupTransactionsRealtime: () => (/* binding */ setupTransactionsRealtime),\n/* harmony export */   subscribeToEvents: () => (/* binding */ subscribeToEvents),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   testSupabaseConnection: () => (/* binding */ testSupabaseConnection),\n/* harmony export */   updateAttendanceRecord: () => (/* binding */ updateAttendanceRecord),\n/* harmony export */   updateEmployee: () => (/* binding */ updateEmployee),\n/* harmony export */   updateExpenseRequest: () => (/* binding */ updateExpenseRequest),\n/* harmony export */   updateExpenseStatus: () => (/* binding */ updateExpenseStatus),\n/* harmony export */   updateKasbonStatus: () => (/* binding */ updateKasbonStatus),\n/* harmony export */   updateMaxAbsentDays: () => (/* binding */ updateMaxAbsentDays),\n/* harmony export */   updateOutletStock: () => (/* binding */ updateOutletStock),\n/* harmony export */   updateServiceStock: () => (/* binding */ updateServiceStock),\n/* harmony export */   updateUserPin: () => (/* binding */ updateUserPin),\n/* harmony export */   uploadPhotoToSupabase: () => (/* binding */ uploadPhotoToSupabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/.pnpm/@supabase+supabase-js@2.55.0/node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\n// =============================\n// Konfigurasi Supabase\n// =============================\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"https://tkrrjvcgviwnliinovik.supabase.co\";\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrcnJqdmNndml3bmxpaW5vdmlrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMDE4MjQsImV4cCI6MjA3MDY3NzgyNH0.uf7R06Gd6Mgf_3Zv3Q184HWPqzo6kbrfhQ1BkkdM9iM\";\nif (!supabaseUrl) {\n    throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable.\");\n}\nif (!supabaseAnonKey) {\n    throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable.\");\n}\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: true,\n        autoRefreshToken: true\n    },\n    realtime: {\n        params: {\n            eventsPerSecond: 10\n        }\n    },\n    global: {\n        headers: {\n            'x-application-name': 'pigtown-barbershop'\n        }\n    }\n});\nconst testSupabaseConnection = async ()=>{\n    try {\n        const { data, error } = await supabase.from(\"points\").select('*, users!inner(name, branch_id, branches:branch_id(name))');\n        if (error) {\n            console.error(\"Supabase connection test failed:\", error);\n            return false;\n        }\n        console.log(\"Supabase connection successful\");\n        return true;\n    } catch (error) {\n        console.error(\"Supabase connection error:\", error);\n        return false;\n    }\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Hitung Hari Kerja\n// =============================\nfunction getBusinessDaysCount(startDate, endDate) {\n    let count = 0;\n    const curDate = new Date(startDate.getTime());\n    while(curDate <= endDate){\n        const dayOfWeek = curDate.getDay();\n        // 0 = Minggu, 6 = Sabtu (tidak dihitung sebagai hari kerja)\n        if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n            count++;\n        }\n        curDate.setDate(curDate.getDate() + 1);\n    }\n    return count;\n}\nasync function getBranchShifts(branchId) {\n    console.log(\"[v0] getBranchShifts called with branchId:\", branchId);\n    const { data, error } = await supabase.from(\"branch_shifts\").select(\"*\").eq(\"branch_id\", branchId).eq(\"is_active\", true).order(\"start_time\");\n    console.log(\"[v0] Branch shifts result:\", {\n        data,\n        error\n    });\n    if (error || !data || data.length === 0) {\n        console.log(\"[v0] No shifts found, returning default shifts\");\n        return {\n            data: [\n                {\n                    id: \"default-pagi-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Pagi\",\n                    shift_type: \"pagi\",\n                    start_time: \"08:00\",\n                    end_time: \"16:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                },\n                {\n                    id: \"default-siang-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Siang\",\n                    shift_type: \"siang\",\n                    start_time: \"12:00\",\n                    end_time: \"20:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                },\n                {\n                    id: \"default-malam-\".concat(branchId),\n                    branch_id: branchId,\n                    shift_name: \"Shift Malam\",\n                    shift_type: \"malam\",\n                    start_time: \"20:00\",\n                    end_time: \"04:00\",\n                    is_active: true,\n                    created_at: new Date().toISOString()\n                }\n            ],\n            error: null\n        };\n    }\n    return {\n        data,\n        error: null\n    };\n}\nasync function createBranchShift(shiftData) {\n    console.log(\"[v0] createBranchShift called with:\", shiftData);\n    const shiftToInsert = {\n        ...shiftData,\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"branch_shifts\").insert([\n        shiftToInsert\n    ]).select().single();\n    console.log(\"[v0] Create branch shift result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// Fungsi helper Attendance\n// =============================\nasync function uploadPhotoToSupabase(base64, filename) {\n    try {\n        function base64ToBlob(base64Data) {\n            let contentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"image/jpeg\";\n            const byteCharacters = atob(base64Data.split(\",\")[1]);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++)byteNumbers[i] = slice.charCodeAt(i);\n                byteArrays.push(new Uint8Array(byteNumbers));\n            }\n            return new Blob(byteArrays, {\n                type: contentType\n            });\n        }\n        const blob = base64ToBlob(base64);\n        const { error } = await supabase.storage.from(\"attendance-photos\").upload(filename, blob, {\n            cacheControl: \"3600\",\n            upsert: true,\n            contentType: \"image/jpeg\"\n        });\n        if (error) throw error;\n        const { data: publicUrlData } = supabase.storage.from(\"attendance-photos\").getPublicUrl(filename);\n        return (publicUrlData === null || publicUrlData === void 0 ? void 0 : publicUrlData.publicUrl) || null;\n    } catch (error) {\n        console.error(\"Photo upload failed:\", error);\n        return null;\n    }\n}\nasync function createAttendanceRecord(attendanceData) {\n    const { data, error } = await supabase.from(\"attendance\").insert([\n        attendanceData\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateAttendanceRecord(id, updates) {\n    const { data, error } = await supabase.from(\"attendance\").update({\n        ...updates,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", id).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAttendanceByDate(userId, date) {\n    const { data, error } = await supabase.from(\"attendance\").select(\"*\").eq(\"user_id\", userId).eq(\"date\", date).single();\n    return error && error.code !== \"PGRST116\" ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAllAttendanceRecords(branchId) {\n    let query = supabase.from(\"attendance\").select(\"*,\\n      users:user_id ( id, name, email ),\\n      branches:branch_id ( id, name )\\n    \").order(\"date\", {\n        ascending: false\n    }).order(\"created_at\", {\n        ascending: false\n    });\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data, error } = await query;\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Fungsi helper POS\n// =============================\nasync function getServicesWithCategories() {\n    const { data, error } = await supabase.from(\"services\").select(\"*,\\n    service_categories ( id, name, description )\\n  \").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function getServiceCategories() {\n    const { data, error } = await supabase.from(\"service_categories\").select(\"*\").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function createTransaction(transactionData) {\n    const transactionNumber = await generateTransactionNumber();\n    let { cashier_id, branch_id, server_id } = transactionData;\n    // Get cashier, branch, server data untuk snapshot\n    let cashierName = 'Unknown';\n    let branchName = 'Unknown';\n    let serverName;\n    if (!cashier_id) {\n        const { data: users } = await supabase.from(\"users\").select(\"id, name\").limit(1).single();\n        cashier_id = users === null || users === void 0 ? void 0 : users.id;\n        cashierName = (users === null || users === void 0 ? void 0 : users.name) || 'Unknown';\n    } else {\n        const { data: cashier } = await supabase.from(\"users\").select(\"name\").eq(\"id\", cashier_id).single();\n        cashierName = (cashier === null || cashier === void 0 ? void 0 : cashier.name) || 'Unknown';\n    }\n    if (!branch_id) {\n        const { data: branches } = await supabase.from(\"branches\").select(\"id, name\").limit(1).single();\n        branch_id = branches === null || branches === void 0 ? void 0 : branches.id;\n        branchName = (branches === null || branches === void 0 ? void 0 : branches.name) || 'Unknown';\n    } else {\n        const { data: branch } = await supabase.from(\"branches\").select(\"name\").eq(\"id\", branch_id).single();\n        branchName = (branch === null || branch === void 0 ? void 0 : branch.name) || 'Unknown';\n    }\n    if (server_id) {\n        const { data: server } = await supabase.from(\"users\").select(\"name\").eq(\"id\", server_id).single();\n        serverName = server === null || server === void 0 ? void 0 : server.name;\n    }\n    const transactionToInsert = {\n        ...transactionData,\n        transaction_number: transactionNumber,\n        receipt_number: transactionNumber,\n        cashier_id,\n        cashier_name: cashierName,\n        branch_id,\n        branch_name: branchName,\n        server_id,\n        server_name: serverName,\n        subtotal: transactionData.subtotal || transactionData.total_amount || 0,\n        payment_status: transactionData.payment_status || \"completed\",\n        payment_method: transactionData.payment_method || \"cash\",\n        total_amount: transactionData.total_amount || 0,\n        discount_amount: transactionData.discount_amount || 0,\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"transactions\").insert([\n        transactionToInsert\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function createTransactionItems(items) {\n    // Enrich items dengan snapshot data dari services\n    const enrichedItems = await Promise.all(items.map(async (item)=>{\n        if (item.service_id) {\n            var _service_service_categories_, _service_service_categories;\n            const { data: service } = await supabase.from(\"services\").select(\"name, type, service_categories(name)\").eq(\"id\", item.service_id).single();\n            return {\n                ...item,\n                service_name: (service === null || service === void 0 ? void 0 : service.name) || 'Unknown Service',\n                service_type: service === null || service === void 0 ? void 0 : service.type,\n                service_category: Array.isArray(service === null || service === void 0 ? void 0 : service.service_categories) ? (_service_service_categories_ = service.service_categories[0]) === null || _service_service_categories_ === void 0 ? void 0 : _service_service_categories_.name : service === null || service === void 0 ? void 0 : (_service_service_categories = service.service_categories) === null || _service_service_categories === void 0 ? void 0 : _service_service_categories.name\n            };\n        }\n        return item;\n    }));\n    const { data, error } = await supabase.from(\"transaction_items\").insert(enrichedItems).select();\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function getReceiptTemplate(branchId) {\n    let query = supabase.from(\"receipt_templates\").select(\"*\");\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data, error } = await query.single();\n    return error && error.code !== \"PGRST116\" ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getActiveReceiptTemplate(branchId) {\n    // Priority 1: Try to get active template (is_active = true)\n    let query = supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_active\", true);\n    if (branchId) query = query.eq(\"branch_id\", branchId);\n    const { data: activeData, error: activeError } = await query.single();\n    if (activeData && !activeError) {\n        return {\n            data: activeData,\n            error: null\n        };\n    }\n    // Priority 2: If no active template, get default template (is_default = true)\n    let defaultQuery = supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_default\", true);\n    if (branchId) defaultQuery = defaultQuery.eq(\"branch_id\", branchId);\n    const { data: defaultData, error: defaultError } = await defaultQuery.single();\n    if (defaultData && !defaultError) {\n        return {\n            data: defaultData,\n            error: null\n        };\n    }\n    // Priority 3: Fallback to any template\n    return await getReceiptTemplate(branchId);\n}\nasync function getBranches() {\n    const { data, error } = await supabase.from(\"branches\").select(\"*\").order(\"name\");\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\nasync function generateTransactionNumber() {\n    try {\n        const { data, error } = await supabase.rpc(\"generate_receipt_number\");\n        if (!error && data) return data;\n        const today = new Date();\n        const dateStr = today.toISOString().slice(0, 10).replace(/-/g, \"\");\n        const { data: transactions } = await supabase.from(\"transactions\").select(\"transaction_number\").gte(\"created_at\", \"\".concat(today.toISOString().slice(0, 10), \"T00:00:00.000Z\")).lt(\"created_at\", \"\".concat(today.toISOString().slice(0, 10), \"T23:59:59.999Z\"));\n        const counter = ((transactions === null || transactions === void 0 ? void 0 : transactions.length) || 0) + 1;\n        return \"\".concat(dateStr).concat(counter.toString().padStart(3, \"0\"));\n    } catch (e) {\n        return \"\".concat(Date.now());\n    }\n}\n// =============================\n// Fungsi helper Stock Management\n// =============================\nasync function checkServiceStock(serviceId) {\n    const { data, error } = await supabase.from(\"services\").select(\"stock\").eq(\"id\", serviceId).single();\n    return error ? 0 : (data === null || data === void 0 ? void 0 : data.stock) || 0;\n}\nasync function reduceServiceStock(serviceId, quantity) {\n    const { data: currentService, error: fetchError } = await supabase.from(\"services\").select(\"stock\").eq(\"id\", serviceId).single();\n    if (fetchError) return {\n        data: null,\n        error: fetchError\n    };\n    const currentStock = currentService.stock || 0;\n    const newStock = Math.max(0, currentStock - quantity);\n    const { data, error } = await supabase.from(\"services\").update({\n        stock: newStock\n    }).eq(\"id\", serviceId).select(\"stock\").single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateServiceStock(serviceId, newStock) {\n    const { data, error } = await supabase.from(\"services\").update({\n        stock: newStock,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", serviceId).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// Fungsi helper Points System\n// =============================\nasync function getUsersWithPoints(branchId) {\n    console.log(\"[v1] getUsersWithPoints called with branchId:\", branchId);\n    let usersQuery = supabase.from(\"users\").select(\"*, branches:branch_id(name)\").order(\"name\");\n    if (branchId && branchId !== \"all\") {\n        usersQuery = usersQuery.eq(\"branch_id\", branchId);\n    }\n    const { data: users, error: usersError } = await usersQuery;\n    if (usersError) return {\n        data: [],\n        error: usersError\n    };\n    if (!users) return {\n        data: [],\n        error: null\n    };\n    const { data: allPoints, error: pointsError } = await supabase.from(\"points\").select(\"user_id, points_earned, created_at\");\n    if (pointsError) return {\n        data: [],\n        error: pointsError\n    };\n    const usersWithCalculatedPoints = users.map((user)=>{\n        const userPoints = (allPoints === null || allPoints === void 0 ? void 0 : allPoints.filter((point)=>point.user_id === user.id)) || [];\n        const totalPoints = userPoints.reduce((sum, point)=>sum + (point.points_earned || 0), 0);\n        const currentMonth = new Date().getMonth();\n        const currentYear = new Date().getFullYear();\n        const monthlyPoints = userPoints.reduce((sum, point)=>{\n            const pointDate = new Date(point.created_at);\n            if (pointDate.getMonth() === currentMonth && pointDate.getFullYear() === currentYear) {\n                return sum + (point.points_earned || 0);\n            }\n            return sum;\n        }, 0);\n        return {\n            ...user,\n            total_points: totalPoints,\n            monthly_points: monthlyPoints\n        };\n    });\n    const sortedUsers = usersWithCalculatedPoints.sort((a, b)=>(b.total_points || 0) - (a.total_points || 0)).map((user, index)=>({\n            ...user,\n            rank: index + 1\n        }));\n    console.log(\"[v1] Final sorted users:\", sortedUsers);\n    return {\n        data: sortedUsers,\n        error: null\n    };\n}\nasync function getPointsStatistics(branchId) {\n    const { data: users, error } = await getUsersWithPoints(branchId);\n    if (error) return {\n        data: null,\n        error\n    };\n    const totalEmployees = users.length;\n    const topPerformer = users[0] || null;\n    const totalPoints = users.reduce((sum, user)=>sum + (user.total_points || 0), 0);\n    const averagePoints = totalEmployees > 0 ? Math.round(totalPoints / totalEmployees) : 0;\n    return {\n        data: {\n            totalEmployees,\n            topPerformer,\n            averagePoints,\n            totalPoints\n        },\n        error: null\n    };\n}\nasync function getPointTransactions(branchId) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n    console.log(\"[v3 Final] getPointTransactions called with branchId:\", branchId);\n    try {\n        // First, get point transactions\n        let query = supabase.from(\"points\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        }).limit(limit);\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: [],\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                // No users in this branch, return empty\n                console.log(\"No users found in branch:\", branchId);\n                return {\n                    data: [],\n                    error: null\n                };\n            }\n        }\n        const { data: pointsData, error } = await query;\n        if (error) {\n            console.error(\"Error fetching point transactions:\", error);\n            console.error(\"Error details:\", JSON.stringify(error, null, 2));\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            return {\n                data: [],\n                error\n            };\n        }\n        if (!pointsData || pointsData.length === 0) {\n            console.log(\"No point transactions found\");\n            return {\n                data: [],\n                error: null\n            };\n        }\n        // Get user details for all points\n        const userIds = [\n            ...new Set(pointsData.map((p)=>p.user_id).filter(Boolean))\n        ];\n        let usersMap = {};\n        if (userIds.length > 0) {\n            const { data: users } = await supabase.from(\"users\").select(\"id, name, branch_id\").in(\"id\", userIds);\n            if (users) {\n                usersMap = users.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Get all unique branch_ids\n        const branchIds = [\n            ...new Set(Object.values(usersMap).map((u)=>u.branch_id).filter(Boolean))\n        ];\n        // Fetch branch details\n        let branchesMap = {};\n        if (branchIds.length > 0) {\n            const { data: branches } = await supabase.from(\"branches\").select(\"id, name\").in(\"id\", branchIds);\n            if (branches) {\n                branchesMap = branches.reduce((acc, b)=>({\n                        ...acc,\n                        [b.id]: b\n                    }), {});\n            }\n        }\n        // Merge user and branch info into points\n        const enrichedData = pointsData === null || pointsData === void 0 ? void 0 : pointsData.map((point)=>{\n            var _usersMap_point_user_id;\n            return {\n                ...point,\n                users: point.user_id ? {\n                    ...usersMap[point.user_id],\n                    branches: ((_usersMap_point_user_id = usersMap[point.user_id]) === null || _usersMap_point_user_id === void 0 ? void 0 : _usersMap_point_user_id.branch_id) ? branchesMap[usersMap[point.user_id].branch_id] : null\n                } : null\n            };\n        });\n        console.log(\"Point transactions fetched successfully:\", (enrichedData === null || enrichedData === void 0 ? void 0 : enrichedData.length) || 0, \"records\");\n        return {\n            data: enrichedData || [],\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Unexpected error in getPointTransactions:\", error);\n        return {\n            data: [],\n            error: error\n        };\n    }\n}\nasync function addPointTransaction(pointData) {\n    const { data, error } = await supabase.from(\"points\").insert([\n        {\n            ...pointData,\n            created_at: new Date().toISOString()\n        }\n    ]).select().single();\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getUserPoints(userId) {\n    const { data, error } = await supabase.from(\"points\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Kasbon Functions\n// =============================\nasync function getKasbonRequests(branchId, statusFilter) {\n    console.log(\"[v0] getKasbonRequests called with:\", {\n        branchId,\n        statusFilter\n    });\n    try {\n        // First, get kasbon requests\n        let query = supabase.from(\"kasbon\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        });\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: [],\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                console.log(\"No users found in branch:\", branchId);\n                return {\n                    data: [],\n                    error: null\n                };\n            }\n        }\n        if (statusFilter && statusFilter !== \"all\") {\n            query = query.eq(\"status\", statusFilter);\n        }\n        const { data: kasbonData, error } = await query;\n        if (error) {\n            console.error(\"[v0] Kasbon requests error:\", error);\n            return {\n                data: [],\n                error\n            };\n        }\n        if (!kasbonData || kasbonData.length === 0) {\n            console.log(\"[v0] No kasbon requests found\");\n            return {\n                data: [],\n                error: null\n            };\n        }\n        // Get user details\n        const userIds = [\n            ...new Set(kasbonData.map((k)=>k.user_id).filter(Boolean))\n        ];\n        let usersMap = {};\n        if (userIds.length > 0) {\n            const { data: users } = await supabase.from(\"users\").select(\"id, name, email, position, branch_id\").in(\"id\", userIds);\n            if (users) {\n                usersMap = users.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Get approver details\n        const approverIds = [\n            ...new Set(kasbonData.map((k)=>k.approved_by).filter(Boolean))\n        ];\n        let approversMap = {};\n        if (approverIds.length > 0) {\n            const { data: approvers } = await supabase.from(\"users\").select(\"id, name\").in(\"id\", approverIds);\n            if (approvers) {\n                approversMap = approvers.reduce((acc, u)=>({\n                        ...acc,\n                        [u.id]: u\n                    }), {});\n            }\n        }\n        // Merge user and approver info\n        const enrichedData = kasbonData.map((kasbon)=>({\n                ...kasbon,\n                user: kasbon.user_id ? usersMap[kasbon.user_id] : null,\n                approver: kasbon.approved_by ? approversMap[kasbon.approved_by] : null\n            }));\n        console.log(\"[v0] Kasbon requests result:\", (enrichedData === null || enrichedData === void 0 ? void 0 : enrichedData.length) || 0, \"records\");\n        return {\n            data: enrichedData || [],\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[v0] Unexpected error in getKasbonRequests:\", error);\n        return {\n            data: [],\n            error: error\n        };\n    }\n}\nasync function getKasbonStatistics(branchId) {\n    console.log(\"[v0] getKasbonStatistics called with branchId:\", branchId);\n    try {\n        let query = supabase.from(\"kasbon\").select(\"amount, status, user_id\");\n        if (branchId && branchId !== \"all\") {\n            // Filter by user's branch_id\n            const { data: usersInBranch, error: usersError } = await supabase.from(\"users\").select(\"id\").eq(\"branch_id\", branchId);\n            if (usersError) {\n                console.error(\"Error fetching users in branch:\", usersError);\n                return {\n                    data: {\n                        pendingAmount: 0,\n                        approvedAmount: 0,\n                        totalPaid: 0,\n                        activeEmployees: 0\n                    },\n                    error: usersError\n                };\n            }\n            if (usersInBranch && usersInBranch.length > 0) {\n                const userIds = usersInBranch.map((u)=>u.id);\n                query = query.in(\"user_id\", userIds);\n            } else {\n                return {\n                    data: {\n                        pendingAmount: 0,\n                        approvedAmount: 0,\n                        totalPaid: 0,\n                        activeEmployees: 0\n                    },\n                    error: null\n                };\n            }\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.log(\"[v0] Error fetching kasbon statistics:\", error);\n            return {\n                data: {\n                    pendingAmount: 0,\n                    approvedAmount: 0,\n                    totalPaid: 0,\n                    activeEmployees: 0\n                },\n                error\n            };\n        }\n        const pendingAmount = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"pending\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const approvedAmount = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"approved\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const totalPaid = (data === null || data === void 0 ? void 0 : data.filter((k)=>k.status === \"paid\").reduce((sum, k)=>sum + (k.amount || 0), 0)) || 0;\n        const { data: usersData } = await supabase.from(\"users\").select(\"id\").eq(\"status\", \"active\");\n        const activeEmployees = (usersData === null || usersData === void 0 ? void 0 : usersData.length) || 0;\n        const statistics = {\n            pendingAmount,\n            approvedAmount,\n            totalPaid,\n            activeEmployees\n        };\n        console.log(\"[v0] Kasbon statistics result:\", statistics);\n        return {\n            data: statistics,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[v0] Unexpected error in getKasbonStatistics:\", error);\n        return {\n            data: {\n                pendingAmount: 0,\n                approvedAmount: 0,\n                totalPaid: 0,\n                activeEmployees: 0\n            },\n            error: error\n        };\n    }\n}\nasync function getUsersWithKasbon(branchId) {\n    console.log(\"[v0] getUsersWithKasbon called with branchId:\", branchId);\n    let query = supabase.from(\"users\").select(\"*\").order(\"name\");\n    if (branchId && branchId !== \"all\") {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data: users, error: usersError } = await query;\n    if (usersError) return {\n        data: [],\n        error: usersError\n    };\n    const { data: allKasbon, error: kasbonError } = await supabase.from(\"kasbon\").select(\"*\").order(\"created_at\", {\n        ascending: false\n    });\n    if (kasbonError) {\n        console.log(\"[v0] Kasbon error, returning users without kasbon data:\", kasbonError);\n        const usersWithoutKasbon = (users === null || users === void 0 ? void 0 : users.map((user)=>({\n                ...user,\n                total_kasbon: 0,\n                active_kasbon: 0,\n                kasbon_history: []\n            }))) || [];\n        return {\n            data: usersWithoutKasbon,\n            error: null\n        };\n    }\n    const usersWithKasbonData = (users === null || users === void 0 ? void 0 : users.map((user)=>{\n        const userKasbon = (allKasbon === null || allKasbon === void 0 ? void 0 : allKasbon.filter((kasbon)=>kasbon.user_id === user.id)) || [];\n        const totalKasbon = userKasbon.reduce((sum, kasbon)=>sum + (kasbon.amount || 0), 0);\n        const activeKasbon = userKasbon.filter((kasbon)=>kasbon.status === \"approved\" || kasbon.status === \"pending\").reduce((sum, kasbon)=>sum + (kasbon.amount || 0), 0);\n        return {\n            ...user,\n            total_kasbon: totalKasbon,\n            active_kasbon: activeKasbon,\n            kasbon_history: userKasbon\n        };\n    })) || [];\n    console.log(\"[v0] Users with kasbon data:\", usersWithKasbonData);\n    return {\n        data: usersWithKasbonData,\n        error: null\n    };\n}\nasync function createKasbonRequest(kasbonData) {\n    console.log(\"[v0] createKasbonRequest called with:\", kasbonData);\n    // Get user name for snapshot\n    const { data: user, error: userError } = await supabase.from(\"users\").select(\"name\").eq(\"id\", kasbonData.user_id).single();\n    if (userError) {\n        console.error(\"[createKasbonRequest] Error getting user name:\", userError);\n        return {\n            data: null,\n            error: userError\n        };\n    }\n    const kasbonToInsert = {\n        ...kasbonData,\n        user_name: (user === null || user === void 0 ? void 0 : user.name) || \"Unknown\",\n        status: \"pending\",\n        request_date: new Date().toISOString(),\n        created_at: new Date().toISOString()\n    };\n    const { data, error } = await supabase.from(\"kasbon\").insert([\n        kasbonToInsert\n    ]).select().single();\n    console.log(\"[v0] Create kasbon result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function updateKasbonStatus(kasbonId, status, approvedBy) {\n    console.log(\"[v0] updateKasbonStatus called with:\", {\n        kasbonId,\n        status,\n        approvedBy\n    });\n    const updateData = {\n        status,\n        updated_at: new Date().toISOString()\n    };\n    if (status === \"approved\") {\n        updateData.approved_by = approvedBy;\n        updateData.approved_at = new Date().toISOString();\n    }\n    const { data, error } = await supabase.from(\"kasbon\").update(updateData).eq(\"id\", kasbonId).select().single();\n    console.log(\"[v0] Update kasbon status result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\n// =============================\n// FUNGSI SEDERHANA: HITUNG HARI TIDAK HADIR\n// =============================\nasync function getEmployeeAbsenceInfo(employeeId) {\n    console.log(\"[SIMPLE] getEmployeeAbsenceInfo called for:\", employeeId);\n    try {\n        // 1. Get employee data termasuk settingan libur\n        const { data: employee, error: empError } = await supabase.from(\"users\").select(\"max_absent_days\").eq(\"id\", employeeId).single();\n        if (empError || !employee) {\n            console.error(\"Error getting employee:\", empError);\n            return {\n                maxAbsentDays: 4,\n                currentAbsentDays: 0,\n                remainingDays: 4,\n                excessDays: 0\n            };\n        }\n        // 2. Hitung hari tidak hadir bulan ini\n        const currentDate = new Date();\n        const firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);\n        const lastDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);\n        const { data: attendanceData, error: attendanceError } = await supabase.from(\"attendance\").select(\"status, date\").eq(\"user_id\", employeeId).gte(\"date\", firstDayOfMonth.toISOString().split('T')[0]).lte(\"date\", lastDayOfMonth.toISOString().split('T')[0]);\n        if (attendanceError) {\n            console.error(\"Error getting attendance data:\", attendanceError);\n            return {\n                maxAbsentDays: employee.max_absent_days || 4,\n                currentAbsentDays: 0,\n                remainingDays: employee.max_absent_days || 4,\n                excessDays: 0\n            };\n        }\n        // Hitung hari tidak hadir (status absent atau tidak ada data attendance)\n        const currentAbsentDays = (attendanceData === null || attendanceData === void 0 ? void 0 : attendanceData.filter((record)=>record.status === \"absent\" || record.status === null).length) || 0;\n        const maxAbsentDays = employee.max_absent_days || 4;\n        const remainingDays = Math.max(0, maxAbsentDays - currentAbsentDays);\n        const excessDays = Math.max(0, currentAbsentDays - maxAbsentDays);\n        console.log(\"[SIMPLE] Absence info:\", {\n            maxAbsentDays,\n            currentAbsentDays,\n            remainingDays,\n            excessDays\n        });\n        return {\n            maxAbsentDays,\n            currentAbsentDays,\n            remainingDays,\n            excessDays\n        };\n    } catch (error) {\n        console.error(\"Error in getEmployeeAbsenceInfo:\", error);\n        return {\n            maxAbsentDays: 4,\n            currentAbsentDays: 0,\n            remainingDays: 4,\n            excessDays: 0\n        };\n    }\n}\n// =============================\n// FUNGSI UPDATE JUMLAH HARI LIBUR\n// =============================\nasync function updateMaxAbsentDays(employeeId, maxDays) {\n    try {\n        const { data, error } = await supabase.from(\"users\").update({\n            max_absent_days: maxDays\n        }).eq(\"id\", employeeId).select().single();\n        if (error) {\n            console.error(\"Error updating max absent days:\", error);\n            return {\n                error\n            };\n        }\n        console.log(\"Max absent days updated:\", data);\n        return {\n            data\n        };\n    } catch (error) {\n        console.error(\"Exception updating max absent days:\", error);\n        return {\n            error\n        };\n    }\n}\n// =============================\n// Employee Management Functions\n// =============================\nasync function getEmployees() {\n    console.log(\"[MODERN] getEmployees called - fetching all employees including inactive\");\n    const { data: users, error: usersError } = await supabase.from(\"users\").select(\"\\n      id,\\n      name,\\n      email,\\n      phone,\\n      position,\\n      status,\\n      created_at,\\n      salary,\\n      commission_rate,\\n      max_absent_days,\\n      pin,\\n      rating,\\n      attendanceRate,\\n      currentMonthCustomers,\\n      totalCustomers,\\n      presentDays,\\n      totalWorkDays,\\n      lateDays,\\n      overtimeHours,\\n      overtimeRate,\\n      bonusPoints,\\n      penaltyPoints,\\n      kasbonBalance,\\n      kasbonLimit,\\n      monthlyRevenue\\n    \").order(\"name\"); // Tampilkan SEMUA karyawan (aktif dan tidak aktif)\n    console.log(\"[MODERN] Result:\", {\n        usersCount: users === null || users === void 0 ? void 0 : users.length,\n        hasError: !!usersError,\n        firstUser: users === null || users === void 0 ? void 0 : users[0]\n    });\n    // PENTING: Hanya return error jika benar-benar ada error DAN tidak ada data\n    if (usersError && !users) {\n        console.error(\"[MODERN] Error fetching employees:\", usersError);\n        return {\n            data: [],\n            error: usersError\n        };\n    }\n    // Transformasi data - gunakan data dari database\n    const employees = (users || []).map((user)=>({\n            id: user.id,\n            name: user.name,\n            email: user.email || '',\n            phone: user.phone || '',\n            position: user.position || '',\n            status: user.status || 'active',\n            salary: user.salary || 3000000,\n            baseSalary: user.salary || 3000000,\n            commissionRate: user.commission_rate || 0,\n            pin: user.pin || '',\n            max_absent_days: user.max_absent_days || 4,\n            created_at: user.created_at,\n            totalBonus: 0,\n            totalPenalty: 0,\n            rating: user.rating || 0,\n            attendanceRate: user.attendanceRate || 0,\n            currentMonthCustomers: user.currentMonthCustomers || 0,\n            totalCustomers: user.totalCustomers || 0,\n            presentDays: user.presentDays || 0,\n            totalWorkDays: user.totalWorkDays || 0,\n            lateDays: user.lateDays || 0,\n            overtimeHours: user.overtimeHours || 0,\n            overtimeRate: user.overtimeRate || 0,\n            bonusPoints: user.bonusPoints || 0,\n            penaltyPoints: user.penaltyPoints || 0,\n            kasbonBalance: user.kasbonBalance || 0,\n            kasbonLimit: user.kasbonLimit || 0,\n            monthlyRevenue: String(user.monthlyRevenue || '0')\n        }));\n    console.log(\"[MODERN] Final employees:\", employees.length);\n    return {\n        data: employees,\n        error: null\n    };\n}\nasync function addEmployee(employee) {\n    console.log(\"[v11] addEmployee called with:\", employee);\n    // Just create user profile in users table\n    // Admin will manually create auth user in Supabase Dashboard if needed\n    const userData = {\n        name: employee.name,\n        email: employee.email,\n        phone: employee.phone || null,\n        status: employee.status || \"active\",\n        pin: employee.pin,\n        position: employee.position,\n        salary: employee.salary || employee.baseSalary || 0,\n        commission_rate: employee.commissionRate || 0\n    };\n    const { data, error } = await supabase.from(\"users\").insert([\n        userData\n    ]).select().single();\n    console.log(\"[v11] addEmployee result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function updateEmployee(id, employee) {\n    console.log(\"[v11] updateEmployee called with:\", id);\n    const userData = {\n        name: employee.name,\n        email: employee.email,\n        phone: employee.phone,\n        status: employee.status,\n        pin: employee.pin,\n        position: employee.position,\n        salary: employee.baseSalary,\n        commission_rate: employee.commissionRate\n    };\n    const { data, error } = await supabase.from(\"users\").update(userData).eq(\"id\", id).select().single();\n    console.log(\"[v11] updateEmployee result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function deleteEmployee(id) {\n    console.log(\"[deleteEmployee] Starting deletion for id:\", id);\n    try {\n        // Cek apakah user ada\n        const { data: existingUser, error: checkError } = await supabase.from(\"users\").select(\"*\").eq(\"id\", id).single();\n        if (checkError) {\n            console.error(\"[deleteEmployee] Error checking user:\", checkError);\n            return {\n                data: null,\n                error: checkError\n            };\n        }\n        if (!existingUser) {\n            console.error(\"[deleteEmployee] User not found\");\n            return {\n                data: null,\n                error: {\n                    message: \"Karyawan tidak ditemukan\"\n                }\n            };\n        }\n        console.log(\"[deleteEmployee] User exists:\", existingUser);\n        // SOFT DELETE - ubah status jadi 'inactive' agar data tetap ada untuk transaksi\n        const { data, error } = await supabase.from(\"users\").update({\n            status: 'inactive'\n        }).eq(\"id\", id).select().single();\n        console.log(\"[deleteEmployee] Soft delete response:\", {\n            data,\n            error\n        });\n        if (error) {\n            console.error(\"[deleteEmployee] Soft delete error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"[deleteEmployee] Soft delete successful - status changed to inactive\");\n        return {\n            data,\n            error: null\n        };\n    } catch (e) {\n        console.error(\"[deleteEmployee] Exception:\", e);\n        return {\n            data: null,\n            error: {\n                message: String(e)\n            }\n        };\n    }\n}\n// =============================\n// PERBAIKAN FUNGSI GET EMPLOYEE STATS\n// =============================\nasync function getEmployeeStats(employeeId) {\n    console.log(\"[v13-FIXED] getEmployeeStats called for:\", employeeId);\n    try {\n        // 1. Hitung transaksi dan revenue - gunakan server_id (yang melayani), bukan cashier_id\n        const { data: transactions, error: transactionsError } = await supabase.from(\"transactions\").select(\"total_amount, created_at\").eq(\"server_id\", employeeId).gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n        if (transactionsError) {\n            console.error(\"[v13-FIXED] Error fetching transactions:\", transactionsError);\n        }\n        const totalTransactions = (transactions === null || transactions === void 0 ? void 0 : transactions.length) || 0;\n        const totalRevenue = (transactions === null || transactions === void 0 ? void 0 : transactions.reduce((sum, t)=>sum + (t.total_amount || 0), 0)) || 0;\n        const averageTransaction = totalTransactions > 0 ? totalRevenue / totalTransactions : 0;\n        // 2. Hitung komisi dari commission_amount yang sudah tersimpan di transaction_items\n        let totalCommission = 0;\n        try {\n            console.log(\"[getEmployeeStats] Calculating commission for employee:\", employeeId);\n            const { data: commissionData, error: commissionError } = await supabase.from(\"transaction_items\").select(\"commission_amount, commission_status\").eq(\"barber_id\", employeeId).eq(\"commission_status\", \"credited\").gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n            if (!commissionError && commissionData) {\n                totalCommission = commissionData.reduce((sum, item)=>{\n                    return sum + (item.commission_amount || 0);\n                }, 0);\n                console.log(\"[getEmployeeStats] Commission items found:\", commissionData.length, \"Total:\", totalCommission);\n            } else if (commissionError) {\n                console.error(\"[v13-FIXED] Error calculating commission:\", commissionError);\n            }\n        } catch (commissionError) {\n            console.error(\"[v13-FIXED] Unexpected error calculating commission:\", commissionError);\n            totalCommission = 0;\n        }\n        // 3. Hitung points untuk bonus/penalty\n        const { data: pointsData, error: pointsError } = await supabase.from(\"points\").select(\"points_earned, points_type\").eq(\"user_id\", employeeId).gte(\"created_at\", new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString());\n        let bonusPoints = 0;\n        let penaltyPoints = 0;\n        if (!pointsError && pointsData) {\n            pointsData.forEach((point)=>{\n                if (point.points_earned > 0) {\n                    bonusPoints += point.points_earned;\n                } else {\n                    penaltyPoints += Math.abs(point.points_earned);\n                }\n            });\n        }\n        const stats = {\n            totalTransactions,\n            totalRevenue,\n            totalCommission,\n            averageTransaction,\n            bonusPoints,\n            penaltyPoints,\n            totalBonus: bonusPoints,\n            totalPenalty: penaltyPoints\n        };\n        console.log(\"[v13-FIXED] Employee stats:\", stats);\n        return stats;\n    } catch (error) {\n        console.error(\"[v13-FIXED] Unexpected error in getEmployeeStats:\", error);\n        // Return default stats jika terjadi error\n        return {\n            totalTransactions: 0,\n            totalRevenue: 0,\n            totalCommission: 0,\n            averageTransaction: 0,\n            bonusPoints: 0,\n            penaltyPoints: 0,\n            totalBonus: 0,\n            totalPenalty: 0\n        };\n    }\n}\nasync function getEmployeeCommissions(employeeId) {\n    console.log(\"[v12-FIXED] getEmployeeCommissions (now rules) called for:\", employeeId);\n    const { data, error } = await supabase.from(\"commission_rules\").select(\"*, services (name, price)\").eq(\"user_id\", employeeId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) {\n        console.error(\"[v12-FIXED] Error fetching commission rules:\", error);\n    }\n    console.log(\"[v12-FIXED] Employee commission rules result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// PERBAIKAN FUNGSI GET EMPLOYEE ATTENDANCE\n// =============================\nasync function getEmployeeAttendance(employeeId) {\n    console.log(\"[v13-FIXED] getEmployeeAttendance called for:\", employeeId);\n    try {\n        const currentMonth = new Date().getMonth();\n        const currentYear = new Date().getFullYear();\n        const firstDayOfMonth = new Date(currentYear, currentMonth, 1);\n        const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);\n        const { data, error } = await supabase.from(\"attendance\").select(\"*\").eq(\"user_id\", employeeId).gte(\"date\", firstDayOfMonth.toISOString().split('T')[0]).lte(\"date\", lastDayOfMonth.toISOString().split('T')[0]).order(\"date\", {\n            ascending: true\n        });\n        if (error) {\n            console.error(\"[v13-FIXED] Error fetching attendance:\", error);\n            return {\n                data: [],\n                error,\n                attendanceRate: 0,\n                presentDays: 0,\n                lateDays: 0,\n                overtimeHours: 0,\n                totalWorkDays: 0\n            };\n        }\n        const totalWorkDays = getBusinessDaysCount(firstDayOfMonth, lastDayOfMonth);\n        const presentDays = data.filter((record)=>record.status === \"checked_out\" || record.status === \"checked_in\").length;\n        const lateDays = data.filter((record)=>{\n            if (!record.check_in_time) return false;\n            const checkInTime = record.check_in_time;\n            return checkInTime > \"08:30:00\";\n        }).length;\n        const totalHours = data.reduce((sum, record)=>sum + (record.total_hours || 0), 0);\n        const regularHours = presentDays * 8;\n        const overtimeHours = Math.max(0, totalHours - regularHours);\n        const attendanceRate = totalWorkDays > 0 ? Math.round(presentDays / totalWorkDays * 100) : 0;\n        console.log(\"[v13-FIXED] Employee attendance result:\", {\n            totalWorkDays,\n            presentDays,\n            lateDays,\n            overtimeHours: Math.max(0, overtimeHours),\n            attendanceRate\n        });\n        return {\n            data: data || [],\n            error: null,\n            attendanceRate,\n            presentDays,\n            lateDays,\n            overtimeHours: Math.max(0, overtimeHours),\n            totalWorkDays\n        };\n    } catch (error) {\n        console.error(\"[v13-FIXED] Unexpected error in getEmployeeAttendance:\", error);\n        return {\n            data: [],\n            error: error,\n            attendanceRate: 0,\n            presentDays: 0,\n            lateDays: 0,\n            overtimeHours: 0,\n            totalWorkDays: 0\n        };\n    }\n}\n// =============================\n// ðŸ”¥ FUNGSI BARU YANG DITAMBAHKAN - getEmployeePhotos\n// =============================\nasync function getEmployeePhotos(userId) {\n    console.log(\"[getEmployeePhotos] Called with userId:\", userId);\n    try {\n        const { data, error } = await supabase.from(\"attendance\").select(\"\\n        *,\\n        users:user_id ( id, name, email, position, branch_id ),\\n        branches:branch_id ( id, name, address )\\n      \").eq(\"user_id\", userId).or(\"check_in_photo.not.is.null,check_out_photo.not.is.null\").order(\"date\", {\n            ascending: false\n        }).order(\"created_at\", {\n            ascending: false\n        }).limit(50);\n        console.log(\"[getEmployeePhotos] Query result:\", {\n            data,\n            error\n        });\n        if (error) {\n            console.error(\"[getEmployeePhotos] Error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        const attendanceWithDetails = (data || []).map((record)=>({\n                id: record.id,\n                user_id: record.user_id,\n                branch_id: record.branch_id,\n                shift_type: record.shift_type,\n                check_in_time: record.check_in_time,\n                check_out_time: record.check_out_time,\n                break_start_time: record.break_start_time,\n                break_end_time: record.break_end_time,\n                total_hours: record.total_hours,\n                break_duration: record.break_duration,\n                status: record.status,\n                check_in_photo: record.check_in_photo,\n                check_out_photo: record.check_out_photo,\n                date: record.date,\n                created_at: record.created_at,\n                updated_at: record.updated_at,\n                users: record.users ? {\n                    id: record.users.id,\n                    name: record.users.name,\n                    email: record.users.email,\n                    position: record.users.position,\n                    branch_id: record.users.branch_id,\n                    created_at: record.users.created_at || new Date().toISOString()\n                } : undefined,\n                branches: record.branches ? {\n                    id: record.branches.id,\n                    name: record.branches.name,\n                    address: record.branches.address,\n                    created_at: record.branches.created_at || new Date().toISOString()\n                } : undefined\n            }));\n        console.log(\"[getEmployeePhotos] Returning:\", attendanceWithDetails.length, \"records\");\n        return {\n            data: attendanceWithDetails,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"[getEmployeePhotos] Exception:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// =============================\n// ðŸ”¥ FUNGSI BARU YANG DITAMBAHKAN - getEmployeeAttendanceWithPhotos\n// =============================\nasync function getEmployeeAttendanceWithPhotos(userId) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    console.log(\"[getEmployeeAttendanceWithPhotos] Called with userId:\", userId, \"days:\", days);\n    try {\n        const endDate = new Date();\n        const startDate = new Date();\n        startDate.setDate(endDate.getDate() - days);\n        const startDateStr = startDate.toISOString().split('T')[0];\n        const endDateStr = endDate.toISOString().split('T')[0];\n        console.log(\"[getEmployeeAttendanceWithPhotos] Date range:\", startDateStr, \"to\", endDateStr);\n        const { data, error } = await supabase.from(\"attendance\").select(\"\\n        *,\\n        users:user_id ( id, name, email, position, branch_id ),\\n        branches:branch_id ( id, name, address )\\n      \").eq(\"user_id\", userId).gte(\"date\", startDateStr).lte(\"date\", endDateStr).order(\"date\", {\n            ascending: false\n        }).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"[getEmployeeAttendanceWithPhotos] Query result:\", {\n            dataLength: data === null || data === void 0 ? void 0 : data.length,\n            error\n        });\n        // Ignore empty error objects\n        if (error === null || error === void 0 ? void 0 : error.message) {\n            console.error(\"[getEmployeeAttendanceWithPhotos] Error:\", error);\n            return {\n                data: [],\n                error,\n                attendanceRate: 0,\n                presentDays: 0,\n                lateDays: 0,\n                totalWorkDays: days,\n                overtimeHours: 0\n            };\n        }\n        const attendanceRecords = (data || []).map((record)=>({\n                id: record.id,\n                user_id: record.user_id,\n                branch_id: record.branch_id,\n                shift_type: record.shift_type,\n                check_in_time: record.check_in_time,\n                check_out_time: record.check_out_time,\n                break_start_time: record.break_start_time,\n                break_end_time: record.break_end_time,\n                total_hours: record.total_hours,\n                break_duration: record.break_duration,\n                status: record.status,\n                check_in_photo: record.check_in_photo,\n                check_out_photo: record.check_out_photo,\n                date: record.date,\n                created_at: record.created_at,\n                updated_at: record.updated_at,\n                users: record.users ? {\n                    id: record.users.id,\n                    name: record.users.name,\n                    email: record.users.email,\n                    position: record.users.position,\n                    branch_id: record.users.branch_id,\n                    created_at: record.users.created_at || new Date().toISOString()\n                } : undefined,\n                branches: record.branches ? {\n                    id: record.branches.id,\n                    name: record.branches.name,\n                    address: record.branches.address,\n                    created_at: record.branches.created_at || new Date().toISOString()\n                } : undefined\n            }));\n        const presentDays = attendanceRecords.filter((r)=>r.status !== 'absent' && (r.check_in_time || r.check_out_time)).length;\n        const lateDays = attendanceRecords.filter((r)=>{\n            if (!r.check_in_time) return false;\n            const checkInTime = r.check_in_time;\n            return checkInTime > \"08:30\";\n        }).length;\n        const totalHours = attendanceRecords.reduce((sum, r)=>sum + (r.total_hours || 0), 0);\n        const regularHours = presentDays * 8;\n        const overtimeHours = Math.max(0, totalHours - regularHours);\n        const attendanceRate = days > 0 ? Math.round(presentDays / days * 100) : 0;\n        console.log(\"[getEmployeeAttendanceWithPhotos] Statistics:\", {\n            attendanceRate,\n            presentDays,\n            lateDays,\n            totalWorkDays: days,\n            overtimeHours: Math.round(overtimeHours * 100) / 100\n        });\n        return {\n            data: attendanceRecords,\n            error: null,\n            attendanceRate,\n            presentDays,\n            lateDays,\n            totalWorkDays: days,\n            overtimeHours: Math.round(overtimeHours * 100) / 100\n        };\n    } catch (error) {\n        console.error(\"[getEmployeeAttendanceWithPhotos] Exception:\", error);\n        return {\n            data: [],\n            error: error,\n            attendanceRate: 0,\n            presentDays: 0,\n            lateDays: 0,\n            totalWorkDays: days,\n            overtimeHours: 0\n        };\n    }\n}\n// =============================\n// Auth Helper Functions\n// =============================\nasync function getCurrentUser() {\n    try {\n        const { data: { user }, error } = await supabase.auth.getUser();\n        console.log(\"[getCurrentUser] Auth user:\", user);\n        console.log(\"[getCurrentUser] Auth error:\", error);\n        if (error) {\n            console.error(\"[getCurrentUser] Error getting current user:\", error);\n            return null;\n        }\n        return user;\n    } catch (error) {\n        console.error(\"[getCurrentUser] Unexpected error:\", error);\n        return null;\n    }\n}\n// Fungsi untuk get profile dari auth data saja\nasync function getAuthUserProfile(userId) {\n    try {\n        const { data: authData } = await supabase.auth.getUser();\n        if (authData.user && authData.user.id === userId) {\n            var _authData_user_email;\n            return {\n                id: authData.user.id,\n                email: authData.user.email || \"\",\n                name: ((_authData_user_email = authData.user.email) === null || _authData_user_email === void 0 ? void 0 : _authData_user_email.split('@')[0]) || \"User\",\n                pin: \"\",\n                position: \"employee\",\n                status: \"active\",\n                created_at: new Date().toISOString()\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[getAuthUserProfile] Error:\", error);\n        return null;\n    }\n}\n// Fungsi untuk create user profile dari auth data\nasync function createUserProfileFromAuth(userId) {\n    try {\n        var _authData_user_email;\n        // Get auth user data\n        const { data: authData, error: authError } = await supabase.auth.admin.getUserById(userId);\n        if (authError || !authData.user) {\n            console.error(\"[createUserProfile] Cannot get auth user:\", authError);\n            return getAuthUserProfile(userId);\n        }\n        // Create user profile\n        const { data: newUser, error: insertError } = await supabase.from('users').insert({\n            id: authData.user.id,\n            email: authData.user.email,\n            name: ((_authData_user_email = authData.user.email) === null || _authData_user_email === void 0 ? void 0 : _authData_user_email.split('@')[0]) || 'User',\n            position: 'employee',\n            status: 'active',\n            created_at: new Date().toISOString()\n        }).select().single();\n        if (insertError) {\n            console.error(\"[createUserProfile] Insert failed, using auth data:\", insertError);\n            return getAuthUserProfile(userId);\n        }\n        console.log(\"[createUserProfile] New user profile created\");\n        return newUser;\n    } catch (error) {\n        console.error(\"[createUserProfile] Error:\", error);\n        return getAuthUserProfile(userId);\n    }\n}\n// =============================\n// Pengeluaran Cabang\n// =============================\nasync function updateExpenseRequest(expenseId, expenseData) {\n    console.log(\"[v0] updateExpenseRequest called with:\", {\n        expenseId,\n        expenseData\n    });\n    const { data, error } = await supabase.from(\"expenses\").update({\n        ...expenseData,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", expenseId).select().single();\n    console.log(\"[v0] Update expense result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function deleteExpenseRequest(expenseId) {\n    console.log(\"[v0] deleteExpenseRequest called with id:\", expenseId);\n    const { data, error } = await supabase.from(\"expenses\").delete().eq(\"id\", expenseId);\n    console.log(\"[v0] Delete expense result:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\n// =============================\n// Pengeluaran Cabang - GET\n// =============================\nasync function getExpenses(branchId) {\n    console.log(\"[v0] getExpenses called with branchId:\", branchId);\n    let query = supabase.from(\"expenses\").select(\"\\n      *,\\n      branches!inner (\\n        id,\\n        name\\n      )\\n    \").order(\"expense_date\", {\n        ascending: false\n    });\n    if (branchId) {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data, error } = await query;\n    console.log(\"[v0] Expenses result:\", {\n        data,\n        error\n    });\n    return error ? {\n        data: [],\n        error\n    } : {\n        data: data || [],\n        error: null\n    };\n}\n// =============================\n// Pengeluaran Cabang - STATISTICS\n// =============================\nasync function getExpenseStatistics(branchId) {\n    console.log(\"[v0] getExpenseStatistics called with branchId:\", branchId);\n    let query = supabase.from(\"expenses\").select(\"amount\");\n    if (branchId) {\n        query = query.eq(\"branch_id\", branchId);\n    }\n    const { data, error } = await query;\n    if (error) {\n        console.log(\"[v0] Error fetching expense statistics:\", error);\n        return {\n            data: {\n                totalExpenses: 0,\n                averagePerTransaction: 0\n            },\n            error\n        };\n    }\n    const totalExpenses = (data === null || data === void 0 ? void 0 : data.reduce((sum, expense)=>sum + (expense.amount || 0), 0)) || 0;\n    const transactionCount = (data === null || data === void 0 ? void 0 : data.length) || 0;\n    const averagePerTransaction = transactionCount > 0 ? Math.round(totalExpenses / transactionCount) : 0;\n    const statistics = {\n        totalExpenses,\n        averagePerTransaction\n    };\n    console.log(\"[v0] Expense statistics result:\", statistics);\n    return {\n        data: statistics,\n        error: null\n    };\n}\n// =============================\n// Pengeluaran Cabang - CREATE\n// =============================\nasync function createExpenseRequest(expenseData) {\n    console.log(\"[v0] createExpenseRequest called with:\", expenseData);\n    const expenseToInsert = {\n        branch_id: expenseData.branch_id || null,\n        category: expenseData.category,\n        description: expenseData.description,\n        amount: expenseData.amount,\n        notes: expenseData.notes || null,\n        expense_date: new Date().toISOString().split(\"T\")[0],\n        status: \"pending\",\n        created_at: new Date().toISOString()\n    };\n    console.log(\"Data yang akan diinsert:\", expenseToInsert);\n    const { data, error } = await supabase.from(\"expenses\").insert(expenseToInsert).select().single();\n    console.log(\"[v0] Create expense result:\", {\n        data,\n        error\n    });\n    if (error) {\n        console.error(\"Detail error:\", error);\n    }\n    return error ? {\n        data: null,\n        error\n    } : {\n        data,\n        error: null\n    };\n}\nasync function getAllExpensesWithDetails() {\n    try {\n        console.log(\"ðŸ” Fetching expenses without users relationship...\");\n        // PASTIKAN hanya select branches saja, tanpa users\n        const { data, error } = await supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*)\\n      \").order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('âŒ Error fetching expenses:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"âœ… Successfully fetched expenses:\", data === null || data === void 0 ? void 0 : data.length);\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\nasync function updateExpenseStatus(expenseId, status, rejectionReason) {\n    try {\n        console.log(\"ðŸ”„ Updating expense status:\", {\n            expenseId,\n            status,\n            rejectionReason\n        });\n        // Update status dan rejection_reason jika ada\n        const updateData = {\n            status,\n            updated_at: new Date().toISOString()\n        };\n        // Tambahkan rejection_reason jika status rejected\n        if (status === \"rejected\" && rejectionReason) {\n            updateData.rejection_reason = rejectionReason;\n        }\n        // Clear rejection_reason jika status approved/paid\n        if (status === \"approved\" || status === \"paid\") {\n            updateData.rejection_reason = null;\n        }\n        const { data, error } = await supabase.from('expenses').update(updateData).eq('id', expenseId).select('*').single();\n        if (error) {\n            console.error('âŒ Error updating expense status:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        console.log(\"âœ… Expense status updated successfully\");\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\nasync function getExpenseStatisticsByBranch(branchId) {\n    try {\n        let query = supabase.from('expenses').select('status, amount');\n        if (branchId && branchId !== 'all') {\n            query = query.eq('branch_id', branchId);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error('Error fetching expense statistics:', error);\n            return {\n                total: 0,\n                pending: 0,\n                approved: 0,\n                rejected: 0,\n                paid: 0,\n                totalAmount: 0,\n                pendingAmount: 0,\n                approvedAmount: 0,\n                rejectedAmount: 0,\n                paidAmount: 0\n            };\n        }\n        const stats = {\n            total: (data === null || data === void 0 ? void 0 : data.length) || 0,\n            pending: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'pending').length) || 0,\n            approved: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'approved').length) || 0,\n            rejected: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'rejected').length) || 0,\n            paid: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'paid').length) || 0,\n            totalAmount: (data === null || data === void 0 ? void 0 : data.reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            pendingAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'pending').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            approvedAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'approved').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            rejectedAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'rejected').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0,\n            paidAmount: (data === null || data === void 0 ? void 0 : data.filter((e)=>e.status === 'paid').reduce((sum, e)=>sum + (e.amount || 0), 0)) || 0\n        };\n        return stats;\n    } catch (error) {\n        console.error('Unexpected error in getExpenseStatisticsByBranch:', error);\n        return {\n            total: 0,\n            pending: 0,\n            approved: 0,\n            rejected: 0,\n            paid: 0,\n            totalAmount: 0,\n            pendingAmount: 0,\n            approvedAmount: 0,\n            rejectedAmount: 0,\n            paidAmount: 0\n        };\n    }\n}\nasync function getExpensesByStatus(status, branchId) {\n    try {\n        let query = supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*),\\n        users:requested_by (*)\\n      \").eq('status', status).order('created_at', {\n            ascending: false\n        });\n        if (branchId && branchId !== 'all') {\n            query = query.eq('branch_id', branchId);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error(\"Error fetching \".concat(status, \" expenses:\"), error);\n            return {\n                data: [],\n                error\n            };\n        }\n        return {\n            data: data || [],\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error:', error);\n        return {\n            data: [],\n            error\n        };\n    }\n}\n// =============================\n// Additional Functions\n// =============================\nasync function getAbsentEmployeesToday() {\n    console.log(\"[v0] getAbsentEmployeesToday called\");\n    const today = new Date().toISOString().split(\"T\")[0];\n    try {\n        const { data: activeEmployees, error: employeesError } = await supabase.from(\"users\").select(\"*\").eq(\"status\", \"active\").order(\"name\");\n        if (employeesError) {\n            console.error(\"[v0] Error fetching active employees:\", employeesError);\n            return [];\n        }\n        const { data: todayAttendance, error: attendanceError } = await supabase.from(\"attendance\").select(\"user_id\").eq(\"date\", today);\n        if (attendanceError) {\n            console.error(\"[v0] Error fetching today's attendance:\", attendanceError);\n            return [];\n        }\n        const presentEmployeeIds = new Set((todayAttendance === null || todayAttendance === void 0 ? void 0 : todayAttendance.map((a)=>a.user_id)) || []);\n        const absentEmployees = (activeEmployees === null || activeEmployees === void 0 ? void 0 : activeEmployees.filter((employee)=>!presentEmployeeIds.has(employee.id))) || [];\n        const transformedAbsentEmployees = absentEmployees.map((user)=>({\n                id: user.id,\n                name: user.name,\n                email: user.email || \"\",\n                phone: user.phone || \"\",\n                position: user.position || \"employee\",\n                status: user.status || \"active\",\n                avatar: \"/placeholder.svg?height=40&width=40&query=\".concat(encodeURIComponent(user.name)),\n                rating: 4.5,\n                baseSalary: 5000000,\n                attendanceRate: 95,\n                currentMonthCustomers: 0,\n                totalCustomers: 0,\n                presentDays: 0,\n                totalWorkDays: 0,\n                lateDays: 0,\n                overtimeHours: 0,\n                overtimeRate: 25000,\n                bonusPoints: 0,\n                penaltyPoints: 0,\n                commissionRate: 0.05,\n                joinDate: user.created_at,\n                kasbonBalance: 0,\n                kasbonLimit: 2000000,\n                monthlyRevenue: \"0\",\n                pin: user.pin || \"\"\n            }));\n        console.log(\"[v0] Found absent employees:\", transformedAbsentEmployees.length);\n        return transformedAbsentEmployees;\n    } catch (error) {\n        console.error(\"[v0] Error in getAbsentEmployeesToday:\", error);\n        return [];\n    }\n}\n// =============================\n// Attendance Management Functions\n// =============================\nasync function getDetailedAttendanceRecords(date) {\n    let query = supabase.from(\"attendance\").select(\"*,\\n      users:user_id (\\n        id,\\n        name,\\n        email,\\n        position,\\n        branch_id\\n      ),\\n      branches:branch_id (\\n        id,\\n        name,\\n        address,\\n        shifts\\n      )\\n    \").order(\"date\", {\n        ascending: false\n    }).order(\"created_at\", {\n        ascending: false\n    });\n    if (date) {\n        query = query.eq(\"date\", date);\n    }\n    const { data, error } = await query;\n    if (error) {\n        console.error(\"[v0] Error fetching detailed attendance:\", error);\n        return {\n            data: [],\n            error\n        };\n    }\n    return {\n        data: data || [],\n        error: null\n    };\n}\n// ðŸ”¥ GET stock per outlet\nconst getOutletStock = async (outletId)=>{\n    try {\n        const { data, error } = await supabase.from('outlet_stock').select('*').eq('outlet_id', outletId).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('Error fetching outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in getOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ UPDATE stock per outlet (with UPSERT)\nconst updateOutletStock = async (outletId, serviceId, newStock)=>{\n    try {\n        // Use upsert to create if not exists, update if exists\n        const { data, error } = await supabase.from('outlet_stock').upsert({\n            outlet_id: outletId,\n            service_id: serviceId,\n            stock_quantity: newStock,\n            is_active: true,\n            min_stock_threshold: 5,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: 'outlet_id,service_id'\n        }).select().single();\n        if (error) {\n            console.error('Error updating outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in updateOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ GET low stock alerts (FIXED VERSION)\nconst getLowStockAlerts = async ()=>{\n    try {\n        // Get all outlet stock (no joins needed)\n        const { data: allStock, error: fetchError } = await supabase.from('outlet_stock').select('*').eq('is_active', true);\n        if (fetchError) {\n            console.error('Error fetching outlet stock:', fetchError);\n            return {\n                data: null,\n                error: fetchError\n            };\n        }\n        // Filter manually for low stock\n        const lowStock = (allStock || []).filter((item)=>item.stock_quantity <= item.min_stock_threshold);\n        return {\n            data: lowStock,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in getLowStockAlerts:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// ðŸ”¥ REDUCE stock ketika terjadi transaksi\n// ðŸ”¥ REDUCE stock ketika terjadi transaksi (FIXED)\nconst reduceOutletStock = async (outletId, serviceId, quantity)=>{\n    try {\n        // Get current stock\n        const { data: currentStock, error: fetchError } = await supabase.from('outlet_stock').select('stock_quantity').eq('outlet_id', outletId).eq('service_id', serviceId).single();\n        if (fetchError) {\n            console.error('Error fetching current stock:', fetchError);\n            return {\n                data: null,\n                error: fetchError\n            };\n        }\n        const newStock = Math.max(0, ((currentStock === null || currentStock === void 0 ? void 0 : currentStock.stock_quantity) || 0) - quantity);\n        // Update stock\n        const { data, error } = await supabase.from('outlet_stock').update({\n            stock_quantity: newStock,\n            updated_at: new Date().toISOString()\n        }).eq('outlet_id', outletId).eq('service_id', serviceId).select(\"\\n        *,\\n        service:services(*, service_categories(*)),\\n        branch:outlet_id(*)\\n      \").single();\n        if (error) {\n            console.error('Error reducing outlet stock:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('Unexpected error in reduceOutletStock:', error);\n        return {\n            data: null,\n            error\n        };\n    }\n};\n// =============================\n// POS Helper Functions\n// =============================\nconst loadBranchesData = async (supabase, setBranches, setSelectedBranch)=>{\n    const { data, error } = await supabase.from(\"branches\").select(\"*\");\n    if (error) {\n        console.error(\"Error loading branches:\", error);\n        return;\n    }\n    setBranches(data);\n    if (data.length > 0) {\n        setSelectedBranch(data[0].name);\n    }\n};\nconst loadBranchData = async (supabase, setReceiptTemplate, setBranchInfo)=>{\n    console.log(\"[v0] Loading branch and template data...\");\n    try {\n        const { data: templateData, error: templateError } = await supabase.from(\"receipt_templates\").select(\"*\").eq(\"is_active\", true).single();\n        if (templateError) {\n            console.error(\"Error loading receipt template:\", templateError);\n        } else {\n            console.log(\"[v0] Loaded active template:\", templateData);\n            setReceiptTemplate(templateData);\n        }\n        console.log(\"[v0] Branch data loading completed without overriding selectedBranch\");\n    } catch (error) {\n        console.error(\"Error loading branch and template data:\", error);\n    }\n};\nconst processTransaction = async (supabase, branches, selectedBranch, cart, currentUser, paymentMethod, customerName, discountReason, getTotalPrice, getDiscountAmount, getFinalTotal)=>{\n    const selectedBranchData = branches.find((b)=>b.name === selectedBranch);\n    if (!(selectedBranchData === null || selectedBranchData === void 0 ? void 0 : selectedBranchData.id)) {\n        throw new Error(\"Data cabang tidak ditemukan\");\n    }\n    const receiptNumber = \"\".concat(new Date().getFullYear()).concat(String(new Date().getMonth() + 1).padStart(2, \"0\")).concat(String(new Date().getDate()).padStart(2, \"0\")).concat(String(Math.floor(Math.random() * 1000)).padStart(3, \"0\"));\n    const transactionData = {\n        receipt_number: receiptNumber,\n        branch_id: selectedBranchData.id,\n        total_amount: getTotalPrice(),\n        discount_amount: getDiscountAmount(),\n        final_amount: getFinalTotal(),\n        payment_method: paymentMethod,\n        customer_name: customerName || null,\n        notes: discountReason || null\n    };\n    console.log(\"[v0] Creating transaction with correct branch_id:\", transactionData);\n    return transactionData;\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Setup Realtime Subscription untuk Transaksi\n// =============================\nconst setupTransactionsRealtime = (callback)=>{\n    const channel = supabase.channel('transactions-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'transactions'\n    }, (payload)=>{\n        console.log('Transaction change detected:', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'transaction_items'\n    }, (payload)=>{\n        console.log('Transaction item change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Realtime subscription status:', status);\n    });\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Setup Realtime untuk Komisi\nconst setupKomisiRealtime = (callback)=>{\n    const channel = supabase.channel('komisi-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'commission_rules'\n    }, (payload)=>{\n        console.log('Commission rule change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Komisi subscription status:', status);\n    });\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Broadcast Event untuk Sinkronisasi Global\nconst broadcastTransactionEvent = async (eventType, payload)=>{\n    try {\n        await supabase.channel('global-events').send({\n            type: 'broadcast',\n            event: eventType,\n            payload: payload\n        });\n        console.log(\"Broadcast event '\".concat(eventType, \"' sent successfully\"));\n    } catch (error) {\n        console.error('Error broadcasting event:', error);\n    }\n};\n// ðŸ”¥ FUNGSI BARU: Listen untuk Global Events\nconst setupGlobalEventsListener = (callback)=>{\n    const channel = supabase.channel('global-events-listener').on('broadcast', {\n        event: '*'\n    }, (payload)=>{\n        console.log('Global event received:', payload);\n        callback(payload.event, payload.payload);\n    }).subscribe();\n    return channel;\n};\n// ðŸ”¥ FUNGSI BARU: Subscribe to Events\nconst subscribeToEvents = (callback)=>{\n    const channel = supabase.channel('global-events-listener').on('broadcast', {\n        event: '*'\n    }, (payload)=>{\n        console.log('Global event received:', payload);\n        callback(payload.event, payload.payload);\n    }).subscribe();\n    return channel;\n};\n// =============================\n// ðŸ”¥ FUNGSI BARU: Setup Realtime Subscription untuk Employee\n// =============================\nconst setupEmployeeRealtime = (callback)=>{\n    console.log(\"Setting up employee realtime subscription\");\n    const channel = supabase.channel('employees-global').on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'users'\n    }, (payload)=>{\n        console.log('Employee change detected:', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'points'\n    }, (payload)=>{\n        console.log('Points change detected (affects employee stats):', payload);\n        callback();\n    }).on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'attendance'\n    }, (payload)=>{\n        console.log('Attendance change detected:', payload);\n        callback();\n    }).subscribe((status)=>{\n        console.log('Employee realtime subscription status:', status);\n    });\n    return channel;\n};\nasync function getApprovedExpenses() {\n    try {\n        console.log(\"ðŸ” Fetching approved expenses...\");\n        const { data, error } = await supabase.from('expenses').select(\"\\n        *,\\n        branches:branch_id (*)\\n      \").in('status', [\n            'approved',\n            'paid'\n        ]).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            console.error('âŒ Error fetching approved expenses:', error);\n            return {\n                data: [],\n                error\n            };\n        }\n        console.log(\"âœ… Successfully fetched approved expenses:\", data === null || data === void 0 ? void 0 : data.length);\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error('âŒ Unexpected error:', error);\n        return {\n            data: [],\n            error\n        };\n    }\n}\n// ðŸ”¥ TAMBAHKAN fungsi ini di supabase.ts\nconst getOwnerPin = async ()=>{\n    try {\n        const { data, error } = await supabase.from('users').select('pin').eq('position', 'owner').single();\n        if (error || !data) {\n            console.error('Error fetching owner PIN:', error);\n            return ''; // Return empty string if not found\n        }\n        return data.pin || '';\n    } catch (error) {\n        console.error('Unexpected error in getOwnerPin:', error);\n        return '';\n    }\n};\n// ðŸ”¥ TAMBAHKAN fungsi ini di supabase.ts\nconst updateUserPin = async (userId, newPin)=>{\n    try {\n        // Validasi PIN 6 digit\n        if (newPin.length !== 6 || !/^\\d+$/.test(newPin)) {\n            console.error('Invalid PIN format');\n            return false;\n        }\n        const { error } = await supabase.from('users').update({\n            pin: newPin\n        }).eq('id', userId);\n        if (error) {\n            console.error('Error updating PIN:', error);\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error('Unexpected error in updateUserPin:', error);\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdXBhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUVwRCxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxNQUFNQyxjQUFjQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHdCQUF3QixJQUFJO0FBQzVELE1BQU1DLGtCQUNKSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLDZCQUE2QixJQUN6QztBQUVGLElBQUksQ0FBQ0wsYUFBYTtJQUNoQixNQUFNLElBQUlNLE1BQU07QUFDbEI7QUFDQSxJQUFJLENBQUNGLGlCQUFpQjtJQUNwQixNQUFNLElBQUlFLE1BQU07QUFDbEI7QUFFTyxNQUFNQyxXQUFXUixtRUFBWUEsQ0FBQ0MsYUFBYUksaUJBQWlCO0lBQ2pFSSxNQUFNO1FBQ0pDLGdCQUFnQjtRQUNoQkMsa0JBQWtCO0lBQ3BCO0lBQ0FDLFVBQVU7UUFDUkMsUUFBUTtZQUNOQyxpQkFBaUI7UUFDbkI7SUFDRjtJQUNBQyxRQUFRO1FBQ05DLFNBQVM7WUFDUCxzQkFBc0I7UUFDeEI7SUFDRjtBQUNGLEdBQUc7QUFFSSxNQUFNQyx5QkFBeUI7SUFDcEMsSUFBSTtRQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxTQUFTWSxJQUFJLENBQUMsVUFBVUMsTUFBTSxDQUFDO1FBQzdELElBQUlGLE9BQU87WUFDVEcsUUFBUUgsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsT0FBTztRQUNUO1FBQ0FHLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE9BQU87SUFDVCxFQUFFLE9BQU9KLE9BQU87UUFDZEcsUUFBUUgsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUNELGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMs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QUFPQSxPQUFPO1FBQ2RHLFFBQVFILEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYmF5dWVcXERlc2t0b3BcXHBpZ3Rvd25iYXJiZXJzaG9wXFxsaWJcXHN1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIlxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gS29uZmlndXJhc2kgU3VwYWJhc2VcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgXCJodHRwczovL3RrcnJqdmNndml3bmxpaW5vdmlrLnN1cGFiYXNlLmNvXCJcclxuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID1cclxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSB8fFxyXG4gIFwiZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnBjM01pT2lKemRYQmhZbUZ6WlNJc0luSmxaaUk2SW5ScmNuSnFkbU5uZG1sM2JteHBhVzV2ZG1scklpd2ljbTlzWlNJNkltRnViMjRpTENKcFlYUWlPakUzTlRVeE1ERTRNalFzSW1WNGNDSTZNakEzTURZM056Z3lOSDAudWY3UjA2R2Q2TWdmXzNadjNRMTg0SFdQcXpvNmticmZoUTFCa2tkTTlpTVwiXHJcblxyXG5pZiAoIXN1cGFiYXNlVXJsKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUuXCIpXHJcbn1cclxuaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIGVudmlyb25tZW50IHZhcmlhYmxlLlwiKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xyXG4gIGF1dGg6IHtcclxuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxyXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcclxuICB9LFxyXG4gIHJlYWx0aW1lOiB7XHJcbiAgICBwYXJhbXM6IHtcclxuICAgICAgZXZlbnRzUGVyU2Vjb25kOiAxMCxcclxuICAgIH0sXHJcbiAgfSxcclxuICBnbG9iYWw6IHtcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ3gtYXBwbGljYXRpb24tbmFtZSc6ICdwaWd0b3duLWJhcmJlcnNob3AnLFxyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZXN0U3VwYWJhc2VDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwicG9pbnRzXCIpLnNlbGVjdCgnKiwgdXNlcnMhaW5uZXIobmFtZSwgYnJhbmNoX2lkLCBicmFuY2hlczpicmFuY2hfaWQobmFtZSkpJylcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJTdXBhYmFzZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxcIilcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJTdXBhYmFzZSBjb25uZWN0aW9uIGVycm9yOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBIaXR1bmcgSGFyaSBLZXJqYVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5mdW5jdGlvbiBnZXRCdXNpbmVzc0RheXNDb3VudChzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpOiBudW1iZXIge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IGN1ckRhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUuZ2V0VGltZSgpKTtcclxuICAgIFxyXG4gICAgd2hpbGUgKGN1ckRhdGUgPD0gZW5kRGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IGN1ckRhdGUuZ2V0RGF5KCk7XHJcbiAgICAgICAgLy8gMCA9IE1pbmdndSwgNiA9IFNhYnR1ICh0aWRhayBkaWhpdHVuZyBzZWJhZ2FpIGhhcmkga2VyamEpXHJcbiAgICAgICAgaWYgKGRheU9mV2VlayAhPT0gMCAmJiBkYXlPZldlZWsgIT09IDYpIHtcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyRGF0ZS5zZXREYXRlKGN1ckRhdGUuZ2V0RGF0ZSgpICsgMSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBjb3VudDtcclxufVxyXG5cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEludGVyZmFjZXNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbi8vIC0tLSBVc2VyICYgQnJhbmNoIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkOiBzdHJpbmdcclxuICBlbWFpbD86IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIHBvc2l0aW9uPzogc3RyaW5nXHJcbiAgYnJhbmNoX2lkPzogc3RyaW5nXHJcbiAgcGhvbmU/OiBzdHJpbmdcclxuICBhZGRyZXNzPzogc3RyaW5nXHJcbiAgc3RhdHVzPzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnJhbmNoIHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgYWRkcmVzcz86IHN0cmluZ1xyXG4gIHBob25lPzogc3RyaW5nXHJcbiAgc3RhdHVzPzogc3RyaW5nXHJcbiAgbWFuYWdlcl9pZD86IHN0cmluZ1xyXG4gIG1hbmFnZXJfbmFtZT86IHN0cmluZ1xyXG4gIG9wZXJhdGluZ19ob3Vycz86IHtcclxuICAgIG9wZW46IHN0cmluZ1xyXG4gICAgY2xvc2U6IHN0cmluZ1xyXG4gIH1cclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICBzaGlmdHM/OiBCcmFuY2hTaGlmdFtdXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZSB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXHJcbiAgcHJpY2U6IG51bWJlclxyXG4gIGR1cmF0aW9uPzogbnVtYmVyXHJcbiAgY2F0ZWdvcnk/OiBzdHJpbmdcclxuICBzdGF0dXM/OiBzdHJpbmdcclxuICBzdG9jaz86IG51bWJlclxyXG4gIHR5cGU/OiBcInNlcnZpY2VcIiB8IFwicHJvZHVjdFwiXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZUNhdGVnb3J5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcclxuICBpc19hY3RpdmU6IGJvb2xlYW5cclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICB1cGRhdGVkX2F0OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlV2l0aENhdGVnb3J5IGV4dGVuZHMgU2VydmljZSB7XHJcbiAgY2F0ZWdvcnlfaWQ/OiBzdHJpbmdcclxuICBpc19hY3RpdmU/OiBib29sZWFuXHJcbiAgY29tbWlzc2lvbl9yYXRlPzogbnVtYmVyXHJcbiAgc2VydmljZV9jYXRlZ29yaWVzPzogU2VydmljZUNhdGVnb3J5XHJcbn1cclxuXHJcbi8vIC0tLSBUcmFuc2FjdGlvbiAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbiB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHRyYW5zYWN0aW9uX251bWJlcjogc3RyaW5nXHJcbiAgY3VzdG9tZXJfbmFtZTogc3RyaW5nXHJcbiAgdG90YWxfYW1vdW50OiBudW1iZXJcclxuICBwYXltZW50X21ldGhvZDogc3RyaW5nXHJcbiAgcGF5bWVudF9zdGF0dXM6IHN0cmluZ1xyXG4gIG5vdGVzPzogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgY2FzaGllcl9pZD86IHN0cmluZ1xyXG4gIGNhc2hpZXJfbmFtZT86IHN0cmluZ1xyXG4gIGJyYW5jaF9pZD86IHN0cmluZ1xyXG4gIGJyYW5jaF9uYW1lPzogc3RyaW5nXHJcbiAgc2VydmVyX2lkPzogc3RyaW5nXHJcbiAgc2VydmVyX25hbWU/OiBzdHJpbmdcclxuICBjYXNoaWVyPzoge1xyXG4gICAgbmFtZTogc3RyaW5nXHJcbiAgfVxyXG4gIGJyYW5jaD86IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gIH1cclxuICB0cmFuc2FjdGlvbl9pdGVtcz86IHtcclxuICAgIHF1YW50aXR5OiBudW1iZXJcclxuICAgIHVuaXRfcHJpY2U6IG51bWJlclxyXG4gICAgdG90YWxfcHJpY2U6IG51bWJlclxyXG4gICAgc2VydmljZV9pZDogc3RyaW5nXHJcbiAgICBzZXJ2aWNlPzoge1xyXG4gICAgICBuYW1lOiBzdHJpbmdcclxuICAgIH1cclxuICB9W11cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbldpdGhJdGVtcyBleHRlbmRzIFRyYW5zYWN0aW9uIHtcclxuICByZWNlaXB0X251bWJlcj86IHN0cmluZ1xyXG4gIGZpbmFsX2Ftb3VudD86IG51bWJlclxyXG4gIHN1YnRvdGFsPzogbnVtYmVyXHJcbiAgZGlzY291bnRfYW1vdW50PzogbnVtYmVyXHJcbiAgdHJhbnNhY3Rpb25faXRlbXM/OiBUcmFuc2FjdGlvbkl0ZW1XaXRoU2VydmljZVtdXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JdGVtIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdHJhbnNhY3Rpb25faWQ6IHN0cmluZ1xyXG4gIHNlcnZpY2VfaWQ6IHN0cmluZ1xyXG4gIHF1YW50aXR5OiBudW1iZXJcclxuICB1bml0X3ByaWNlOiBudW1iZXJcclxuICB0b3RhbF9wcmljZTogbnVtYmVyXHJcbiAgc2VydmljZT86IHsgbmFtZTogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JdGVtV2l0aFNlcnZpY2UgZXh0ZW5kcyBUcmFuc2FjdGlvbkl0ZW0ge1xyXG4gIHNlcnZpY2U/OiBTZXJ2aWNlV2l0aENhdGVnb3J5XHJcbn1cclxuXHJcbi8vIC0tLSBBdHRlbmRhbmNlIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVuZGFuY2Uge1xyXG4gIGlkOiBzdHJpbmdcclxuICB1c2VyX2lkOiBzdHJpbmdcclxuICBicmFuY2hfaWQ/OiBzdHJpbmdcclxuICBzaGlmdF90eXBlOiBcInBhZ2lcIiB8IFwic2lhbmdcIiB8IFwibWFsYW1cIlxyXG4gIGNoZWNrX2luX3RpbWU/OiBzdHJpbmdcclxuICBjaGVja19vdXRfdGltZT86IHN0cmluZ1xyXG4gIGJyZWFrX3N0YXJ0X3RpbWU/OiBzdHJpbmdcclxuICBicmVha19lbmRfdGltZT86IHN0cmluZ1xyXG4gIHRvdGFsX2hvdXJzPzogbnVtYmVyXHJcbiAgYnJlYWtfZHVyYXRpb24/OiBudW1iZXJcclxuICBzdGF0dXM6IFwiY2hlY2tlZF9pblwiIHwgXCJvbl9icmVha1wiIHwgXCJjaGVja2VkX291dFwiIHwgXCJhYnNlbnRcIlxyXG4gIGNoZWNrX2luX3Bob3RvPzogc3RyaW5nXHJcbiAgY2hlY2tfb3V0X3Bob3RvPzogc3RyaW5nXHJcbiAgZGF0ZTogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVuZGFuY2VXaXRoRGV0YWlscyBleHRlbmRzIEF0dGVuZGFuY2Uge1xyXG4gIHVzZXJzPzogVXNlclxyXG4gIGJyYW5jaGVzPzogQnJhbmNoXHJcbn1cclxuXHJcbi8vIC0tLSBNZW51IC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVDYXRlZ29yeSB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXHJcbiAgaWNvbjogc3RyaW5nXHJcbiAgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJpbmFjdGl2ZVwiXHJcbiAgc29ydF9vcmRlcjogbnVtYmVyXHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW0ge1xyXG4gIGlkOiBzdHJpbmdcclxuICBuYW1lOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xyXG4gIHByaWNlOiBudW1iZXJcclxuICBjYXRlZ29yeV9pZDogc3RyaW5nXHJcbiAgZHVyYXRpb24/OiBudW1iZXJcclxuICBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImluYWN0aXZlXCJcclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZWNlaXB0VGVtcGxhdGUge1xyXG4gIGlkOiBzdHJpbmdcclxuICBuYW1lOiBzdHJpbmdcclxuICBoZWFkZXJfdGV4dD86IHN0cmluZ1xyXG4gIGZvb3Rlcl90ZXh0Pzogc3RyaW5nXHJcbiAgbG9nb191cmw/OiBzdHJpbmdcclxuICBpc19hY3RpdmU/OiBib29sZWFuXHJcbiAgc2hvd19sb2dvPzogYm9vbGVhblxyXG4gIHNob3dfYWRkcmVzcz86IGJvb2xlYW5cclxuICBzaG93X3Bob25lPzogYm9vbGVhblxyXG4gIHNob3dfZGF0ZT86IGJvb2xlYW5cclxuICBzaG93X2JhcmJlcj86IGJvb2xlYW5cclxuICBjcmVhdGVkX2F0Pzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVjZWlwdFRlbXBsYXRlV2l0aEJyYW5jaCBleHRlbmRzIFJlY2VpcHRUZW1wbGF0ZSB7XHJcbiAgYnJhbmNoX2lkPzogc3RyaW5nXHJcbiAgdGVtcGxhdGVfbmFtZT86IHN0cmluZ1xyXG4gIHBhcGVyX3dpZHRoPzogbnVtYmVyXHJcbn1cclxuXHJcbi8vIC0tLSBQb2ludHMgU3lzdGVtIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9pZDogc3RyaW5nXHJcbiAgcG9pbnRzX2Vhcm5lZDogbnVtYmVyXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIHBvaW50c190eXBlOiBzdHJpbmdcclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICB1cGRhdGVkX2F0Pzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlcldpdGhQb2ludHMgZXh0ZW5kcyBVc2VyIHtcclxuICB0b3RhbF9wb2ludHM/OiBudW1iZXJcclxuICBtb250aGx5X3BvaW50cz86IG51bWJlclxyXG4gIHJhbms/OiBudW1iZXJcclxuICBwb2ludHM/OiBQb2ludFtdXHJcbiAgYnJhbmNoZXM6IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gIH0gfCBudWxsXHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEthc2JvbiBJbnRlcmZhY2VzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBpbnRlcmZhY2UgS2FzYm9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9pZDogc3RyaW5nXHJcbiAgdXNlcl9uYW1lPzogc3RyaW5nXHJcbiAgYW1vdW50OiBudW1iZXJcclxuICBwYWlkX2Ftb3VudD86IG51bWJlclxyXG4gIHJlYXNvbjogc3RyaW5nXHJcbiAgc3RhdHVzOiBcInBlbmRpbmdcIiB8IFwiYXBwcm92ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwicGFpZFwiXHJcbiAgcmVxdWVzdF9kYXRlOiBzdHJpbmdcclxuICBkdWVfZGF0ZT86IHN0cmluZ1xyXG4gIG5vdGVzPzogc3RyaW5nXHJcbiAgYXBwcm92ZWRfYnk/OiBzdHJpbmdcclxuICBhcHByb3ZlZF9hdD86IHN0cmluZ1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBLYXNib25XaXRoVXNlciBleHRlbmRzIEthc2JvbiB7XHJcbiAgdXNlcj86IFVzZXJcclxuICBhcHByb3Zlcj86IHtcclxuICAgIGlkOiBzdHJpbmdcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VyV2l0aEthc2JvbiBleHRlbmRzIFVzZXIge1xyXG4gIHRvdGFsX2thc2Jvbj86IG51bWJlclxyXG4gIGFjdGl2ZV9rYXNib24/OiBudW1iZXJcclxuICBrYXNib25faGlzdG9yeT86IEthc2JvbltdXHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEV4cGVuc2UgTWFuYWdlbWVudCBJbnRlcmZhY2VzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBpbnRlcmZhY2UgRXhwZW5zZSB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIGJyYW5jaF9pZD86IHN0cmluZ1xyXG4gIGNhdGVnb3J5OiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgYW1vdW50OiBudW1iZXJcclxuICBzdGF0dXM6IFwicGVuZGluZ1wiIHwgXCJhcHByb3ZlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJwYWlkXCJcclxuICByZXF1ZXN0X2RhdGU6IHN0cmluZ1xyXG4gIGR1ZV9kYXRlPzogc3RyaW5nXHJcbiAgcmVjZWlwdF91cmw/OiBzdHJpbmdcclxuICBub3Rlcz86IHN0cmluZ1xyXG4gIHJlcXVlc3RlZF9ieTogc3RyaW5nXHJcbiAgYXBwcm92ZWRfYnk/OiBzdHJpbmdcclxuICBhcHByb3ZlZF9hdD86IHN0cmluZ1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFeHBlbnNlV2l0aFVzZXIgZXh0ZW5kcyBFeHBlbnNlIHtcclxuICB1c2Vycz86IFVzZXJcclxuICBicmFuY2hlcz86IEJyYW5jaFxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBCcmFuY2ggU2hpZnQgTWFuYWdlbWVudFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgaW50ZXJmYWNlIEJyYW5jaFNoaWZ0IHtcclxuICBpZDogc3RyaW5nXHJcbiAgYnJhbmNoX2lkOiBzdHJpbmdcclxuICBzaGlmdF9uYW1lOiBzdHJpbmdcclxuICBzaGlmdF90eXBlOiBcInBhZ2lcIiB8IFwic2lhbmdcIiB8IFwibWFsYW1cIlxyXG4gIHN0YXJ0X3RpbWU6IHN0cmluZ1xyXG4gIGVuZF90aW1lOiBzdHJpbmdcclxuICBpc19hY3RpdmU6IGJvb2xlYW5cclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaFNoaWZ0cyhicmFuY2hJZDogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGdldEJyYW5jaFNoaWZ0cyBjYWxsZWQgd2l0aCBicmFuY2hJZDpcIiwgYnJhbmNoSWQpXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImJyYW5jaF9zaGlmdHNcIilcclxuICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgICAuZXEoXCJpc19hY3RpdmVcIiwgdHJ1ZSlcclxuICAgIC5vcmRlcihcInN0YXJ0X3RpbWVcIilcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIEJyYW5jaCBzaGlmdHMgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcblxyXG4gIGlmIChlcnJvciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIE5vIHNoaWZ0cyBmb3VuZCwgcmV0dXJuaW5nIGRlZmF1bHQgc2hpZnRzXCIpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IGBkZWZhdWx0LXBhZ2ktJHticmFuY2hJZH1gLFxyXG4gICAgICAgICAgYnJhbmNoX2lkOiBicmFuY2hJZCxcclxuICAgICAgICAgIHNoaWZ0X25hbWU6IFwiU2hpZnQgUGFnaVwiLFxyXG4gICAgICAgICAgc2hpZnRfdHlwZTogXCJwYWdpXCIgYXMgY29uc3QsXHJcbiAgICAgICAgICBzdGFydF90aW1lOiBcIjA4OjAwXCIsXHJcbiAgICAgICAgICBlbmRfdGltZTogXCIxNjowMFwiLFxyXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IGBkZWZhdWx0LXNpYW5nLSR7YnJhbmNoSWR9YCxcclxuICAgICAgICAgIGJyYW5jaF9pZDogYnJhbmNoSWQsXHJcbiAgICAgICAgICBzaGlmdF9uYW1lOiBcIlNoaWZ0IFNpYW5nXCIsXHJcbiAgICAgICAgICBzaGlmdF90eXBlOiBcInNpYW5nXCIgYXMgY29uc3QsXHJcbiAgICAgICAgICBzdGFydF90aW1lOiBcIjEyOjAwXCIsXHJcbiAgICAgICAgICBlbmRfdGltZTogXCIyMDowMFwiLFxyXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IGBkZWZhdWx0LW1hbGFtLSR7YnJhbmNoSWR9YCxcclxuICAgICAgICAgIGJyYW5jaF9pZDogYnJhbmNoSWQsXHJcbiAgICAgICAgICBzaGlmdF9uYW1lOiBcIlNoaWZ0IE1hbGFtXCIsXHJcbiAgICAgICAgICBzaGlmdF90eXBlOiBcIm1hbGFtXCIgYXMgY29uc3QsXHJcbiAgICAgICAgICBzdGFydF90aW1lOiBcIjIwOjAwXCIsXHJcbiAgICAgICAgICBlbmRfdGltZTogXCIwNDowMFwiLFxyXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoU2hpZnQoc2hpZnREYXRhOiBPbWl0PEJyYW5jaFNoaWZ0LCBcImlkXCIgfCBcImNyZWF0ZWRfYXRcIj4pIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gY3JlYXRlQnJhbmNoU2hpZnQgY2FsbGVkIHdpdGg6XCIsIHNoaWZ0RGF0YSlcclxuXHJcbiAgY29uc3Qgc2hpZnRUb0luc2VydCA9IHtcclxuICAgIC4uLnNoaWZ0RGF0YSxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJicmFuY2hfc2hpZnRzXCIpLmluc2VydChbc2hpZnRUb0luc2VydF0pLnNlbGVjdCgpLnNpbmdsZSgpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBDcmVhdGUgYnJhbmNoIHNoaWZ0IHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBGdW5nc2kgaGVscGVyIEF0dGVuZGFuY2VcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBob3RvVG9TdXBhYmFzZShiYXNlNjQ6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBmdW5jdGlvbiBiYXNlNjRUb0Jsb2IoYmFzZTY0RGF0YTogc3RyaW5nLCBjb250ZW50VHlwZSA9IFwiaW1hZ2UvanBlZ1wiKSB7XHJcbiAgICAgIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihiYXNlNjREYXRhLnNwbGl0KFwiLFwiKVsxXSlcclxuICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdXHJcbiAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IDUxMikge1xyXG4gICAgICAgIGNvbnN0IHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA1MTIpXHJcbiAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKVxyXG4gICAgICAgIGJ5dGVBcnJheXMucHVzaChuZXcgVWludDhBcnJheShieXRlTnVtYmVycykpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogY29udGVudFR5cGUgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBibG9iID0gYmFzZTY0VG9CbG9iKGJhc2U2NClcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2UuZnJvbShcImF0dGVuZGFuY2UtcGhvdG9zXCIpLnVwbG9hZChmaWxlbmFtZSwgYmxvYiwge1xyXG4gICAgICBjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxyXG4gICAgICB1cHNlcnQ6IHRydWUsXHJcbiAgICAgIGNvbnRlbnRUeXBlOiBcImltYWdlL2pwZWdcIixcclxuICAgIH0pXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiBwdWJsaWNVcmxEYXRhIH0gPSBzdXBhYmFzZS5zdG9yYWdlLmZyb20oXCJhdHRlbmRhbmNlLXBob3Rvc1wiKS5nZXRQdWJsaWNVcmwoZmlsZW5hbWUpXHJcbiAgICByZXR1cm4gcHVibGljVXJsRGF0YT8ucHVibGljVXJsIHx8IG51bGxcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlBob3RvIHVwbG9hZCBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBdHRlbmRhbmNlUmVjb3JkKGF0dGVuZGFuY2VEYXRhOiBQYXJ0aWFsPEF0dGVuZGFuY2U+KSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImF0dGVuZGFuY2VcIikuaW5zZXJ0KFthdHRlbmRhbmNlRGF0YV0pLnNlbGVjdCgpLnNpbmdsZSgpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVBdHRlbmRhbmNlUmVjb3JkKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8QXR0ZW5kYW5jZT4pIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAudXBkYXRlKHsgLi4udXBkYXRlcywgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXHJcbiAgICAuZXEoXCJpZFwiLCBpZClcclxuICAgIC5zZWxlY3QoKVxyXG4gICAgLnNpbmdsZSgpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBdHRlbmRhbmNlQnlEYXRlKHVzZXJJZDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYXR0ZW5kYW5jZVwiKS5zZWxlY3QoXCIqXCIpLmVxKFwidXNlcl9pZFwiLCB1c2VySWQpLmVxKFwiZGF0ZVwiLCBkYXRlKS5zaW5nbGUoKVxyXG4gIHJldHVybiBlcnJvciAmJiBlcnJvci5jb2RlICE9PSBcIlBHUlNUMTE2XCIgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEF0dGVuZGFuY2VSZWNvcmRzKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgLnNlbGVjdChgKixcclxuICAgICAgdXNlcnM6dXNlcl9pZCAoIGlkLCBuYW1lLCBlbWFpbCApLFxyXG4gICAgICBicmFuY2hlczpicmFuY2hfaWQgKCBpZCwgbmFtZSApXHJcbiAgICBgKVxyXG4gICAgLm9yZGVyKFwiZGF0ZVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgaWYgKGJyYW5jaElkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKVxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBGdW5nc2kgaGVscGVyIFBPU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmljZXNXaXRoQ2F0ZWdvcmllcygpIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJzZXJ2aWNlc1wiKVxyXG4gICAgLnNlbGVjdChgKixcclxuICAgIHNlcnZpY2VfY2F0ZWdvcmllcyAoIGlkLCBuYW1lLCBkZXNjcmlwdGlvbiApXHJcbiAgYClcclxuICAgIC5vcmRlcihcIm5hbWVcIilcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXJ2aWNlQ2F0ZWdvcmllcygpIHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwic2VydmljZV9jYXRlZ29yaWVzXCIpLnNlbGVjdChcIipcIikub3JkZXIoXCJuYW1lXCIpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25EYXRhOiBQYXJ0aWFsPFRyYW5zYWN0aW9uV2l0aEl0ZW1zPikge1xyXG4gIGNvbnN0IHRyYW5zYWN0aW9uTnVtYmVyID0gYXdhaXQgZ2VuZXJhdGVUcmFuc2FjdGlvbk51bWJlcigpXHJcbiAgbGV0IHsgY2FzaGllcl9pZCwgYnJhbmNoX2lkLCBzZXJ2ZXJfaWQgfSA9IHRyYW5zYWN0aW9uRGF0YVxyXG5cclxuICAvLyBHZXQgY2FzaGllciwgYnJhbmNoLCBzZXJ2ZXIgZGF0YSB1bnR1ayBzbmFwc2hvdFxyXG4gIGxldCBjYXNoaWVyTmFtZSA9ICdVbmtub3duJ1xyXG4gIGxldCBicmFuY2hOYW1lID0gJ1Vua25vd24nXHJcbiAgbGV0IHNlcnZlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG5cclxuICBpZiAoIWNhc2hpZXJfaWQpIHtcclxuICAgIGNvbnN0IHsgZGF0YTogdXNlcnMgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCJpZCwgbmFtZVwiKS5saW1pdCgxKS5zaW5nbGUoKVxyXG4gICAgY2FzaGllcl9pZCA9IHVzZXJzPy5pZFxyXG4gICAgY2FzaGllck5hbWUgPSB1c2Vycz8ubmFtZSB8fCAnVW5rbm93bidcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgeyBkYXRhOiBjYXNoaWVyIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuc2VsZWN0KFwibmFtZVwiKS5lcShcImlkXCIsIGNhc2hpZXJfaWQpLnNpbmdsZSgpXHJcbiAgICBjYXNoaWVyTmFtZSA9IGNhc2hpZXI/Lm5hbWUgfHwgJ1Vua25vd24nXHJcbiAgfVxyXG5cclxuICBpZiAoIWJyYW5jaF9pZCkge1xyXG4gICAgY29uc3QgeyBkYXRhOiBicmFuY2hlcyB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImJyYW5jaGVzXCIpLnNlbGVjdChcImlkLCBuYW1lXCIpLmxpbWl0KDEpLnNpbmdsZSgpXHJcbiAgICBicmFuY2hfaWQgPSBicmFuY2hlcz8uaWRcclxuICAgIGJyYW5jaE5hbWUgPSBicmFuY2hlcz8ubmFtZSB8fCAnVW5rbm93bidcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgeyBkYXRhOiBicmFuY2ggfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJicmFuY2hlc1wiKS5zZWxlY3QoXCJuYW1lXCIpLmVxKFwiaWRcIiwgYnJhbmNoX2lkKS5zaW5nbGUoKVxyXG4gICAgYnJhbmNoTmFtZSA9IGJyYW5jaD8ubmFtZSB8fCAnVW5rbm93bidcclxuICB9XHJcblxyXG4gIGlmIChzZXJ2ZXJfaWQpIHtcclxuICAgIGNvbnN0IHsgZGF0YTogc2VydmVyIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuc2VsZWN0KFwibmFtZVwiKS5lcShcImlkXCIsIHNlcnZlcl9pZCkuc2luZ2xlKClcclxuICAgIHNlcnZlck5hbWUgPSBzZXJ2ZXI/Lm5hbWVcclxuICB9XHJcblxyXG4gIGNvbnN0IHRyYW5zYWN0aW9uVG9JbnNlcnQgPSB7XHJcbiAgICAuLi50cmFuc2FjdGlvbkRhdGEsXHJcbiAgICB0cmFuc2FjdGlvbl9udW1iZXI6IHRyYW5zYWN0aW9uTnVtYmVyLFxyXG4gICAgcmVjZWlwdF9udW1iZXI6IHRyYW5zYWN0aW9uTnVtYmVyLFxyXG4gICAgY2FzaGllcl9pZCxcclxuICAgIGNhc2hpZXJfbmFtZTogY2FzaGllck5hbWUsXHJcbiAgICBicmFuY2hfaWQsXHJcbiAgICBicmFuY2hfbmFtZTogYnJhbmNoTmFtZSxcclxuICAgIHNlcnZlcl9pZCxcclxuICAgIHNlcnZlcl9uYW1lOiBzZXJ2ZXJOYW1lLFxyXG4gICAgc3VidG90YWw6IHRyYW5zYWN0aW9uRGF0YS5zdWJ0b3RhbCB8fCB0cmFuc2FjdGlvbkRhdGEudG90YWxfYW1vdW50IHx8IDAsXHJcbiAgICBwYXltZW50X3N0YXR1czogdHJhbnNhY3Rpb25EYXRhLnBheW1lbnRfc3RhdHVzIHx8IFwiY29tcGxldGVkXCIsXHJcbiAgICBwYXltZW50X21ldGhvZDogdHJhbnNhY3Rpb25EYXRhLnBheW1lbnRfbWV0aG9kIHx8IFwiY2FzaFwiLFxyXG4gICAgdG90YWxfYW1vdW50OiB0cmFuc2FjdGlvbkRhdGEudG90YWxfYW1vdW50IHx8IDAsXHJcbiAgICBkaXNjb3VudF9hbW91bnQ6IHRyYW5zYWN0aW9uRGF0YS5kaXNjb3VudF9hbW91bnQgfHwgMCxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJ0cmFuc2FjdGlvbnNcIikuaW5zZXJ0KFt0cmFuc2FjdGlvblRvSW5zZXJ0XSkuc2VsZWN0KCkuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uSXRlbXMoaXRlbXM6IFBhcnRpYWw8VHJhbnNhY3Rpb25JdGVtPltdKSB7XHJcbiAgLy8gRW5yaWNoIGl0ZW1zIGRlbmdhbiBzbmFwc2hvdCBkYXRhIGRhcmkgc2VydmljZXNcclxuICBjb25zdCBlbnJpY2hlZEl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtKSA9PiB7XHJcbiAgICBpZiAoaXRlbS5zZXJ2aWNlX2lkKSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogc2VydmljZSB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInNlcnZpY2VzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcIm5hbWUsIHR5cGUsIHNlcnZpY2VfY2F0ZWdvcmllcyhuYW1lKVwiKVxyXG4gICAgICAgIC5lcShcImlkXCIsIGl0ZW0uc2VydmljZV9pZClcclxuICAgICAgICAuc2luZ2xlKClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uaXRlbSxcclxuICAgICAgICBzZXJ2aWNlX25hbWU6IHNlcnZpY2U/Lm5hbWUgfHwgJ1Vua25vd24gU2VydmljZScsXHJcbiAgICAgICAgc2VydmljZV90eXBlOiBzZXJ2aWNlPy50eXBlLFxyXG4gICAgICAgIHNlcnZpY2VfY2F0ZWdvcnk6IEFycmF5LmlzQXJyYXkoc2VydmljZT8uc2VydmljZV9jYXRlZ29yaWVzKSBcclxuICAgICAgICAgID8gc2VydmljZS5zZXJ2aWNlX2NhdGVnb3JpZXNbMF0/Lm5hbWUgXHJcbiAgICAgICAgICA6IChzZXJ2aWNlPy5zZXJ2aWNlX2NhdGVnb3JpZXMgYXMgYW55KT8ubmFtZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlbVxyXG4gIH0pKVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidHJhbnNhY3Rpb25faXRlbXNcIikuaW5zZXJ0KGVucmljaGVkSXRlbXMpLnNlbGVjdCgpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVjZWlwdFRlbXBsYXRlKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UuZnJvbShcInJlY2VpcHRfdGVtcGxhdGVzXCIpLnNlbGVjdChcIipcIilcclxuICBpZiAoYnJhbmNoSWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnkuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgJiYgZXJyb3IuY29kZSAhPT0gXCJQR1JTVDExNlwiID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY3RpdmVSZWNlaXB0VGVtcGxhdGUoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICAvLyBQcmlvcml0eSAxOiBUcnkgdG8gZ2V0IGFjdGl2ZSB0ZW1wbGF0ZSAoaXNfYWN0aXZlID0gdHJ1ZSlcclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKFwicmVjZWlwdF90ZW1wbGF0ZXNcIikuc2VsZWN0KFwiKlwiKS5lcShcImlzX2FjdGl2ZVwiLCB0cnVlKVxyXG4gIGlmIChicmFuY2hJZCkgcXVlcnkgPSBxdWVyeS5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZClcclxuICBjb25zdCB7IGRhdGE6IGFjdGl2ZURhdGEsIGVycm9yOiBhY3RpdmVFcnJvciB9ID0gYXdhaXQgcXVlcnkuc2luZ2xlKClcclxuICBcclxuICBpZiAoYWN0aXZlRGF0YSAmJiAhYWN0aXZlRXJyb3IpIHtcclxuICAgIHJldHVybiB7IGRhdGE6IGFjdGl2ZURhdGEsIGVycm9yOiBudWxsIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gUHJpb3JpdHkgMjogSWYgbm8gYWN0aXZlIHRlbXBsYXRlLCBnZXQgZGVmYXVsdCB0ZW1wbGF0ZSAoaXNfZGVmYXVsdCA9IHRydWUpXHJcbiAgbGV0IGRlZmF1bHRRdWVyeSA9IHN1cGFiYXNlLmZyb20oXCJyZWNlaXB0X3RlbXBsYXRlc1wiKS5zZWxlY3QoXCIqXCIpLmVxKFwiaXNfZGVmYXVsdFwiLCB0cnVlKVxyXG4gIGlmIChicmFuY2hJZCkgZGVmYXVsdFF1ZXJ5ID0gZGVmYXVsdFF1ZXJ5LmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKVxyXG4gIGNvbnN0IHsgZGF0YTogZGVmYXVsdERhdGEsIGVycm9yOiBkZWZhdWx0RXJyb3IgfSA9IGF3YWl0IGRlZmF1bHRRdWVyeS5zaW5nbGUoKVxyXG4gIFxyXG4gIGlmIChkZWZhdWx0RGF0YSAmJiAhZGVmYXVsdEVycm9yKSB7XHJcbiAgICByZXR1cm4geyBkYXRhOiBkZWZhdWx0RGF0YSwgZXJyb3I6IG51bGwgfVxyXG4gIH1cclxuICBcclxuICAvLyBQcmlvcml0eSAzOiBGYWxsYmFjayB0byBhbnkgdGVtcGxhdGVcclxuICByZXR1cm4gYXdhaXQgZ2V0UmVjZWlwdFRlbXBsYXRlKGJyYW5jaElkKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJhbmNoZXMoKSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImJyYW5jaGVzXCIpLnNlbGVjdChcIipcIikub3JkZXIoXCJuYW1lXCIpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUcmFuc2FjdGlvbk51bWJlcigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoXCJnZW5lcmF0ZV9yZWNlaXB0X251bWJlclwiKVxyXG4gICAgaWYgKCFlcnJvciAmJiBkYXRhKSByZXR1cm4gZGF0YVxyXG5cclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxyXG4gICAgY29uc3QgZGF0ZVN0ciA9IHRvZGF5LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApLnJlcGxhY2UoLy0vZywgXCJcIilcclxuICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInRyYW5zYWN0aW9uc1wiKVxyXG4gICAgICAuc2VsZWN0KFwidHJhbnNhY3Rpb25fbnVtYmVyXCIpXHJcbiAgICAgIC5ndGUoXCJjcmVhdGVkX2F0XCIsIGAke3RvZGF5LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApfVQwMDowMDowMC4wMDBaYClcclxuICAgICAgLmx0KFwiY3JlYXRlZF9hdFwiLCBgJHt0b2RheS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKX1UMjM6NTk6NTkuOTk5WmApXHJcbiAgICBjb25zdCBjb3VudGVyID0gKHRyYW5zYWN0aW9ucz8ubGVuZ3RoIHx8IDApICsgMVxyXG4gICAgcmV0dXJuIGAke2RhdGVTdHJ9JHtjb3VudGVyLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgXCIwXCIpfWBcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBgJHtEYXRlLm5vdygpfWBcclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZ1bmdzaSBoZWxwZXIgU3RvY2sgTWFuYWdlbWVudFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tTZXJ2aWNlU3RvY2soc2VydmljZUlkOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJzZXJ2aWNlc1wiKS5zZWxlY3QoXCJzdG9ja1wiKS5lcShcImlkXCIsIHNlcnZpY2VJZCkuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyAwIDogZGF0YT8uc3RvY2sgfHwgMFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVkdWNlU2VydmljZVN0b2NrKHNlcnZpY2VJZDogc3RyaW5nLCBxdWFudGl0eTogbnVtYmVyKSB7XHJcbiAgY29uc3QgeyBkYXRhOiBjdXJyZW50U2VydmljZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInNlcnZpY2VzXCIpXHJcbiAgICAuc2VsZWN0KFwic3RvY2tcIilcclxuICAgIC5lcShcImlkXCIsIHNlcnZpY2VJZClcclxuICAgIC5zaW5nbGUoKVxyXG4gIGlmIChmZXRjaEVycm9yKSByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZmV0Y2hFcnJvciB9XHJcblxyXG4gIGNvbnN0IGN1cnJlbnRTdG9jayA9IGN1cnJlbnRTZXJ2aWNlLnN0b2NrIHx8IDBcclxuICBjb25zdCBuZXdTdG9jayA9IE1hdGgubWF4KDAsIGN1cnJlbnRTdG9jayAtIHF1YW50aXR5KVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJzZXJ2aWNlc1wiKVxyXG4gICAgLnVwZGF0ZSh7IHN0b2NrOiBuZXdTdG9jayB9KVxyXG4gICAgLmVxKFwiaWRcIiwgc2VydmljZUlkKVxyXG4gICAgLnNlbGVjdChcInN0b2NrXCIpXHJcbiAgICAuc2luZ2xlKClcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IG51bGwsIGVycm9yIH0gOiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVNlcnZpY2VTdG9jayhzZXJ2aWNlSWQ6IHN0cmluZywgbmV3U3RvY2s6IG51bWJlcikge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInNlcnZpY2VzXCIpXHJcbiAgICAudXBkYXRlKHsgc3RvY2s6IG5ld1N0b2NrLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgIC5lcShcImlkXCIsIHNlcnZpY2VJZClcclxuICAgIC5zZWxlY3QoKVxyXG4gICAgLnNpbmdsZSgpXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZ1bmdzaSBoZWxwZXIgUG9pbnRzIFN5c3RlbVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcnNXaXRoUG9pbnRzKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjFdIGdldFVzZXJzV2l0aFBvaW50cyBjYWxsZWQgd2l0aCBicmFuY2hJZDpcIiwgYnJhbmNoSWQpO1xyXG5cclxuICBsZXQgdXNlcnNRdWVyeSA9IHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCIqLCBicmFuY2hlczpicmFuY2hfaWQobmFtZSlcIikub3JkZXIoXCJuYW1lXCIpO1xyXG4gIGlmIChicmFuY2hJZCAmJiBicmFuY2hJZCAhPT0gXCJhbGxcIikge1xyXG4gICAgdXNlcnNRdWVyeSA9IHVzZXJzUXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhOiB1c2VycywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHVzZXJzUXVlcnk7XHJcbiAgaWYgKHVzZXJzRXJyb3IpIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogdXNlcnNFcnJvciB9O1xyXG4gIGlmICghdXNlcnMpIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG5cclxuICBjb25zdCB7IGRhdGE6IGFsbFBvaW50cywgZXJyb3I6IHBvaW50c0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJwb2ludHNcIilcclxuICAgIC5zZWxlY3QoXCJ1c2VyX2lkLCBwb2ludHNfZWFybmVkLCBjcmVhdGVkX2F0XCIpO1xyXG4gIGlmIChwb2ludHNFcnJvcikgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBwb2ludHNFcnJvciB9O1xyXG5cclxuICBjb25zdCB1c2Vyc1dpdGhDYWxjdWxhdGVkUG9pbnRzID0gdXNlcnMubWFwKCh1c2VyOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHVzZXJQb2ludHMgPSBhbGxQb2ludHM/LmZpbHRlcigocG9pbnQpID0+IHBvaW50LnVzZXJfaWQgPT09IHVzZXIuaWQpIHx8IFtdO1xyXG4gICAgY29uc3QgdG90YWxQb2ludHMgPSB1c2VyUG9pbnRzLnJlZHVjZSgoc3VtLCBwb2ludCkgPT4gc3VtICsgKHBvaW50LnBvaW50c19lYXJuZWQgfHwgMCksIDApO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkuZ2V0TW9udGgoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xyXG5cclxuICAgIGNvbnN0IG1vbnRobHlQb2ludHMgPSB1c2VyUG9pbnRzLnJlZHVjZSgoc3VtLCBwb2ludCkgPT4ge1xyXG4gICAgICBjb25zdCBwb2ludERhdGUgPSBuZXcgRGF0ZShwb2ludC5jcmVhdGVkX2F0KTtcclxuICAgICAgaWYgKHBvaW50RGF0ZS5nZXRNb250aCgpID09PSBjdXJyZW50TW9udGggJiYgcG9pbnREYXRlLmdldEZ1bGxZZWFyKCkgPT09IGN1cnJlbnRZZWFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1bSArIChwb2ludC5wb2ludHNfZWFybmVkIHx8IDApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9LCAwKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi51c2VyLFxyXG4gICAgICB0b3RhbF9wb2ludHM6IHRvdGFsUG9pbnRzLFxyXG4gICAgICBtb250aGx5X3BvaW50czogbW9udGhseVBvaW50cyxcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHNvcnRlZFVzZXJzID0gdXNlcnNXaXRoQ2FsY3VsYXRlZFBvaW50c1xyXG4gICAgLnNvcnQoKGEsIGIpID0+IChiLnRvdGFsX3BvaW50cyB8fCAwKSAtIChhLnRvdGFsX3BvaW50cyB8fCAwKSlcclxuICAgIC5tYXAoKHVzZXIsIGluZGV4KSA9PiAoe1xyXG4gICAgICAuLi51c2VyLFxyXG4gICAgICByYW5rOiBpbmRleCArIDEsXHJcbiAgICB9KSk7XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YxXSBGaW5hbCBzb3J0ZWQgdXNlcnM6XCIsIHNvcnRlZFVzZXJzKTtcclxuICByZXR1cm4geyBkYXRhOiBzb3J0ZWRVc2VycywgZXJyb3I6IG51bGwgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBvaW50c1N0YXRpc3RpY3MoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBjb25zdCB7IGRhdGE6IHVzZXJzLCBlcnJvciB9ID0gYXdhaXQgZ2V0VXNlcnNXaXRoUG9pbnRzKGJyYW5jaElkKVxyXG5cclxuICBpZiAoZXJyb3IpIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cclxuXHJcbiAgY29uc3QgdG90YWxFbXBsb3llZXMgPSB1c2Vycy5sZW5ndGhcclxuICBjb25zdCB0b3BQZXJmb3JtZXIgPSB1c2Vyc1swXSB8fCBudWxsXHJcbiAgY29uc3QgdG90YWxQb2ludHMgPSB1c2Vycy5yZWR1Y2UoKHN1bSwgdXNlcikgPT4gc3VtICsgKHVzZXIudG90YWxfcG9pbnRzIHx8IDApLCAwKVxyXG4gIGNvbnN0IGF2ZXJhZ2VQb2ludHMgPSB0b3RhbEVtcGxveWVlcyA+IDAgPyBNYXRoLnJvdW5kKHRvdGFsUG9pbnRzIC8gdG90YWxFbXBsb3llZXMpIDogMFxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZGF0YToge1xyXG4gICAgICB0b3RhbEVtcGxveWVlcyxcclxuICAgICAgdG9wUGVyZm9ybWVyLFxyXG4gICAgICBhdmVyYWdlUG9pbnRzLFxyXG4gICAgICB0b3RhbFBvaW50cyxcclxuICAgIH0sXHJcbiAgICBlcnJvcjogbnVsbCxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb2ludFRyYW5zYWN0aW9ucyhicmFuY2hJZD86IHN0cmluZywgbGltaXQgPSA1MCkge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YzIEZpbmFsXSBnZXRQb2ludFRyYW5zYWN0aW9ucyBjYWxsZWQgd2l0aCBicmFuY2hJZDpcIiwgYnJhbmNoSWQpO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRmlyc3QsIGdldCBwb2ludCB0cmFuc2FjdGlvbnNcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwicG9pbnRzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgIC5saW1pdChsaW1pdCk7XHJcblxyXG4gICAgaWYgKGJyYW5jaElkICYmIGJyYW5jaElkICE9PSBcImFsbFwiKSB7XHJcbiAgICAgIC8vIEZpbHRlciBieSB1c2VyJ3MgYnJhbmNoX2lkXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlcnNJbkJyYW5jaCwgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAgIC5zZWxlY3QoXCJpZFwiKVxyXG4gICAgICAgIC5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VycyBpbiBicmFuY2g6XCIsIHVzZXJzRXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogdXNlcnNFcnJvciB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodXNlcnNJbkJyYW5jaCAmJiB1c2Vyc0luQnJhbmNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB1c2VySWRzID0gdXNlcnNJbkJyYW5jaC5tYXAodSA9PiB1LmlkKTtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmluKFwidXNlcl9pZFwiLCB1c2VySWRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBObyB1c2VycyBpbiB0aGlzIGJyYW5jaCwgcmV0dXJuIGVtcHR5XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJObyB1c2VycyBmb3VuZCBpbiBicmFuY2g6XCIsIGJyYW5jaElkKTtcclxuICAgICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogcG9pbnRzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcG9pbnQgdHJhbnNhY3Rpb25zOlwiLCBlcnJvcik7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXRhaWxzOlwiLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29kZTpcIiwgZXJyb3IuY29kZSk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBtZXNzYWdlOlwiLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwb2ludHNEYXRhIHx8IHBvaW50c0RhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gcG9pbnQgdHJhbnNhY3Rpb25zIGZvdW5kXCIpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdXNlciBkZXRhaWxzIGZvciBhbGwgcG9pbnRzXHJcbiAgICBjb25zdCB1c2VySWRzID0gWy4uLm5ldyBTZXQocG9pbnRzRGF0YS5tYXAocCA9PiBwLnVzZXJfaWQpLmZpbHRlcihCb29sZWFuKSldO1xyXG4gICAgbGV0IHVzZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgICBcclxuICAgIGlmICh1c2VySWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImlkLCBuYW1lLCBicmFuY2hfaWRcIilcclxuICAgICAgICAuaW4oXCJpZFwiLCB1c2VySWRzKTtcclxuICAgICAgXHJcbiAgICAgIGlmICh1c2Vycykge1xyXG4gICAgICAgIHVzZXJzTWFwID0gdXNlcnMucmVkdWNlKChhY2MsIHUpID0+ICh7IC4uLmFjYywgW3UuaWRdOiB1IH0pLCB7fSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgYWxsIHVuaXF1ZSBicmFuY2hfaWRzXHJcbiAgICBjb25zdCBicmFuY2hJZHMgPSBbLi4ubmV3IFNldChPYmplY3QudmFsdWVzKHVzZXJzTWFwKS5tYXAoKHU6IGFueSkgPT4gdS5icmFuY2hfaWQpLmZpbHRlcihCb29sZWFuKSldO1xyXG4gICAgXHJcbiAgICAvLyBGZXRjaCBicmFuY2ggZGV0YWlsc1xyXG4gICAgbGV0IGJyYW5jaGVzTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgICBpZiAoYnJhbmNoSWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgeyBkYXRhOiBicmFuY2hlcyB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcImJyYW5jaGVzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImlkLCBuYW1lXCIpXHJcbiAgICAgICAgLmluKFwiaWRcIiwgYnJhbmNoSWRzKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChicmFuY2hlcykge1xyXG4gICAgICAgIGJyYW5jaGVzTWFwID0gYnJhbmNoZXMucmVkdWNlKChhY2MsIGIpID0+ICh7IC4uLmFjYywgW2IuaWRdOiBiIH0pLCB7fSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNZXJnZSB1c2VyIGFuZCBicmFuY2ggaW5mbyBpbnRvIHBvaW50c1xyXG4gICAgY29uc3QgZW5yaWNoZWREYXRhID0gcG9pbnRzRGF0YT8ubWFwKHBvaW50ID0+ICh7XHJcbiAgICAgIC4uLnBvaW50LFxyXG4gICAgICB1c2VyczogcG9pbnQudXNlcl9pZCA/IHtcclxuICAgICAgICAuLi51c2Vyc01hcFtwb2ludC51c2VyX2lkXSxcclxuICAgICAgICBicmFuY2hlczogdXNlcnNNYXBbcG9pbnQudXNlcl9pZF0/LmJyYW5jaF9pZCA/IGJyYW5jaGVzTWFwW3VzZXJzTWFwW3BvaW50LnVzZXJfaWRdLmJyYW5jaF9pZF0gOiBudWxsXHJcbiAgICAgIH0gOiBudWxsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJQb2ludCB0cmFuc2FjdGlvbnMgZmV0Y2hlZCBzdWNjZXNzZnVsbHk6XCIsIGVucmljaGVkRGF0YT8ubGVuZ3RoIHx8IDAsIFwicmVjb3Jkc1wiKTtcclxuICAgIHJldHVybiB7IGRhdGE6IGVucmljaGVkRGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0UG9pbnRUcmFuc2FjdGlvbnM6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogZXJyb3IgYXMgYW55IH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUG9pbnRUcmFuc2FjdGlvbihwb2ludERhdGE6IHtcclxuICB1c2VyX2lkOiBzdHJpbmdcclxuICBwb2ludHM6IG51bWJlclxyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICB0eXBlOiBcImVhcm5lZFwiIHwgXCJkZWR1Y3RlZFwiIHwgXCJib251c1wiIHwgXCJwZW5hbHR5XCJcclxufSkge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInBvaW50c1wiKVxyXG4gICAgLmluc2VydChbXHJcbiAgICAgIHtcclxuICAgICAgICAuLi5wb2ludERhdGEsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9LFxyXG4gICAgXSlcclxuICAgIC5zZWxlY3QoKVxyXG4gICAgLnNpbmdsZSgpXHJcblxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclBvaW50cyh1c2VySWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInBvaW50c1wiKVxyXG4gICAgLnNlbGVjdChcIipcIilcclxuICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxyXG4gICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBbXSwgZXJyb3IgfSA6IHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBLYXNib24gRnVuY3Rpb25zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRLYXNib25SZXF1ZXN0cyhicmFuY2hJZD86IHN0cmluZywgc3RhdHVzRmlsdGVyPzogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGdldEthc2JvblJlcXVlc3RzIGNhbGxlZCB3aXRoOlwiLCB7IGJyYW5jaElkLCBzdGF0dXNGaWx0ZXIgfSlcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEZpcnN0LCBnZXQga2FzYm9uIHJlcXVlc3RzXHJcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImthc2JvblwiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICAgIGlmIChicmFuY2hJZCAmJiBicmFuY2hJZCAhPT0gXCJhbGxcIikge1xyXG4gICAgICAvLyBGaWx0ZXIgYnkgdXNlcidzIGJyYW5jaF9pZFxyXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJzSW5CcmFuY2gsIGVycm9yOiB1c2Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWRcIilcclxuICAgICAgICAuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlcnMgaW4gYnJhbmNoOlwiLCB1c2Vyc0Vycm9yKTtcclxuICAgICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IHVzZXJzRXJyb3IgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzSW5CcmFuY2ggJiYgdXNlcnNJbkJyYW5jaC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgdXNlcklkcyA9IHVzZXJzSW5CcmFuY2gubWFwKHUgPT4gdS5pZCk7XHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5pbihcInVzZXJfaWRcIiwgdXNlcklkcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJObyB1c2VycyBmb3VuZCBpbiBicmFuY2g6XCIsIGJyYW5jaElkKTtcclxuICAgICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0dXNGaWx0ZXIgJiYgc3RhdHVzRmlsdGVyICE9PSBcImFsbFwiKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoXCJzdGF0dXNcIiwgc3RhdHVzRmlsdGVyKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YToga2FzYm9uRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEthc2JvbiByZXF1ZXN0cyBlcnJvcjpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrYXNib25EYXRhIHx8IGthc2JvbkRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBObyBrYXNib24gcmVxdWVzdHMgZm91bmRcIilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBudWxsIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdXNlciBkZXRhaWxzXHJcbiAgICBjb25zdCB1c2VySWRzID0gWy4uLm5ldyBTZXQoa2FzYm9uRGF0YS5tYXAoayA9PiBrLnVzZXJfaWQpLmZpbHRlcihCb29sZWFuKSldO1xyXG4gICAgbGV0IHVzZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgICBcclxuICAgIGlmICh1c2VySWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImlkLCBuYW1lLCBlbWFpbCwgcG9zaXRpb24sIGJyYW5jaF9pZFwiKVxyXG4gICAgICAgIC5pbihcImlkXCIsIHVzZXJJZHMpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzKSB7XHJcbiAgICAgICAgdXNlcnNNYXAgPSB1c2Vycy5yZWR1Y2UoKGFjYywgdSkgPT4gKHsgLi4uYWNjLCBbdS5pZF06IHUgfSksIHt9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBhcHByb3ZlciBkZXRhaWxzXHJcbiAgICBjb25zdCBhcHByb3ZlcklkcyA9IFsuLi5uZXcgU2V0KGthc2JvbkRhdGEubWFwKGsgPT4gay5hcHByb3ZlZF9ieSkuZmlsdGVyKEJvb2xlYW4pKV07XHJcbiAgICBsZXQgYXBwcm92ZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgICBcclxuICAgIGlmIChhcHByb3Zlcklkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXBwcm92ZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWQsIG5hbWVcIilcclxuICAgICAgICAuaW4oXCJpZFwiLCBhcHByb3Zlcklkcyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoYXBwcm92ZXJzKSB7XHJcbiAgICAgICAgYXBwcm92ZXJzTWFwID0gYXBwcm92ZXJzLnJlZHVjZSgoYWNjLCB1KSA9PiAoeyAuLi5hY2MsIFt1LmlkXTogdSB9KSwge30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWVyZ2UgdXNlciBhbmQgYXBwcm92ZXIgaW5mb1xyXG4gICAgY29uc3QgZW5yaWNoZWREYXRhID0ga2FzYm9uRGF0YS5tYXAoa2FzYm9uID0+ICh7XHJcbiAgICAgIC4uLmthc2JvbixcclxuICAgICAgdXNlcjoga2FzYm9uLnVzZXJfaWQgPyB1c2Vyc01hcFtrYXNib24udXNlcl9pZF0gOiBudWxsLFxyXG4gICAgICBhcHByb3Zlcjoga2FzYm9uLmFwcHJvdmVkX2J5ID8gYXBwcm92ZXJzTWFwW2thc2Jvbi5hcHByb3ZlZF9ieV0gOiBudWxsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEthc2JvbiByZXF1ZXN0cyByZXN1bHQ6XCIsIGVucmljaGVkRGF0YT8ubGVuZ3RoIHx8IDAsIFwicmVjb3Jkc1wiKVxyXG4gICAgcmV0dXJuIHsgZGF0YTogZW5yaWNoZWREYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIFVuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0S2FzYm9uUmVxdWVzdHM6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogZXJyb3IgYXMgYW55IH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0S2FzYm9uU3RhdGlzdGljcyhicmFuY2hJZD86IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBnZXRLYXNib25TdGF0aXN0aWNzIGNhbGxlZCB3aXRoIGJyYW5jaElkOlwiLCBicmFuY2hJZClcclxuXHJcbiAgdHJ5IHtcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oXCJrYXNib25cIikuc2VsZWN0KFwiYW1vdW50LCBzdGF0dXMsIHVzZXJfaWRcIilcclxuXHJcbiAgICBpZiAoYnJhbmNoSWQgJiYgYnJhbmNoSWQgIT09IFwiYWxsXCIpIHtcclxuICAgICAgLy8gRmlsdGVyIGJ5IHVzZXIncyBicmFuY2hfaWRcclxuICAgICAgY29uc3QgeyBkYXRhOiB1c2Vyc0luQnJhbmNoLCBlcnJvcjogdXNlcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgICAgLnNlbGVjdChcImlkXCIpXHJcbiAgICAgICAgLmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKTtcclxuICAgICAgXHJcbiAgICAgIGlmICh1c2Vyc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHVzZXJzIGluIGJyYW5jaDpcIiwgdXNlcnNFcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgICAgICAgYXBwcm92ZWRBbW91bnQ6IDAsXHJcbiAgICAgICAgICAgIHRvdGFsUGFpZDogMCxcclxuICAgICAgICAgICAgYWN0aXZlRW1wbG95ZWVzOiAwLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiB1c2Vyc0Vycm9yLFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzSW5CcmFuY2ggJiYgdXNlcnNJbkJyYW5jaC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgdXNlcklkcyA9IHVzZXJzSW5CcmFuY2gubWFwKHUgPT4gdS5pZCk7XHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5pbihcInVzZXJfaWRcIiwgdXNlcklkcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgICAgICAgYXBwcm92ZWRBbW91bnQ6IDAsXHJcbiAgICAgICAgICAgIHRvdGFsUGFpZDogMCxcclxuICAgICAgICAgICAgYWN0aXZlRW1wbG95ZWVzOiAwLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBFcnJvciBmZXRjaGluZyBrYXNib24gc3RhdGlzdGljczpcIiwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgICAgIGFwcHJvdmVkQW1vdW50OiAwLFxyXG4gICAgICAgICAgdG90YWxQYWlkOiAwLFxyXG4gICAgICAgICAgYWN0aXZlRW1wbG95ZWVzOiAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwZW5kaW5nQW1vdW50ID0gZGF0YT8uZmlsdGVyKChrKSA9PiBrLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpLnJlZHVjZSgoc3VtLCBrKSA9PiBzdW0gKyAoay5hbW91bnQgfHwgMCksIDApIHx8IDBcclxuICAgIGNvbnN0IGFwcHJvdmVkQW1vdW50ID0gZGF0YT8uZmlsdGVyKChrKSA9PiBrLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiKS5yZWR1Y2UoKHN1bSwgaykgPT4gc3VtICsgKGsuYW1vdW50IHx8IDApLCAwKSB8fCAwXHJcbiAgICBjb25zdCB0b3RhbFBhaWQgPSBkYXRhPy5maWx0ZXIoKGspID0+IGsuc3RhdHVzID09PSBcInBhaWRcIikucmVkdWNlKChzdW0sIGspID0+IHN1bSArIChrLmFtb3VudCB8fCAwKSwgMCkgfHwgMFxyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogdXNlcnNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuc2VsZWN0KFwiaWRcIikuZXEoXCJzdGF0dXNcIiwgXCJhY3RpdmVcIilcclxuICAgIGNvbnN0IGFjdGl2ZUVtcGxveWVlcyA9IHVzZXJzRGF0YT8ubGVuZ3RoIHx8IDBcclxuXHJcbiAgICBjb25zdCBzdGF0aXN0aWNzID0ge1xyXG4gICAgICBwZW5kaW5nQW1vdW50LFxyXG4gICAgICBhcHByb3ZlZEFtb3VudCxcclxuICAgICAgdG90YWxQYWlkLFxyXG4gICAgICBhY3RpdmVFbXBsb3llZXMsXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEthc2JvbiBzdGF0aXN0aWNzIHJlc3VsdDpcIiwgc3RhdGlzdGljcylcclxuICAgIHJldHVybiB7IGRhdGE6IHN0YXRpc3RpY3MsIGVycm9yOiBudWxsIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gVW5leHBlY3RlZCBlcnJvciBpbiBnZXRLYXNib25TdGF0aXN0aWNzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgICBhcHByb3ZlZEFtb3VudDogMCxcclxuICAgICAgICB0b3RhbFBhaWQ6IDAsXHJcbiAgICAgICAgYWN0aXZlRW1wbG95ZWVzOiAwLFxyXG4gICAgICB9LFxyXG4gICAgICBlcnJvcjogZXJyb3IgYXMgYW55LFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJzV2l0aEthc2JvbihicmFuY2hJZD86IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBnZXRVc2Vyc1dpdGhLYXNib24gY2FsbGVkIHdpdGggYnJhbmNoSWQ6XCIsIGJyYW5jaElkKVxyXG5cclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuc2VsZWN0KFwiKlwiKS5vcmRlcihcIm5hbWVcIilcclxuXHJcbiAgaWYgKGJyYW5jaElkICYmIGJyYW5jaElkICE9PSBcImFsbFwiKSB7XHJcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKFwiYnJhbmNoX2lkXCIsIGJyYW5jaElkKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhOiB1c2VycywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gIGlmICh1c2Vyc0Vycm9yKSByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IHVzZXJzRXJyb3IgfVxyXG5cclxuICBjb25zdCB7IGRhdGE6IGFsbEthc2JvbiwgZXJyb3I6IGthc2JvbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJrYXNib25cIilcclxuICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICBpZiAoa2FzYm9uRXJyb3IpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBLYXNib24gZXJyb3IsIHJldHVybmluZyB1c2VycyB3aXRob3V0IGthc2JvbiBkYXRhOlwiLCBrYXNib25FcnJvcilcclxuICAgIGNvbnN0IHVzZXJzV2l0aG91dEthc2JvbiA9XHJcbiAgICAgIHVzZXJzPy5tYXAoKHVzZXI6IGFueSkgPT4gKHtcclxuICAgICAgICAuLi51c2VyLFxyXG4gICAgICAgIHRvdGFsX2thc2JvbjogMCxcclxuICAgICAgICBhY3RpdmVfa2FzYm9uOiAwLFxyXG4gICAgICAgIGthc2Jvbl9oaXN0b3J5OiBbXSxcclxuICAgICAgfSkpIHx8IFtdXHJcbiAgICByZXR1cm4geyBkYXRhOiB1c2Vyc1dpdGhvdXRLYXNib24sIGVycm9yOiBudWxsIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHVzZXJzV2l0aEthc2JvbkRhdGEgPVxyXG4gICAgdXNlcnM/Lm1hcCgodXNlcjogYW55KSA9PiB7XHJcbiAgICAgIGNvbnN0IHVzZXJLYXNib24gPSBhbGxLYXNib24/LmZpbHRlcigoa2FzYm9uOiBhbnkpID0+IGthc2Jvbi51c2VyX2lkID09PSB1c2VyLmlkKSB8fCBbXVxyXG4gICAgICBjb25zdCB0b3RhbEthc2JvbiA9IHVzZXJLYXNib24ucmVkdWNlKChzdW06IG51bWJlciwga2FzYm9uOiBhbnkpID0+IHN1bSArIChrYXNib24uYW1vdW50IHx8IDApLCAwKVxyXG4gICAgICBjb25zdCBhY3RpdmVLYXNib24gPSB1c2VyS2FzYm9uXHJcbiAgICAgICAgLmZpbHRlcigoa2FzYm9uOiBhbnkpID0+IGthc2Jvbi5zdGF0dXMgPT09IFwiYXBwcm92ZWRcIiB8fCBrYXNib24uc3RhdHVzID09PSBcInBlbmRpbmdcIilcclxuICAgICAgICAucmVkdWNlKChzdW06IG51bWJlciwga2FzYm9uOiBhbnkpID0+IHN1bSArIChrYXNib24uYW1vdW50IHx8IDApLCAwKVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi51c2VyLFxyXG4gICAgICAgIHRvdGFsX2thc2JvbjogdG90YWxLYXNib24sXHJcbiAgICAgICAgYWN0aXZlX2thc2JvbjogYWN0aXZlS2FzYm9uLFxyXG4gICAgICAgIGthc2Jvbl9oaXN0b3J5OiB1c2VyS2FzYm9uLFxyXG4gICAgICB9XHJcbiAgICB9KSB8fCBbXVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gVXNlcnMgd2l0aCBrYXNib24gZGF0YTpcIiwgdXNlcnNXaXRoS2FzYm9uRGF0YSlcclxuICByZXR1cm4geyBkYXRhOiB1c2Vyc1dpdGhLYXNib25EYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVLYXNib25SZXF1ZXN0KGthc2JvbkRhdGE6IHtcclxuICB1c2VyX2lkOiBzdHJpbmdcclxuICBhbW91bnQ6IG51bWJlclxyXG4gIHJlYXNvbjogc3RyaW5nXHJcbiAgZHVlX2RhdGU/OiBzdHJpbmdcclxuICBub3Rlcz86IHN0cmluZ1xyXG59KSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGNyZWF0ZUthc2JvblJlcXVlc3QgY2FsbGVkIHdpdGg6XCIsIGthc2JvbkRhdGEpXHJcblxyXG4gIC8vIEdldCB1c2VyIG5hbWUgZm9yIHNuYXBzaG90XHJcbiAgY29uc3QgeyBkYXRhOiB1c2VyLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgLnNlbGVjdChcIm5hbWVcIilcclxuICAgIC5lcShcImlkXCIsIGthc2JvbkRhdGEudXNlcl9pZClcclxuICAgIC5zaW5nbGUoKVxyXG5cclxuICBpZiAodXNlckVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZUthc2JvblJlcXVlc3RdIEVycm9yIGdldHRpbmcgdXNlciBuYW1lOlwiLCB1c2VyRXJyb3IpXHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGthc2JvblRvSW5zZXJ0ID0ge1xyXG4gICAgLi4ua2FzYm9uRGF0YSxcclxuICAgIHVzZXJfbmFtZTogdXNlcj8ubmFtZSB8fCBcIlVua25vd25cIixcclxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIgYXMgY29uc3QsXHJcbiAgICByZXF1ZXN0X2RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJrYXNib25cIikuaW5zZXJ0KFtrYXNib25Ub0luc2VydF0pLnNlbGVjdCgpLnNpbmdsZSgpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBDcmVhdGUga2FzYm9uIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlS2FzYm9uU3RhdHVzKFxyXG4gIGthc2JvbklkOiBzdHJpbmcsXHJcbiAgc3RhdHVzOiBcImFwcHJvdmVkXCIgfCBcInJlamVjdGVkXCIgfCBcInBhaWRcIixcclxuICBhcHByb3ZlZEJ5OiBzdHJpbmcsXHJcbikge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSB1cGRhdGVLYXNib25TdGF0dXMgY2FsbGVkIHdpdGg6XCIsIHsga2FzYm9uSWQsIHN0YXR1cywgYXBwcm92ZWRCeSB9KVxyXG5cclxuICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XHJcbiAgICBzdGF0dXMsXHJcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfVxyXG5cclxuICBpZiAoc3RhdHVzID09PSBcImFwcHJvdmVkXCIpIHtcclxuICAgIHVwZGF0ZURhdGEuYXBwcm92ZWRfYnkgPSBhcHByb3ZlZEJ5XHJcbiAgICB1cGRhdGVEYXRhLmFwcHJvdmVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwia2FzYm9uXCIpLnVwZGF0ZSh1cGRhdGVEYXRhKS5lcShcImlkXCIsIGthc2JvbklkKS5zZWxlY3QoKS5zaW5nbGUoKVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gVXBkYXRlIGthc2JvbiBzdGF0dXMgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEVtcGxveWVlIE1hbmFnZW1lbnQgSW50ZXJmYWNlc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgaW50ZXJmYWNlIEVtcGxveWVlIHtcclxuICB0b3RhbEJvbnVzOiBudW1iZXJcclxuICB0b3RhbFBlbmFsdHk6IG51bWJlclxyXG4gIGlkOiBzdHJpbmdcclxuICBuYW1lOiBzdHJpbmdcclxuICBlbWFpbDogc3RyaW5nXHJcbiAgcGhvbmU/OiBzdHJpbmdcclxuICBwb3NpdGlvbj86IHN0cmluZ1xyXG4gIHN0YXR1cz86IHN0cmluZ1xyXG4gIGF2YXRhcj86IHN0cmluZ1xyXG4gIHJhdGluZz86IG51bWJlclxyXG4gIGJhc2VTYWxhcnk/OiBudW1iZXJcclxuICBhdHRlbmRhbmNlUmF0ZT86IG51bWJlclxyXG4gIGN1cnJlbnRNb250aEN1c3RvbWVycz86IG51bWJlclxyXG4gIHRvdGFsQ3VzdG9tZXJzPzogbnVtYmVyXHJcbiAgcHJlc2VudERheXM/OiBudW1iZXJcclxuICB0b3RhbFdvcmtEYXlzPzogbnVtYmVyXHJcbiAgbGF0ZURheXM/OiBudW1iZXJcclxuICBvdmVydGltZUhvdXJzPzogbnVtYmVyXHJcbiAgb3ZlcnRpbWVSYXRlPzogbnVtYmVyXHJcbiAgYm9udXNQb2ludHM/OiBudW1iZXJcclxuICBwZW5hbHR5UG9pbnRzPzogbnVtYmVyXHJcbiAgY29tbWlzc2lvblJhdGU/OiBudW1iZXJcclxuICBqb2luRGF0ZT86IHN0cmluZ1xyXG4gIGthc2JvbkJhbGFuY2U/OiBudW1iZXJcclxuICBrYXNib25MaW1pdD86IG51bWJlclxyXG4gIG1vbnRobHlSZXZlbnVlPzogc3RyaW5nXHJcbiAgcGluPzogc3RyaW5nXHJcbiAgbWF4X2Fic2VudF9kYXlzPzogbnVtYmVyXHJcbiAgY3VycmVudF9hYnNlbnRfZGF5cz86IG51bWJlclxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBGVU5HU0kgU0VERVJIQU5BOiBISVRVTkcgSEFSSSBUSURBSyBIQURJUlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW1wbG95ZWVBYnNlbmNlSW5mbyhlbXBsb3llZUlkOiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIltTSU1QTEVdIGdldEVtcGxveWVlQWJzZW5jZUluZm8gY2FsbGVkIGZvcjpcIiwgZW1wbG95ZWVJZCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyAxLiBHZXQgZW1wbG95ZWUgZGF0YSB0ZXJtYXN1ayBzZXR0aW5nYW4gbGlidXJcclxuICAgIGNvbnN0IHsgZGF0YTogZW1wbG95ZWUsIGVycm9yOiBlbXBFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwibWF4X2Fic2VudF9kYXlzXCIpXHJcbiAgICAgIC5lcShcImlkXCIsIGVtcGxveWVlSWQpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZW1wRXJyb3IgfHwgIWVtcGxveWVlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGVtcGxveWVlOlwiLCBlbXBFcnJvcik7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIG1heEFic2VudERheXM6IDQsIFxyXG4gICAgICAgIGN1cnJlbnRBYnNlbnREYXlzOiAwLCBcclxuICAgICAgICByZW1haW5pbmdEYXlzOiA0LFxyXG4gICAgICAgIGV4Y2Vzc0RheXM6IDAgXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMi4gSGl0dW5nIGhhcmkgdGlkYWsgaGFkaXIgYnVsYW4gaW5pXHJcbiAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZShjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpLCAxKTtcclxuICAgIGNvbnN0IGxhc3REYXlPZk1vbnRoID0gbmV3IERhdGUoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSwgY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDEsIDApO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogYXR0ZW5kYW5jZURhdGEsIGVycm9yOiBhdHRlbmRhbmNlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgICAuc2VsZWN0KFwic3RhdHVzLCBkYXRlXCIpXHJcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgLmd0ZShcImRhdGVcIiwgZmlyc3REYXlPZk1vbnRoLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSlcclxuICAgICAgLmx0ZShcImRhdGVcIiwgbGFzdERheU9mTW9udGgudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKTtcclxuXHJcbiAgICBpZiAoYXR0ZW5kYW5jZUVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGF0dGVuZGFuY2UgZGF0YTpcIiwgYXR0ZW5kYW5jZUVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgbWF4QWJzZW50RGF5czogZW1wbG95ZWUubWF4X2Fic2VudF9kYXlzIHx8IDQsIFxyXG4gICAgICAgIGN1cnJlbnRBYnNlbnREYXlzOiAwLCBcclxuICAgICAgICByZW1haW5pbmdEYXlzOiBlbXBsb3llZS5tYXhfYWJzZW50X2RheXMgfHwgNCxcclxuICAgICAgICBleGNlc3NEYXlzOiAwIFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpdHVuZyBoYXJpIHRpZGFrIGhhZGlyIChzdGF0dXMgYWJzZW50IGF0YXUgdGlkYWsgYWRhIGRhdGEgYXR0ZW5kYW5jZSlcclxuICAgIGNvbnN0IGN1cnJlbnRBYnNlbnREYXlzID0gYXR0ZW5kYW5jZURhdGE/LmZpbHRlcihyZWNvcmQgPT4gXHJcbiAgICAgIHJlY29yZC5zdGF0dXMgPT09IFwiYWJzZW50XCIgfHwgcmVjb3JkLnN0YXR1cyA9PT0gbnVsbFxyXG4gICAgKS5sZW5ndGggfHwgMDtcclxuXHJcbiAgICBjb25zdCBtYXhBYnNlbnREYXlzID0gZW1wbG95ZWUubWF4X2Fic2VudF9kYXlzIHx8IDQ7XHJcbiAgICBjb25zdCByZW1haW5pbmdEYXlzID0gTWF0aC5tYXgoMCwgbWF4QWJzZW50RGF5cyAtIGN1cnJlbnRBYnNlbnREYXlzKTtcclxuICAgIGNvbnN0IGV4Y2Vzc0RheXMgPSBNYXRoLm1heCgwLCBjdXJyZW50QWJzZW50RGF5cyAtIG1heEFic2VudERheXMpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW1NJTVBMRV0gQWJzZW5jZSBpbmZvOlwiLCB7IFxyXG4gICAgICBtYXhBYnNlbnREYXlzLCBcclxuICAgICAgY3VycmVudEFic2VudERheXMsIFxyXG4gICAgICByZW1haW5pbmdEYXlzLCBcclxuICAgICAgZXhjZXNzRGF5cyBcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7IFxyXG4gICAgICBtYXhBYnNlbnREYXlzLCBcclxuICAgICAgY3VycmVudEFic2VudERheXMsIFxyXG4gICAgICByZW1haW5pbmdEYXlzLCBcclxuICAgICAgZXhjZXNzRGF5cyBcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2V0RW1wbG95ZWVBYnNlbmNlSW5mbzpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIG1heEFic2VudERheXM6IDQsIFxyXG4gICAgICBjdXJyZW50QWJzZW50RGF5czogMCwgXHJcbiAgICAgIHJlbWFpbmluZ0RheXM6IDQsXHJcbiAgICAgIGV4Y2Vzc0RheXM6IDAgXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRlVOR1NJIFVQREFURSBKVU1MQUggSEFSSSBMSUJVUlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTWF4QWJzZW50RGF5cyhlbXBsb3llZUlkOiBzdHJpbmcsIG1heERheXM6IG51bWJlcikge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAgIC51cGRhdGUoeyBtYXhfYWJzZW50X2RheXM6IG1heERheXMgfSlcclxuICAgICAgLmVxKFwiaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIG1heCBhYnNlbnQgZGF5czpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiTWF4IGFic2VudCBkYXlzIHVwZGF0ZWQ6XCIsIGRhdGEpO1xyXG4gICAgcmV0dXJuIHsgZGF0YSB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIHVwZGF0aW5nIG1heCBhYnNlbnQgZGF5czpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW1wbG95ZWVTdGF0cyB7XHJcbiAgdG90YWxUcmFuc2FjdGlvbnM6IG51bWJlclxyXG4gIHRvdGFsUmV2ZW51ZTogbnVtYmVyXHJcbiAgdG90YWxDb21taXNzaW9uOiBudW1iZXJcclxuICBhdmVyYWdlVHJhbnNhY3Rpb246IG51bWJlclxyXG4gIGJvbnVzUG9pbnRzPzogbnVtYmVyXHJcbiAgcGVuYWx0eVBvaW50cz86IG51bWJlclxyXG4gIHRvdGFsQm9udXM/OiBudW1iZXJcclxuICB0b3RhbFBlbmFsdHk/OiBudW1iZXJcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRW1wbG95ZWUgTWFuYWdlbWVudCBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZXMoKSB7XHJcbiAgY29uc29sZS5sb2coXCJbTU9ERVJOXSBnZXRFbXBsb3llZXMgY2FsbGVkIC0gZmV0Y2hpbmcgYWxsIGVtcGxveWVlcyBpbmNsdWRpbmcgaW5hY3RpdmVcIik7XHJcblxyXG4gIGNvbnN0IHsgZGF0YTogdXNlcnMsIGVycm9yOiB1c2Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgLnNlbGVjdChgXHJcbiAgICAgIGlkLFxyXG4gICAgICBuYW1lLFxyXG4gICAgICBlbWFpbCxcclxuICAgICAgcGhvbmUsXHJcbiAgICAgIHBvc2l0aW9uLFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIGNyZWF0ZWRfYXQsXHJcbiAgICAgIHNhbGFyeSxcclxuICAgICAgY29tbWlzc2lvbl9yYXRlLFxyXG4gICAgICBtYXhfYWJzZW50X2RheXMsXHJcbiAgICAgIHBpbixcclxuICAgICAgcmF0aW5nLFxyXG4gICAgICBhdHRlbmRhbmNlUmF0ZSxcclxuICAgICAgY3VycmVudE1vbnRoQ3VzdG9tZXJzLFxyXG4gICAgICB0b3RhbEN1c3RvbWVycyxcclxuICAgICAgcHJlc2VudERheXMsXHJcbiAgICAgIHRvdGFsV29ya0RheXMsXHJcbiAgICAgIGxhdGVEYXlzLFxyXG4gICAgICBvdmVydGltZUhvdXJzLFxyXG4gICAgICBvdmVydGltZVJhdGUsXHJcbiAgICAgIGJvbnVzUG9pbnRzLFxyXG4gICAgICBwZW5hbHR5UG9pbnRzLFxyXG4gICAgICBrYXNib25CYWxhbmNlLFxyXG4gICAgICBrYXNib25MaW1pdCxcclxuICAgICAgbW9udGhseVJldmVudWVcclxuICAgIGApXHJcbiAgICAub3JkZXIoXCJuYW1lXCIpOyAgLy8gVGFtcGlsa2FuIFNFTVVBIGthcnlhd2FuIChha3RpZiBkYW4gdGlkYWsgYWt0aWYpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW01PREVSTl0gUmVzdWx0OlwiLCB7IFxyXG4gICAgdXNlcnNDb3VudDogdXNlcnM/Lmxlbmd0aCwgXHJcbiAgICBoYXNFcnJvcjogISF1c2Vyc0Vycm9yLFxyXG4gICAgZmlyc3RVc2VyOiB1c2Vycz8uWzBdXHJcbiAgfSk7XHJcblxyXG4gIC8vIFBFTlRJTkc6IEhhbnlhIHJldHVybiBlcnJvciBqaWthIGJlbmFyLWJlbmFyIGFkYSBlcnJvciBEQU4gdGlkYWsgYWRhIGRhdGFcclxuICBpZiAodXNlcnNFcnJvciAmJiAhdXNlcnMpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbTU9ERVJOXSBFcnJvciBmZXRjaGluZyBlbXBsb3llZXM6XCIsIHVzZXJzRXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiB1c2Vyc0Vycm9yIH07XHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm1hc2kgZGF0YSAtIGd1bmFrYW4gZGF0YSBkYXJpIGRhdGFiYXNlXHJcbiAgY29uc3QgZW1wbG95ZWVzID0gKHVzZXJzIHx8IFtdKS5tYXAoKHVzZXI6IGFueSkgPT4gKHtcclxuICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgbmFtZTogdXNlci5uYW1lLFxyXG4gICAgZW1haWw6IHVzZXIuZW1haWwgfHwgJycsXHJcbiAgICBwaG9uZTogdXNlci5waG9uZSB8fCAnJyxcclxuICAgIHBvc2l0aW9uOiB1c2VyLnBvc2l0aW9uIHx8ICcnLFxyXG4gICAgc3RhdHVzOiB1c2VyLnN0YXR1cyB8fCAnYWN0aXZlJyxcclxuICAgIHNhbGFyeTogdXNlci5zYWxhcnkgfHwgMzAwMDAwMCwgLy8gVGFtYmFoa2FuIHNhbGFyeSB1bnR1ayBkaXRhbXBpbGthbiBkaSBrYXJ0dVxyXG4gICAgYmFzZVNhbGFyeTogdXNlci5zYWxhcnkgfHwgMzAwMDAwMCxcclxuICAgIGNvbW1pc3Npb25SYXRlOiB1c2VyLmNvbW1pc3Npb25fcmF0ZSB8fCAwLFxyXG4gICAgcGluOiB1c2VyLnBpbiB8fCAnJyxcclxuICAgIG1heF9hYnNlbnRfZGF5czogdXNlci5tYXhfYWJzZW50X2RheXMgfHwgNCxcclxuICAgIGNyZWF0ZWRfYXQ6IHVzZXIuY3JlYXRlZF9hdCxcclxuICAgIHRvdGFsQm9udXM6IDAsXHJcbiAgICB0b3RhbFBlbmFsdHk6IDAsXHJcbiAgICByYXRpbmc6IHVzZXIucmF0aW5nIHx8IDAsXHJcbiAgICBhdHRlbmRhbmNlUmF0ZTogdXNlci5hdHRlbmRhbmNlUmF0ZSB8fCAwLFxyXG4gICAgY3VycmVudE1vbnRoQ3VzdG9tZXJzOiB1c2VyLmN1cnJlbnRNb250aEN1c3RvbWVycyB8fCAwLFxyXG4gICAgdG90YWxDdXN0b21lcnM6IHVzZXIudG90YWxDdXN0b21lcnMgfHwgMCxcclxuICAgIHByZXNlbnREYXlzOiB1c2VyLnByZXNlbnREYXlzIHx8IDAsXHJcbiAgICB0b3RhbFdvcmtEYXlzOiB1c2VyLnRvdGFsV29ya0RheXMgfHwgMCxcclxuICAgIGxhdGVEYXlzOiB1c2VyLmxhdGVEYXlzIHx8IDAsXHJcbiAgICBvdmVydGltZUhvdXJzOiB1c2VyLm92ZXJ0aW1lSG91cnMgfHwgMCxcclxuICAgIG92ZXJ0aW1lUmF0ZTogdXNlci5vdmVydGltZVJhdGUgfHwgMCxcclxuICAgIGJvbnVzUG9pbnRzOiB1c2VyLmJvbnVzUG9pbnRzIHx8IDAsXHJcbiAgICBwZW5hbHR5UG9pbnRzOiB1c2VyLnBlbmFsdHlQb2ludHMgfHwgMCxcclxuICAgIGthc2JvbkJhbGFuY2U6IHVzZXIua2FzYm9uQmFsYW5jZSB8fCAwLFxyXG4gICAga2FzYm9uTGltaXQ6IHVzZXIua2FzYm9uTGltaXQgfHwgMCxcclxuICAgIG1vbnRobHlSZXZlbnVlOiBTdHJpbmcodXNlci5tb250aGx5UmV2ZW51ZSB8fCAnMCcpXHJcbiAgfSkpO1xyXG5cclxuICBjb25zb2xlLmxvZyhcIltNT0RFUk5dIEZpbmFsIGVtcGxveWVlczpcIiwgZW1wbG95ZWVzLmxlbmd0aCk7XHJcbiAgcmV0dXJuIHsgZGF0YTogZW1wbG95ZWVzLCBlcnJvcjogbnVsbCB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkRW1wbG95ZWUoZW1wbG95ZWU6IFBhcnRpYWw8RW1wbG95ZWU+KSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjExXSBhZGRFbXBsb3llZSBjYWxsZWQgd2l0aDpcIiwgZW1wbG95ZWUpXHJcblxyXG4gIC8vIEp1c3QgY3JlYXRlIHVzZXIgcHJvZmlsZSBpbiB1c2VycyB0YWJsZVxyXG4gIC8vIEFkbWluIHdpbGwgbWFudWFsbHkgY3JlYXRlIGF1dGggdXNlciBpbiBTdXBhYmFzZSBEYXNoYm9hcmQgaWYgbmVlZGVkXHJcbiAgY29uc3QgdXNlckRhdGEgPSB7XHJcbiAgICBuYW1lOiBlbXBsb3llZS5uYW1lLFxyXG4gICAgZW1haWw6IGVtcGxveWVlLmVtYWlsLFxyXG4gICAgcGhvbmU6IGVtcGxveWVlLnBob25lIHx8IG51bGwsXHJcbiAgICBzdGF0dXM6IGVtcGxveWVlLnN0YXR1cyB8fCBcImFjdGl2ZVwiLFxyXG4gICAgcGluOiBlbXBsb3llZS5waW4sXHJcbiAgICBwb3NpdGlvbjogZW1wbG95ZWUucG9zaXRpb24sXHJcbiAgICBzYWxhcnk6IChlbXBsb3llZSBhcyBhbnkpLnNhbGFyeSB8fCBlbXBsb3llZS5iYXNlU2FsYXJ5IHx8IDAsXHJcbiAgICBjb21taXNzaW9uX3JhdGU6IGVtcGxveWVlLmNvbW1pc3Npb25SYXRlIHx8IDAsXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuaW5zZXJ0KFt1c2VyRGF0YV0pLnNlbGVjdCgpLnNpbmdsZSgpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YxMV0gYWRkRW1wbG95ZWUgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1wbG95ZWUoaWQ6IHN0cmluZywgZW1wbG95ZWU6IFBhcnRpYWw8RW1wbG95ZWU+KSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjExXSB1cGRhdGVFbXBsb3llZSBjYWxsZWQgd2l0aDpcIiwgaWQpXHJcblxyXG4gIGNvbnN0IHVzZXJEYXRhID0ge1xyXG4gICAgbmFtZTogZW1wbG95ZWUubmFtZSxcclxuICAgIGVtYWlsOiBlbXBsb3llZS5lbWFpbCxcclxuICAgIHBob25lOiBlbXBsb3llZS5waG9uZSxcclxuICAgIHN0YXR1czogZW1wbG95ZWUuc3RhdHVzLFxyXG4gICAgcGluOiBlbXBsb3llZS5waW4sXHJcbiAgICBwb3NpdGlvbjogZW1wbG95ZWUucG9zaXRpb24sXHJcbiAgICBzYWxhcnk6IGVtcGxveWVlLmJhc2VTYWxhcnksXHJcbiAgICBjb21taXNzaW9uX3JhdGU6IGVtcGxveWVlLmNvbW1pc3Npb25SYXRlLFxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInVzZXJzXCIpLnVwZGF0ZSh1c2VyRGF0YSkuZXEoXCJpZFwiLCBpZCkuc2VsZWN0KCkuc2luZ2xlKClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjExXSB1cGRhdGVFbXBsb3llZSByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVFbXBsb3llZShpZDogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbZGVsZXRlRW1wbG95ZWVdIFN0YXJ0aW5nIGRlbGV0aW9uIGZvciBpZDpcIiwgaWQpXHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBDZWsgYXBha2FoIHVzZXIgYWRhXHJcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nVXNlciwgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgLnNlbGVjdChcIipcIilcclxuICAgICAgLmVxKFwiaWRcIiwgaWQpXHJcbiAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgIGlmIChjaGVja0Vycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbZGVsZXRlRW1wbG95ZWVdIEVycm9yIGNoZWNraW5nIHVzZXI6XCIsIGNoZWNrRXJyb3IpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGVja0Vycm9yIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWV4aXN0aW5nVXNlcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW2RlbGV0ZUVtcGxveWVlXSBVc2VyIG5vdCBmb3VuZFwiKVxyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiBcIkthcnlhd2FuIHRpZGFrIGRpdGVtdWthblwiIH0gYXMgYW55IH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIltkZWxldGVFbXBsb3llZV0gVXNlciBleGlzdHM6XCIsIGV4aXN0aW5nVXNlcilcclxuXHJcbiAgICAvLyBTT0ZUIERFTEVURSAtIHViYWggc3RhdHVzIGphZGkgJ2luYWN0aXZlJyBhZ2FyIGRhdGEgdGV0YXAgYWRhIHVudHVrIHRyYW5zYWtzaVxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAudXBkYXRlKHsgc3RhdHVzOiAnaW5hY3RpdmUnIH0pXHJcbiAgICAgIC5lcShcImlkXCIsIGlkKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZGVsZXRlRW1wbG95ZWVdIFNvZnQgZGVsZXRlIHJlc3BvbnNlOlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbZGVsZXRlRW1wbG95ZWVdIFNvZnQgZGVsZXRlIGVycm9yOlwiLCBlcnJvcilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2RlbGV0ZUVtcGxveWVlXSBTb2Z0IGRlbGV0ZSBzdWNjZXNzZnVsIC0gc3RhdHVzIGNoYW5nZWQgdG8gaW5hY3RpdmVcIilcclxuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxuICAgIFxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGVsZXRlRW1wbG95ZWVdIEV4Y2VwdGlvbjpcIiwgZSlcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6IFN0cmluZyhlKSB9IGFzIGFueSB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQRVJCQUlLQU4gRlVOR1NJIEdFVCBFTVBMT1lFRSBTVEFUU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW1wbG95ZWVTdGF0cyhlbXBsb3llZUlkOiBzdHJpbmcpOiBQcm9taXNlPEVtcGxveWVlU3RhdHM+IHtcclxuICBjb25zb2xlLmxvZyhcIlt2MTMtRklYRURdIGdldEVtcGxveWVlU3RhdHMgY2FsbGVkIGZvcjpcIiwgZW1wbG95ZWVJZCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyAxLiBIaXR1bmcgdHJhbnNha3NpIGRhbiByZXZlbnVlIC0gZ3VuYWthbiBzZXJ2ZXJfaWQgKHlhbmcgbWVsYXlhbmkpLCBidWthbiBjYXNoaWVyX2lkXHJcbiAgICBjb25zdCB7IGRhdGE6IHRyYW5zYWN0aW9ucywgZXJyb3I6IHRyYW5zYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInRyYW5zYWN0aW9uc1wiKVxyXG4gICAgICAuc2VsZWN0KFwidG90YWxfYW1vdW50LCBjcmVhdGVkX2F0XCIpXHJcbiAgICAgIC5lcShcInNlcnZlcl9pZFwiLCBlbXBsb3llZUlkKVxyXG4gICAgICAuZ3RlKFwiY3JlYXRlZF9hdFwiLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIG5ldyBEYXRlKCkuZ2V0TW9udGgoKSwgMSkudG9JU09TdHJpbmcoKSk7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9uc0Vycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjEzLUZJWEVEXSBFcnJvciBmZXRjaGluZyB0cmFuc2FjdGlvbnM6XCIsIHRyYW5zYWN0aW9uc0Vycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3RhbFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucz8ubGVuZ3RoIHx8IDA7XHJcbiAgICBjb25zdCB0b3RhbFJldmVudWUgPSB0cmFuc2FjdGlvbnM/LnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyAodC50b3RhbF9hbW91bnQgfHwgMCksIDApIHx8IDA7XHJcbiAgICBjb25zdCBhdmVyYWdlVHJhbnNhY3Rpb24gPSB0b3RhbFRyYW5zYWN0aW9ucyA+IDAgPyB0b3RhbFJldmVudWUgLyB0b3RhbFRyYW5zYWN0aW9ucyA6IDA7XHJcblxyXG4gICAgLy8gMi4gSGl0dW5nIGtvbWlzaSBkYXJpIGNvbW1pc3Npb25fYW1vdW50IHlhbmcgc3VkYWggdGVyc2ltcGFuIGRpIHRyYW5zYWN0aW9uX2l0ZW1zXHJcbiAgICBsZXQgdG90YWxDb21taXNzaW9uID0gMDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlU3RhdHNdIENhbGN1bGF0aW5nIGNvbW1pc3Npb24gZm9yIGVtcGxveWVlOlwiLCBlbXBsb3llZUlkKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY29tbWlzc2lvbkRhdGEsIGVycm9yOiBjb21taXNzaW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oXCJ0cmFuc2FjdGlvbl9pdGVtc1wiKVxyXG4gICAgICAgIC5zZWxlY3QoXCJjb21taXNzaW9uX2Ftb3VudCwgY29tbWlzc2lvbl9zdGF0dXNcIilcclxuICAgICAgICAuZXEoXCJiYXJiZXJfaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgICAuZXEoXCJjb21taXNzaW9uX3N0YXR1c1wiLCBcImNyZWRpdGVkXCIpXHJcbiAgICAgICAgLmd0ZShcImNyZWF0ZWRfYXRcIiwgbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBuZXcgRGF0ZSgpLmdldE1vbnRoKCksIDEpLnRvSVNPU3RyaW5nKCkpO1xyXG5cclxuICAgICAgaWYgKCFjb21taXNzaW9uRXJyb3IgJiYgY29tbWlzc2lvbkRhdGEpIHtcclxuICAgICAgICB0b3RhbENvbW1pc3Npb24gPSBjb21taXNzaW9uRGF0YS5yZWR1Y2UoKHN1bSwgaXRlbSkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHN1bSArIChpdGVtLmNvbW1pc3Npb25fYW1vdW50IHx8IDApO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlU3RhdHNdIENvbW1pc3Npb24gaXRlbXMgZm91bmQ6XCIsIGNvbW1pc3Npb25EYXRhLmxlbmd0aCwgXCJUb3RhbDpcIiwgdG90YWxDb21taXNzaW9uKTtcclxuICAgICAgfSBlbHNlIGlmIChjb21taXNzaW9uRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiW3YxMy1GSVhFRF0gRXJyb3IgY2FsY3VsYXRpbmcgY29tbWlzc2lvbjpcIiwgY29tbWlzc2lvbkVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoY29tbWlzc2lvbkVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjEzLUZJWEVEXSBVbmV4cGVjdGVkIGVycm9yIGNhbGN1bGF0aW5nIGNvbW1pc3Npb246XCIsIGNvbW1pc3Npb25FcnJvcik7XHJcbiAgICAgIHRvdGFsQ29tbWlzc2lvbiA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4gSGl0dW5nIHBvaW50cyB1bnR1ayBib251cy9wZW5hbHR5XHJcbiAgICBjb25zdCB7IGRhdGE6IHBvaW50c0RhdGEsIGVycm9yOiBwb2ludHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwb2ludHNcIilcclxuICAgICAgLnNlbGVjdChcInBvaW50c19lYXJuZWQsIHBvaW50c190eXBlXCIpXHJcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgZW1wbG95ZWVJZClcclxuICAgICAgLmd0ZShcImNyZWF0ZWRfYXRcIiwgbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBuZXcgRGF0ZSgpLmdldE1vbnRoKCksIDEpLnRvSVNPU3RyaW5nKCkpO1xyXG5cclxuICAgIGxldCBib251c1BvaW50cyA9IDA7XHJcbiAgICBsZXQgcGVuYWx0eVBvaW50cyA9IDA7XHJcbiAgICBcclxuICAgIGlmICghcG9pbnRzRXJyb3IgJiYgcG9pbnRzRGF0YSkge1xyXG4gICAgICBwb2ludHNEYXRhLmZvckVhY2gocG9pbnQgPT4ge1xyXG4gICAgICAgIGlmIChwb2ludC5wb2ludHNfZWFybmVkID4gMCkge1xyXG4gICAgICAgICAgYm9udXNQb2ludHMgKz0gcG9pbnQucG9pbnRzX2Vhcm5lZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGVuYWx0eVBvaW50cyArPSBNYXRoLmFicyhwb2ludC5wb2ludHNfZWFybmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRzOiBFbXBsb3llZVN0YXRzID0ge1xyXG4gICAgICB0b3RhbFRyYW5zYWN0aW9ucyxcclxuICAgICAgdG90YWxSZXZlbnVlLFxyXG4gICAgICB0b3RhbENvbW1pc3Npb24sXHJcbiAgICAgIGF2ZXJhZ2VUcmFuc2FjdGlvbixcclxuICAgICAgYm9udXNQb2ludHMsXHJcbiAgICAgIHBlbmFsdHlQb2ludHMsXHJcbiAgICAgIHRvdGFsQm9udXM6IGJvbnVzUG9pbnRzLFxyXG4gICAgICB0b3RhbFBlbmFsdHk6IHBlbmFsdHlQb2ludHNcclxuICAgIH07XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbdjEzLUZJWEVEXSBFbXBsb3llZSBzdGF0czpcIiwgc3RhdHMpO1xyXG4gICAgcmV0dXJuIHN0YXRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YxMy1GSVhFRF0gVW5leHBlY3RlZCBlcnJvciBpbiBnZXRFbXBsb3llZVN0YXRzOlwiLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIFJldHVybiBkZWZhdWx0IHN0YXRzIGppa2EgdGVyamFkaSBlcnJvclxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxUcmFuc2FjdGlvbnM6IDAsXHJcbiAgICAgIHRvdGFsUmV2ZW51ZTogMCxcclxuICAgICAgdG90YWxDb21taXNzaW9uOiAwLFxyXG4gICAgICBhdmVyYWdlVHJhbnNhY3Rpb246IDAsXHJcbiAgICAgIGJvbnVzUG9pbnRzOiAwLFxyXG4gICAgICBwZW5hbHR5UG9pbnRzOiAwLFxyXG4gICAgICB0b3RhbEJvbnVzOiAwLFxyXG4gICAgICB0b3RhbFBlbmFsdHk6IDBcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW1wbG95ZWVDb21taXNzaW9ucyhlbXBsb3llZUlkOiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MTItRklYRURdIGdldEVtcGxveWVlQ29tbWlzc2lvbnMgKG5vdyBydWxlcykgY2FsbGVkIGZvcjpcIiwgZW1wbG95ZWVJZClcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiY29tbWlzc2lvbl9ydWxlc1wiKVxyXG4gICAgLnNlbGVjdChgKiwgc2VydmljZXMgKG5hbWUsIHByaWNlKWApXHJcbiAgICAuZXEoXCJ1c2VyX2lkXCIsIGVtcGxveWVlSWQpXHJcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YxMi1GSVhFRF0gRXJyb3IgZmV0Y2hpbmcgY29tbWlzc2lvbiBydWxlczpcIiwgZXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjEyLUZJWEVEXSBFbXBsb3llZSBjb21taXNzaW9uIHJ1bGVzIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogW10sIGVycm9yIH0gOiB7IGRhdGE6IGRhdGEgfHwgW10sIGVycm9yOiBudWxsIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUEVSQkFJS0FOIEZVTkdTSSBHRVQgRU1QTE9ZRUUgQVRURU5EQU5DRVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW1wbG95ZWVBdHRlbmRhbmNlKGVtcGxveWVlSWQ6IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YxMy1GSVhFRF0gZ2V0RW1wbG95ZWVBdHRlbmRhbmNlIGNhbGxlZCBmb3I6XCIsIGVtcGxveWVlSWQpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xyXG4gICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XHJcbiAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCAxKTtcclxuICAgIGNvbnN0IGxhc3REYXlPZk1vbnRoID0gbmV3IERhdGUoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCArIDEsIDApO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAuZXEoXCJ1c2VyX2lkXCIsIGVtcGxveWVlSWQpXHJcbiAgICAgIC5ndGUoXCJkYXRlXCIsIGZpcnN0RGF5T2ZNb250aC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pXHJcbiAgICAgIC5sdGUoXCJkYXRlXCIsIGxhc3REYXlPZk1vbnRoLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSlcclxuICAgICAgLm9yZGVyKFwiZGF0ZVwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlt2MTMtRklYRURdIEVycm9yIGZldGNoaW5nIGF0dGVuZGFuY2U6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBhdHRlbmRhbmNlUmF0ZTogMCxcclxuICAgICAgICBwcmVzZW50RGF5czogMCxcclxuICAgICAgICBsYXRlRGF5czogMCxcclxuICAgICAgICBvdmVydGltZUhvdXJzOiAwLFxyXG4gICAgICAgIHRvdGFsV29ya0RheXM6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3RhbFdvcmtEYXlzID0gZ2V0QnVzaW5lc3NEYXlzQ291bnQoZmlyc3REYXlPZk1vbnRoLCBsYXN0RGF5T2ZNb250aCk7XHJcbiAgICBjb25zdCBwcmVzZW50RGF5cyA9IGRhdGEuZmlsdGVyKHJlY29yZCA9PiBcclxuICAgICAgcmVjb3JkLnN0YXR1cyA9PT0gXCJjaGVja2VkX291dFwiIHx8IHJlY29yZC5zdGF0dXMgPT09IFwiY2hlY2tlZF9pblwiXHJcbiAgICApLmxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBsYXRlRGF5cyA9IGRhdGEuZmlsdGVyKHJlY29yZCA9PiB7XHJcbiAgICAgIGlmICghcmVjb3JkLmNoZWNrX2luX3RpbWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgY29uc3QgY2hlY2tJblRpbWUgPSByZWNvcmQuY2hlY2tfaW5fdGltZTtcclxuICAgICAgcmV0dXJuIGNoZWNrSW5UaW1lID4gXCIwODozMDowMFwiO1xyXG4gICAgfSkubGVuZ3RoO1xyXG5cclxuICAgIGNvbnN0IHRvdGFsSG91cnMgPSBkYXRhLnJlZHVjZSgoc3VtLCByZWNvcmQpID0+IHN1bSArIChyZWNvcmQudG90YWxfaG91cnMgfHwgMCksIDApO1xyXG4gICAgY29uc3QgcmVndWxhckhvdXJzID0gcHJlc2VudERheXMgKiA4O1xyXG4gICAgY29uc3Qgb3ZlcnRpbWVIb3VycyA9IE1hdGgubWF4KDAsIHRvdGFsSG91cnMgLSByZWd1bGFySG91cnMpO1xyXG4gICAgY29uc3QgYXR0ZW5kYW5jZVJhdGUgPSB0b3RhbFdvcmtEYXlzID4gMCA/IE1hdGgucm91bmQoKHByZXNlbnREYXlzIC8gdG90YWxXb3JrRGF5cykgKiAxMDApIDogMDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlt2MTMtRklYRURdIEVtcGxveWVlIGF0dGVuZGFuY2UgcmVzdWx0OlwiLCB7IFxyXG4gICAgICB0b3RhbFdvcmtEYXlzLCBcclxuICAgICAgcHJlc2VudERheXMsIFxyXG4gICAgICBsYXRlRGF5cywgXHJcbiAgICAgIG92ZXJ0aW1lSG91cnM6IE1hdGgubWF4KDAsIG92ZXJ0aW1lSG91cnMpLFxyXG4gICAgICBhdHRlbmRhbmNlUmF0ZSBcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IGRhdGEgfHwgW10sXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBhdHRlbmRhbmNlUmF0ZSxcclxuICAgICAgcHJlc2VudERheXMsXHJcbiAgICAgIGxhdGVEYXlzLFxyXG4gICAgICBvdmVydGltZUhvdXJzOiBNYXRoLm1heCgwLCBvdmVydGltZUhvdXJzKSxcclxuICAgICAgdG90YWxXb3JrRGF5c1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MTMtRklYRURdIFVuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0RW1wbG95ZWVBdHRlbmRhbmNlOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBbXSxcclxuICAgICAgZXJyb3I6IGVycm9yIGFzIGFueSxcclxuICAgICAgYXR0ZW5kYW5jZVJhdGU6IDAsXHJcbiAgICAgIHByZXNlbnREYXlzOiAwLFxyXG4gICAgICBsYXRlRGF5czogMCxcclxuICAgICAgb3ZlcnRpbWVIb3VyczogMCxcclxuICAgICAgdG90YWxXb3JrRGF5czogMFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIPCflKUgRlVOR1NJIEJBUlUgWUFORyBESVRBTUJBSEtBTiAtIGdldEVtcGxveWVlUGhvdG9zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZVBob3Rvcyh1c2VySWQ6IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlUGhvdG9zXSBDYWxsZWQgd2l0aCB1c2VySWQ6XCIsIHVzZXJJZClcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIHVzZXJzOnVzZXJfaWQgKCBpZCwgbmFtZSwgZW1haWwsIHBvc2l0aW9uLCBicmFuY2hfaWQgKSxcclxuICAgICAgICBicmFuY2hlczpicmFuY2hfaWQgKCBpZCwgbmFtZSwgYWRkcmVzcyApXHJcbiAgICAgIGApXHJcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxyXG4gICAgICAub3IoXCJjaGVja19pbl9waG90by5ub3QuaXMubnVsbCxjaGVja19vdXRfcGhvdG8ubm90LmlzLm51bGxcIilcclxuICAgICAgLm9yZGVyKFwiZGF0ZVwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLmxpbWl0KDUwKVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlUGhvdG9zXSBRdWVyeSByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltnZXRFbXBsb3llZVBob3Rvc10gRXJyb3I6XCIsIGVycm9yKVxyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXR0ZW5kYW5jZVdpdGhEZXRhaWxzOiBBdHRlbmRhbmNlV2l0aERldGFpbHNbXSA9IChkYXRhIHx8IFtdKS5tYXAoKHJlY29yZDogYW55KSA9PiAoe1xyXG4gICAgICBpZDogcmVjb3JkLmlkLFxyXG4gICAgICB1c2VyX2lkOiByZWNvcmQudXNlcl9pZCxcclxuICAgICAgYnJhbmNoX2lkOiByZWNvcmQuYnJhbmNoX2lkLFxyXG4gICAgICBzaGlmdF90eXBlOiByZWNvcmQuc2hpZnRfdHlwZSxcclxuICAgICAgY2hlY2tfaW5fdGltZTogcmVjb3JkLmNoZWNrX2luX3RpbWUsXHJcbiAgICAgIGNoZWNrX291dF90aW1lOiByZWNvcmQuY2hlY2tfb3V0X3RpbWUsXHJcbiAgICAgIGJyZWFrX3N0YXJ0X3RpbWU6IHJlY29yZC5icmVha19zdGFydF90aW1lLFxyXG4gICAgICBicmVha19lbmRfdGltZTogcmVjb3JkLmJyZWFrX2VuZF90aW1lLFxyXG4gICAgICB0b3RhbF9ob3VyczogcmVjb3JkLnRvdGFsX2hvdXJzLFxyXG4gICAgICBicmVha19kdXJhdGlvbjogcmVjb3JkLmJyZWFrX2R1cmF0aW9uLFxyXG4gICAgICBzdGF0dXM6IHJlY29yZC5zdGF0dXMsXHJcbiAgICAgIGNoZWNrX2luX3Bob3RvOiByZWNvcmQuY2hlY2tfaW5fcGhvdG8sXHJcbiAgICAgIGNoZWNrX291dF9waG90bzogcmVjb3JkLmNoZWNrX291dF9waG90byxcclxuICAgICAgZGF0ZTogcmVjb3JkLmRhdGUsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IHJlY29yZC5jcmVhdGVkX2F0LFxyXG4gICAgICB1cGRhdGVkX2F0OiByZWNvcmQudXBkYXRlZF9hdCxcclxuICAgICAgdXNlcnM6IHJlY29yZC51c2VycyA/IHtcclxuICAgICAgICBpZDogcmVjb3JkLnVzZXJzLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC51c2Vycy5uYW1lLFxyXG4gICAgICAgIGVtYWlsOiByZWNvcmQudXNlcnMuZW1haWwsXHJcbiAgICAgICAgcG9zaXRpb246IHJlY29yZC51c2Vycy5wb3NpdGlvbixcclxuICAgICAgICBicmFuY2hfaWQ6IHJlY29yZC51c2Vycy5icmFuY2hfaWQsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogcmVjb3JkLnVzZXJzLmNyZWF0ZWRfYXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgIGJyYW5jaGVzOiByZWNvcmQuYnJhbmNoZXMgPyB7XHJcbiAgICAgICAgaWQ6IHJlY29yZC5icmFuY2hlcy5pZCxcclxuICAgICAgICBuYW1lOiByZWNvcmQuYnJhbmNoZXMubmFtZSxcclxuICAgICAgICBhZGRyZXNzOiByZWNvcmQuYnJhbmNoZXMuYWRkcmVzcyxcclxuICAgICAgICBjcmVhdGVkX2F0OiByZWNvcmQuYnJhbmNoZXMuY3JlYXRlZF9hdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgfSkpXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVQaG90b3NdIFJldHVybmluZzpcIiwgYXR0ZW5kYW5jZVdpdGhEZXRhaWxzLmxlbmd0aCwgXCJyZWNvcmRzXCIpXHJcbiAgICByZXR1cm4geyBkYXRhOiBhdHRlbmRhbmNlV2l0aERldGFpbHMsIGVycm9yOiBudWxsIH1cclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0RW1wbG95ZWVQaG90b3NdIEV4Y2VwdGlvbjpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVIFlBTkcgRElUQU1CQUhLQU4gLSBnZXRFbXBsb3llZUF0dGVuZGFuY2VXaXRoUGhvdG9zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbXBsb3llZUF0dGVuZGFuY2VXaXRoUGhvdG9zKHVzZXJJZDogc3RyaW5nLCBkYXlzOiBudW1iZXIgPSAzMCkge1xyXG4gIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3NdIENhbGxlZCB3aXRoIHVzZXJJZDpcIiwgdXNlcklkLCBcImRheXM6XCIsIGRheXMpXHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoKVxyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKVxyXG4gICAgc3RhcnREYXRlLnNldERhdGUoZW5kRGF0ZS5nZXREYXRlKCkgLSBkYXlzKVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0RGF0ZVN0ciA9IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cclxuICAgIGNvbnN0IGVuZERhdGVTdHIgPSBlbmREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3NdIERhdGUgcmFuZ2U6XCIsIHN0YXJ0RGF0ZVN0ciwgXCJ0b1wiLCBlbmREYXRlU3RyKVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIHVzZXJzOnVzZXJfaWQgKCBpZCwgbmFtZSwgZW1haWwsIHBvc2l0aW9uLCBicmFuY2hfaWQgKSxcclxuICAgICAgICBicmFuY2hlczpicmFuY2hfaWQgKCBpZCwgbmFtZSwgYWRkcmVzcyApXHJcbiAgICAgIGApXHJcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxyXG4gICAgICAuZ3RlKFwiZGF0ZVwiLCBzdGFydERhdGVTdHIpXHJcbiAgICAgIC5sdGUoXCJkYXRlXCIsIGVuZERhdGVTdHIpXHJcbiAgICAgIC5vcmRlcihcImRhdGVcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3Rvc10gUXVlcnkgcmVzdWx0OlwiLCB7IGRhdGFMZW5ndGg6IGRhdGE/Lmxlbmd0aCwgZXJyb3IgfSlcclxuXHJcbiAgICAvLyBJZ25vcmUgZW1wdHkgZXJyb3Igb2JqZWN0c1xyXG4gICAgaWYgKGVycm9yPy5tZXNzYWdlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3Rvc10gRXJyb3I6XCIsIGVycm9yKVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGF0dGVuZGFuY2VSYXRlOiAwLFxyXG4gICAgICAgIHByZXNlbnREYXlzOiAwLFxyXG4gICAgICAgIGxhdGVEYXlzOiAwLFxyXG4gICAgICAgIHRvdGFsV29ya0RheXM6IGRheXMsXHJcbiAgICAgICAgb3ZlcnRpbWVIb3VyczogMCxcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGF0dGVuZGFuY2VSZWNvcmRzOiBBdHRlbmRhbmNlV2l0aERldGFpbHNbXSA9IChkYXRhIHx8IFtdKS5tYXAoKHJlY29yZDogYW55KSA9PiAoe1xyXG4gICAgICBpZDogcmVjb3JkLmlkLFxyXG4gICAgICB1c2VyX2lkOiByZWNvcmQudXNlcl9pZCxcclxuICAgICAgYnJhbmNoX2lkOiByZWNvcmQuYnJhbmNoX2lkLFxyXG4gICAgICBzaGlmdF90eXBlOiByZWNvcmQuc2hpZnRfdHlwZSxcclxuICAgICAgY2hlY2tfaW5fdGltZTogcmVjb3JkLmNoZWNrX2luX3RpbWUsXHJcbiAgICAgIGNoZWNrX291dF90aW1lOiByZWNvcmQuY2hlY2tfb3V0X3RpbWUsXHJcbiAgICAgIGJyZWFrX3N0YXJ0X3RpbWU6IHJlY29yZC5icmVha19zdGFydF90aW1lLFxyXG4gICAgICBicmVha19lbmRfdGltZTogcmVjb3JkLmJyZWFrX2VuZF90aW1lLFxyXG4gICAgICB0b3RhbF9ob3VyczogcmVjb3JkLnRvdGFsX2hvdXJzLFxyXG4gICAgICBicmVha19kdXJhdGlvbjogcmVjb3JkLmJyZWFrX2R1cmF0aW9uLFxyXG4gICAgICBzdGF0dXM6IHJlY29yZC5zdGF0dXMsXHJcbiAgICAgIGNoZWNrX2luX3Bob3RvOiByZWNvcmQuY2hlY2tfaW5fcGhvdG8sXHJcbiAgICAgIGNoZWNrX291dF9waG90bzogcmVjb3JkLmNoZWNrX291dF9waG90byxcclxuICAgICAgZGF0ZTogcmVjb3JkLmRhdGUsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IHJlY29yZC5jcmVhdGVkX2F0LFxyXG4gICAgICB1cGRhdGVkX2F0OiByZWNvcmQudXBkYXRlZF9hdCxcclxuICAgICAgdXNlcnM6IHJlY29yZC51c2VycyA/IHtcclxuICAgICAgICBpZDogcmVjb3JkLnVzZXJzLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC51c2Vycy5uYW1lLFxyXG4gICAgICAgIGVtYWlsOiByZWNvcmQudXNlcnMuZW1haWwsXHJcbiAgICAgICAgcG9zaXRpb246IHJlY29yZC51c2Vycy5wb3NpdGlvbixcclxuICAgICAgICBicmFuY2hfaWQ6IHJlY29yZC51c2Vycy5icmFuY2hfaWQsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogcmVjb3JkLnVzZXJzLmNyZWF0ZWRfYXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgIGJyYW5jaGVzOiByZWNvcmQuYnJhbmNoZXMgPyB7XHJcbiAgICAgICAgaWQ6IHJlY29yZC5icmFuY2hlcy5pZCxcclxuICAgICAgICBuYW1lOiByZWNvcmQuYnJhbmNoZXMubmFtZSxcclxuICAgICAgICBhZGRyZXNzOiByZWNvcmQuYnJhbmNoZXMuYWRkcmVzcyxcclxuICAgICAgICBjcmVhdGVkX2F0OiByZWNvcmQuYnJhbmNoZXMuY3JlYXRlZF9hdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgfSkpXHJcblxyXG4gICAgY29uc3QgcHJlc2VudERheXMgPSBhdHRlbmRhbmNlUmVjb3Jkcy5maWx0ZXIociA9PlxyXG4gICAgICByLnN0YXR1cyAhPT0gJ2Fic2VudCcgJiYgKHIuY2hlY2tfaW5fdGltZSB8fCByLmNoZWNrX291dF90aW1lKVxyXG4gICAgKS5sZW5ndGhcclxuXHJcbiAgICBjb25zdCBsYXRlRGF5cyA9IGF0dGVuZGFuY2VSZWNvcmRzLmZpbHRlcihyID0+IHtcclxuICAgICAgaWYgKCFyLmNoZWNrX2luX3RpbWUpIHJldHVybiBmYWxzZVxyXG4gICAgICBjb25zdCBjaGVja0luVGltZSA9IHIuY2hlY2tfaW5fdGltZVxyXG4gICAgICByZXR1cm4gY2hlY2tJblRpbWUgPiBcIjA4OjMwXCJcclxuICAgIH0pLmxlbmd0aFxyXG5cclxuICAgIGNvbnN0IHRvdGFsSG91cnMgPSBhdHRlbmRhbmNlUmVjb3Jkcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgKHIudG90YWxfaG91cnMgfHwgMCksIDApXHJcbiAgICBjb25zdCByZWd1bGFySG91cnMgPSBwcmVzZW50RGF5cyAqIDhcclxuICAgIGNvbnN0IG92ZXJ0aW1lSG91cnMgPSBNYXRoLm1heCgwLCB0b3RhbEhvdXJzIC0gcmVndWxhckhvdXJzKVxyXG4gICAgY29uc3QgYXR0ZW5kYW5jZVJhdGUgPSBkYXlzID4gMCA/IE1hdGgucm91bmQoKHByZXNlbnREYXlzIC8gZGF5cykgKiAxMDApIDogMFxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2dldEVtcGxveWVlQXR0ZW5kYW5jZVdpdGhQaG90b3NdIFN0YXRpc3RpY3M6XCIsIHtcclxuICAgICAgYXR0ZW5kYW5jZVJhdGUsXHJcbiAgICAgIHByZXNlbnREYXlzLFxyXG4gICAgICBsYXRlRGF5cyxcclxuICAgICAgdG90YWxXb3JrRGF5czogZGF5cyxcclxuICAgICAgb3ZlcnRpbWVIb3VyczogTWF0aC5yb3VuZChvdmVydGltZUhvdXJzICogMTAwKSAvIDEwMCxcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogYXR0ZW5kYW5jZVJlY29yZHMsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBhdHRlbmRhbmNlUmF0ZSxcclxuICAgICAgcHJlc2VudERheXMsXHJcbiAgICAgIGxhdGVEYXlzLFxyXG4gICAgICB0b3RhbFdvcmtEYXlzOiBkYXlzLFxyXG4gICAgICBvdmVydGltZUhvdXJzOiBNYXRoLnJvdW5kKG92ZXJ0aW1lSG91cnMgKiAxMDApIC8gMTAwLFxyXG4gICAgfVxyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIltnZXRFbXBsb3llZUF0dGVuZGFuY2VXaXRoUGhvdG9zXSBFeGNlcHRpb246XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogW10sXHJcbiAgICAgIGVycm9yOiBlcnJvciBhcyBhbnksXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlOiAwLFxyXG4gICAgICBwcmVzZW50RGF5czogMCxcclxuICAgICAgbGF0ZURheXM6IDAsXHJcbiAgICAgIHRvdGFsV29ya0RheXM6IGRheXMsXHJcbiAgICAgIG92ZXJ0aW1lSG91cnM6IDAsXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBBdXRoIEhlbHBlciBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRVc2VyKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKFwiW2dldEN1cnJlbnRVc2VyXSBBdXRoIHVzZXI6XCIsIHVzZXIpO1xyXG4gICAgY29uc29sZS5sb2coXCJbZ2V0Q3VycmVudFVzZXJdIEF1dGggZXJyb3I6XCIsIGVycm9yKTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0Q3VycmVudFVzZXJdIEVycm9yIGdldHRpbmcgY3VycmVudCB1c2VyOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1c2VyO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldEN1cnJlbnRVc2VyXSBVbmV4cGVjdGVkIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBGdW5nc2kgdW50dWsgZ2V0IHByb2ZpbGUgZGFyaSBhdXRoIGRhdGEgc2FqYVxyXG5hc3luYyBmdW5jdGlvbiBnZXRBdXRoVXNlclByb2ZpbGUodXNlcklkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhOiBhdXRoRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XHJcbiAgICBcclxuICAgIGlmIChhdXRoRGF0YS51c2VyICYmIGF1dGhEYXRhLnVzZXIuaWQgPT09IHVzZXJJZCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBhdXRoRGF0YS51c2VyLmlkLFxyXG4gICAgICAgIGVtYWlsOiBhdXRoRGF0YS51c2VyLmVtYWlsIHx8IFwiXCIsXHJcbiAgICAgICAgbmFtZTogYXV0aERhdGEudXNlci5lbWFpbD8uc3BsaXQoJ0AnKVswXSB8fCBcIlVzZXJcIixcclxuICAgICAgICBwaW46IFwiXCIsXHJcbiAgICAgICAgcG9zaXRpb246IFwiZW1wbG95ZWVcIixcclxuICAgICAgICBzdGF0dXM6IFwiYWN0aXZlXCIsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldEF1dGhVc2VyUHJvZmlsZV0gRXJyb3I6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRnVuZ3NpIHVudHVrIGNyZWF0ZSB1c2VyIHByb2ZpbGUgZGFyaSBhdXRoIGRhdGFcclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlclByb2ZpbGVGcm9tQXV0aCh1c2VySWQ6IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBHZXQgYXV0aCB1c2VyIGRhdGFcclxuICAgIGNvbnN0IHsgZGF0YTogYXV0aERhdGEsIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZ2V0VXNlckJ5SWQodXNlcklkKTtcclxuICAgIFxyXG4gICAgaWYgKGF1dGhFcnJvciB8fCAhYXV0aERhdGEudXNlcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZVVzZXJQcm9maWxlXSBDYW5ub3QgZ2V0IGF1dGggdXNlcjpcIiwgYXV0aEVycm9yKTtcclxuICAgICAgcmV0dXJuIGdldEF1dGhVc2VyUHJvZmlsZSh1c2VySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSB1c2VyIHByb2ZpbGVcclxuICAgIGNvbnN0IHsgZGF0YTogbmV3VXNlciwgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndXNlcnMnKVxyXG4gICAgICAuaW5zZXJ0KHtcclxuICAgICAgICBpZDogYXV0aERhdGEudXNlci5pZCxcclxuICAgICAgICBlbWFpbDogYXV0aERhdGEudXNlci5lbWFpbCxcclxuICAgICAgICBuYW1lOiBhdXRoRGF0YS51c2VyLmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8ICdVc2VyJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2VtcGxveWVlJyxcclxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9KVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChpbnNlcnRFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZVVzZXJQcm9maWxlXSBJbnNlcnQgZmFpbGVkLCB1c2luZyBhdXRoIGRhdGE6XCIsIGluc2VydEVycm9yKTtcclxuICAgICAgcmV0dXJuIGdldEF1dGhVc2VyUHJvZmlsZSh1c2VySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW2NyZWF0ZVVzZXJQcm9maWxlXSBOZXcgdXNlciBwcm9maWxlIGNyZWF0ZWRcIik7XHJcbiAgICByZXR1cm4gbmV3VXNlcjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIltjcmVhdGVVc2VyUHJvZmlsZV0gRXJyb3I6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBnZXRBdXRoVXNlclByb2ZpbGUodXNlcklkKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQZW5nZWx1YXJhbiBDYWJhbmdcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUV4cGVuc2VSZXF1ZXN0KGV4cGVuc2VJZDogc3RyaW5nLCBleHBlbnNlRGF0YTogUGFydGlhbDxFeHBlbnNlPikge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSB1cGRhdGVFeHBlbnNlUmVxdWVzdCBjYWxsZWQgd2l0aDpcIiwgeyBleHBlbnNlSWQsIGV4cGVuc2VEYXRhIH0pXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImV4cGVuc2VzXCIpXHJcbiAgICAudXBkYXRlKHsgXHJcbiAgICAgIC4uLmV4cGVuc2VEYXRhLFxyXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pXHJcbiAgICAuZXEoXCJpZFwiLCBleHBlbnNlSWQpXHJcbiAgICAuc2VsZWN0KClcclxuICAgIC5zaW5nbGUoKVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gVXBkYXRlIGV4cGVuc2UgcmVzdWx0OlwiLCB7IGRhdGEsIGVycm9yIH0pXHJcbiAgcmV0dXJuIGVycm9yID8geyBkYXRhOiBudWxsLCBlcnJvciB9IDogeyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVFeHBlbnNlUmVxdWVzdChleHBlbnNlSWQ6IHN0cmluZykge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBkZWxldGVFeHBlbnNlUmVxdWVzdCBjYWxsZWQgd2l0aCBpZDpcIiwgZXhwZW5zZUlkKVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJleHBlbnNlc1wiKVxyXG4gICAgLmRlbGV0ZSgpXHJcbiAgICAuZXEoXCJpZFwiLCBleHBlbnNlSWQpXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBEZWxldGUgZXhwZW5zZSByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBlbmdlbHVhcmFuIENhYmFuZyAtIEdFVFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RXhwZW5zZXMoYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gZ2V0RXhwZW5zZXMgY2FsbGVkIHdpdGggYnJhbmNoSWQ6XCIsIGJyYW5jaElkKVxyXG5cclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJleHBlbnNlc1wiKVxyXG4gICAgLnNlbGVjdChgXHJcbiAgICAgICosXHJcbiAgICAgIGJyYW5jaGVzIWlubmVyIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lXHJcbiAgICAgIClcclxuICAgIGApXHJcbiAgICAub3JkZXIoXCJleHBlbnNlX2RhdGVcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gIGlmIChicmFuY2hJZCkge1xyXG4gICAgcXVlcnkgPSBxdWVyeS5lcShcImJyYW5jaF9pZFwiLCBicmFuY2hJZClcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBFeHBlbnNlcyByZXN1bHQ6XCIsIHsgZGF0YSwgZXJyb3IgfSlcclxuICByZXR1cm4gZXJyb3IgPyB7IGRhdGE6IFtdLCBlcnJvciB9IDogeyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBlbmdlbHVhcmFuIENhYmFuZyAtIFNUQVRJU1RJQ1NcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEV4cGVuc2VTdGF0aXN0aWNzKGJyYW5jaElkPzogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIGdldEV4cGVuc2VTdGF0aXN0aWNzIGNhbGxlZCB3aXRoIGJyYW5jaElkOlwiLCBicmFuY2hJZClcclxuXHJcbiAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UuZnJvbShcImV4cGVuc2VzXCIpLnNlbGVjdChcImFtb3VudFwiKVxyXG5cclxuICBpZiAoYnJhbmNoSWQpIHtcclxuICAgIHF1ZXJ5ID0gcXVlcnkuZXEoXCJicmFuY2hfaWRcIiwgYnJhbmNoSWQpXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxyXG5cclxuICBpZiAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBFcnJvciBmZXRjaGluZyBleHBlbnNlIHN0YXRpc3RpY3M6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHRvdGFsRXhwZW5zZXM6IDAsXHJcbiAgICAgICAgYXZlcmFnZVBlclRyYW5zYWN0aW9uOiAwLFxyXG4gICAgICB9LFxyXG4gICAgICBlcnJvcixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHRvdGFsRXhwZW5zZXMgPSBkYXRhPy5yZWR1Y2UoKHN1bSwgZXhwZW5zZSkgPT4gc3VtICsgKGV4cGVuc2UuYW1vdW50IHx8IDApLCAwKSB8fCAwXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25Db3VudCA9IGRhdGE/Lmxlbmd0aCB8fCAwXHJcbiAgY29uc3QgYXZlcmFnZVBlclRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25Db3VudCA+IDAgPyBNYXRoLnJvdW5kKHRvdGFsRXhwZW5zZXMgLyB0cmFuc2FjdGlvbkNvdW50KSA6IDBcclxuXHJcbiAgY29uc3Qgc3RhdGlzdGljcyA9IHtcclxuICAgIHRvdGFsRXhwZW5zZXMsXHJcbiAgICBhdmVyYWdlUGVyVHJhbnNhY3Rpb24sXHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gRXhwZW5zZSBzdGF0aXN0aWNzIHJlc3VsdDpcIiwgc3RhdGlzdGljcylcclxuICByZXR1cm4geyBkYXRhOiBzdGF0aXN0aWNzLCBlcnJvcjogbnVsbCB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBlbmdlbHVhcmFuIENhYmFuZyAtIENSRUFURVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRXhwZW5zZVJlcXVlc3QoZXhwZW5zZURhdGE6IHtcclxuICBicmFuY2hfaWQ/OiBzdHJpbmdcclxuICBjYXRlZ29yeTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIGFtb3VudDogbnVtYmVyXHJcbiAgbm90ZXM/OiBzdHJpbmdcclxufSkge1xyXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBjcmVhdGVFeHBlbnNlUmVxdWVzdCBjYWxsZWQgd2l0aDpcIiwgZXhwZW5zZURhdGEpXHJcblxyXG4gIGNvbnN0IGV4cGVuc2VUb0luc2VydCA9IHtcclxuICAgIGJyYW5jaF9pZDogZXhwZW5zZURhdGEuYnJhbmNoX2lkIHx8IG51bGwsXHJcbiAgICBjYXRlZ29yeTogZXhwZW5zZURhdGEuY2F0ZWdvcnksXHJcbiAgICBkZXNjcmlwdGlvbjogZXhwZW5zZURhdGEuZGVzY3JpcHRpb24sXHJcbiAgICBhbW91bnQ6IGV4cGVuc2VEYXRhLmFtb3VudCxcclxuICAgIG5vdGVzOiBleHBlbnNlRGF0YS5ub3RlcyB8fCBudWxsLFxyXG4gICAgZXhwZW5zZV9kYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdLFxyXG4gICAgc3RhdHVzOiBcInBlbmRpbmdcIixcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiRGF0YSB5YW5nIGFrYW4gZGlpbnNlcnQ6XCIsIGV4cGVuc2VUb0luc2VydClcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiZXhwZW5zZXNcIilcclxuICAgIC5pbnNlcnQoZXhwZW5zZVRvSW5zZXJ0KVxyXG4gICAgLnNlbGVjdCgpXHJcbiAgICAuc2luZ2xlKClcclxuXHJcbiAgY29uc29sZS5sb2coXCJbdjBdIENyZWF0ZSBleHBlbnNlIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KVxyXG4gIFxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkRldGFpbCBlcnJvcjpcIiwgZXJyb3IpXHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBlcnJvciA/IHsgZGF0YTogbnVsbCwgZXJyb3IgfSA6IHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBLZWxvbGEgUGVuZ2VsdWFyYW4gRnVuY3Rpb25zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVuc2VXaXRoRGV0YWlscyBleHRlbmRzIEV4cGVuc2Uge1xyXG4gIGJyYW5jaGVzPzogeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfTtcclxuICBcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEV4cGVuc2VzV2l0aERldGFpbHMoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBGZXRjaGluZyBleHBlbnNlcyB3aXRob3V0IHVzZXJzIHJlbGF0aW9uc2hpcC4uLlwiKTtcclxuICAgIFxyXG4gICAgLy8gUEFTVElLQU4gaGFueWEgc2VsZWN0IGJyYW5jaGVzIHNhamEsIHRhbnBhIHVzZXJzXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZXhwZW5zZXMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoKilcclxuICAgICAgYClcclxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgZXhwZW5zZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi4pyFIFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGV4cGVuc2VzOlwiLCBkYXRhPy5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVFeHBlbnNlU3RhdHVzKFxyXG4gIGV4cGVuc2VJZDogc3RyaW5nLCBcclxuICBzdGF0dXM6IFwiYXBwcm92ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwicGFpZFwiLFxyXG4gIHJlamVjdGlvblJlYXNvbj86IHN0cmluZ1xyXG4pIHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coXCLwn5SEIFVwZGF0aW5nIGV4cGVuc2Ugc3RhdHVzOlwiLCB7IGV4cGVuc2VJZCwgc3RhdHVzLCByZWplY3Rpb25SZWFzb24gfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGFuIHJlamVjdGlvbl9yZWFzb24gamlrYSBhZGFcclxuICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGFtYmFoa2FuIHJlamVjdGlvbl9yZWFzb24gamlrYSBzdGF0dXMgcmVqZWN0ZWRcclxuICAgIGlmIChzdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAmJiByZWplY3Rpb25SZWFzb24pIHtcclxuICAgICAgdXBkYXRlRGF0YS5yZWplY3Rpb25fcmVhc29uID0gcmVqZWN0aW9uUmVhc29uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFyIHJlamVjdGlvbl9yZWFzb24gamlrYSBzdGF0dXMgYXBwcm92ZWQvcGFpZFxyXG4gICAgaWYgKHN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiIHx8IHN0YXR1cyA9PT0gXCJwYWlkXCIpIHtcclxuICAgICAgdXBkYXRlRGF0YS5yZWplY3Rpb25fcmVhc29uID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZXhwZW5zZXMnKVxyXG4gICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXHJcbiAgICAgIC5lcSgnaWQnLCBleHBlbnNlSWQpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciB1cGRhdGluZyBleHBlbnNlIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCLinIUgRXhwZW5zZSBzdGF0dXMgdXBkYXRlZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEV4cGVuc2VTdGF0aXN0aWNzQnlCcmFuY2goYnJhbmNoSWQ/OiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2V4cGVuc2VzJylcclxuICAgICAgLnNlbGVjdCgnc3RhdHVzLCBhbW91bnQnKTtcclxuXHJcbiAgICBpZiAoYnJhbmNoSWQgJiYgYnJhbmNoSWQgIT09ICdhbGwnKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2JyYW5jaF9pZCcsIGJyYW5jaElkKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZXhwZW5zZSBzdGF0aXN0aWNzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbDogMCxcclxuICAgICAgICBwZW5kaW5nOiAwLFxyXG4gICAgICAgIGFwcHJvdmVkOiAwLFxyXG4gICAgICAgIHJlamVjdGVkOiAwLFxyXG4gICAgICAgIHBhaWQ6IDAsXHJcbiAgICAgICAgdG90YWxBbW91bnQ6IDAsXHJcbiAgICAgICAgcGVuZGluZ0Ftb3VudDogMCxcclxuICAgICAgICBhcHByb3ZlZEFtb3VudDogMCxcclxuICAgICAgICByZWplY3RlZEFtb3VudDogMCxcclxuICAgICAgICBwYWlkQW1vdW50OiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdHMgPSB7XHJcbiAgICAgIHRvdGFsOiBkYXRhPy5sZW5ndGggfHwgMCxcclxuICAgICAgcGVuZGluZzogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdwZW5kaW5nJykubGVuZ3RoIHx8IDAsXHJcbiAgICAgIGFwcHJvdmVkOiBkYXRhPy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ2FwcHJvdmVkJykubGVuZ3RoIHx8IDAsXHJcbiAgICAgIHJlamVjdGVkOiBkYXRhPy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykubGVuZ3RoIHx8IDAsXHJcbiAgICAgIHBhaWQ6IGRhdGE/LmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAncGFpZCcpLmxlbmd0aCB8fCAwLFxyXG4gICAgICB0b3RhbEFtb3VudDogZGF0YT8ucmVkdWNlKChzdW0sIGUpID0+IHN1bSArIChlLmFtb3VudCB8fCAwKSwgMCkgfHwgMCxcclxuICAgICAgcGVuZGluZ0Ftb3VudDogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdwZW5kaW5nJykucmVkdWNlKChzdW0sIGUpID0+IHN1bSArIChlLmFtb3VudCB8fCAwKSwgMCkgfHwgMCxcclxuICAgICAgYXBwcm92ZWRBbW91bnQ6IGRhdGE/LmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAnYXBwcm92ZWQnKS5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgKGUuYW1vdW50IHx8IDApLCAwKSB8fCAwLFxyXG4gICAgICByZWplY3RlZEFtb3VudDogZGF0YT8uZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdyZWplY3RlZCcpLnJlZHVjZSgoc3VtLCBlKSA9PiBzdW0gKyAoZS5hbW91bnQgfHwgMCksIDApIHx8IDAsXHJcbiAgICAgIHBhaWRBbW91bnQ6IGRhdGE/LmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAncGFpZCcpLnJlZHVjZSgoc3VtLCBlKSA9PiBzdW0gKyAoZS5hbW91bnQgfHwgMCksIDApIHx8IDBcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHN0YXRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGdldEV4cGVuc2VTdGF0aXN0aWNzQnlCcmFuY2g6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWw6IDAsXHJcbiAgICAgIHBlbmRpbmc6IDAsXHJcbiAgICAgIGFwcHJvdmVkOiAwLFxyXG4gICAgICByZWplY3RlZDogMCxcclxuICAgICAgcGFpZDogMCxcclxuICAgICAgdG90YWxBbW91bnQ6IDAsXHJcbiAgICAgIHBlbmRpbmdBbW91bnQ6IDAsXHJcbiAgICAgIGFwcHJvdmVkQW1vdW50OiAwLFxyXG4gICAgICByZWplY3RlZEFtb3VudDogMCxcclxuICAgICAgcGFpZEFtb3VudDogMFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFeHBlbnNlc0J5U3RhdHVzKHN0YXR1czogc3RyaW5nLCBicmFuY2hJZD86IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZXhwZW5zZXMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoKiksXHJcbiAgICAgICAgdXNlcnM6cmVxdWVzdGVkX2J5ICgqKVxyXG4gICAgICBgKVxyXG4gICAgICAuZXEoJ3N0YXR1cycsIHN0YXR1cylcclxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgIGlmIChicmFuY2hJZCAmJiBicmFuY2hJZCAhPT0gJ2FsbCcpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnYnJhbmNoX2lkJywgYnJhbmNoSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyAke3N0YXR1c30gZXhwZW5zZXM6YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhOiBkYXRhIHx8IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gQWRkaXRpb25hbCBGdW5jdGlvbnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBYnNlbnRFbXBsb3llZXNUb2RheSgpOiBQcm9taXNlPEVtcGxveWVlW10+IHtcclxuICBjb25zb2xlLmxvZyhcIlt2MF0gZ2V0QWJzZW50RW1wbG95ZWVzVG9kYXkgY2FsbGVkXCIpXHJcblxyXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KFwiVFwiKVswXVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhOiBhY3RpdmVFbXBsb3llZXMsIGVycm9yOiBlbXBsb3llZXNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAuZXEoXCJzdGF0dXNcIiwgXCJhY3RpdmVcIilcclxuICAgICAgLm9yZGVyKFwibmFtZVwiKVxyXG5cclxuICAgIGlmIChlbXBsb3llZXNFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBmZXRjaGluZyBhY3RpdmUgZW1wbG95ZWVzOlwiLCBlbXBsb3llZXNFcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiB0b2RheUF0dGVuZGFuY2UsIGVycm9yOiBhdHRlbmRhbmNlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiYXR0ZW5kYW5jZVwiKVxyXG4gICAgICAuc2VsZWN0KFwidXNlcl9pZFwiKVxyXG4gICAgICAuZXEoXCJkYXRlXCIsIHRvZGF5KVxyXG5cclxuICAgIGlmIChhdHRlbmRhbmNlRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgZmV0Y2hpbmcgdG9kYXkncyBhdHRlbmRhbmNlOlwiLCBhdHRlbmRhbmNlRXJyb3IpXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByZXNlbnRFbXBsb3llZUlkcyA9IG5ldyBTZXQodG9kYXlBdHRlbmRhbmNlPy5tYXAoKGEpID0+IGEudXNlcl9pZCkgfHwgW10pXHJcbiAgICBjb25zdCBhYnNlbnRFbXBsb3llZXMgPSBhY3RpdmVFbXBsb3llZXM/LmZpbHRlcigoZW1wbG95ZWUpID0+ICFwcmVzZW50RW1wbG95ZWVJZHMuaGFzKGVtcGxveWVlLmlkKSkgfHwgW11cclxuXHJcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEFic2VudEVtcGxveWVlczogRW1wbG95ZWVbXSA9IGFic2VudEVtcGxveWVlcy5tYXAoKHVzZXI6IGFueSkgPT4gKHtcclxuICAgICAgaWQ6IHVzZXIuaWQsXHJcbiAgICAgIG5hbWU6IHVzZXIubmFtZSxcclxuICAgICAgZW1haWw6IHVzZXIuZW1haWwgfHwgXCJcIixcclxuICAgICAgcGhvbmU6IHVzZXIucGhvbmUgfHwgXCJcIixcclxuICAgICAgcG9zaXRpb246IHVzZXIucG9zaXRpb24gfHwgXCJlbXBsb3llZVwiLFxyXG4gICAgICBzdGF0dXM6IHVzZXIuc3RhdHVzIHx8IFwiYWN0aXZlXCIsXHJcbiAgICAgIGF2YXRhcjogYC9wbGFjZWhvbGRlci5zdmc/aGVpZ2h0PTQwJndpZHRoPTQwJnF1ZXJ5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVzZXIubmFtZSl9YCxcclxuICAgICAgcmF0aW5nOiA0LjUsXHJcbiAgICAgIGJhc2VTYWxhcnk6IDUwMDAwMDAsXHJcbiAgICAgIGF0dGVuZGFuY2VSYXRlOiA5NSxcclxuICAgICAgY3VycmVudE1vbnRoQ3VzdG9tZXJzOiAwLFxyXG4gICAgICB0b3RhbEN1c3RvbWVyczogMCxcclxuICAgICAgcHJlc2VudERheXM6IDAsXHJcbiAgICAgIHRvdGFsV29ya0RheXM6IDAsXHJcbiAgICAgIGxhdGVEYXlzOiAwLFxyXG4gICAgICBvdmVydGltZUhvdXJzOiAwLFxyXG4gICAgICBvdmVydGltZVJhdGU6IDI1MDAwLFxyXG4gICAgICBib251c1BvaW50czogMCxcclxuICAgICAgcGVuYWx0eVBvaW50czogMCxcclxuICAgICAgY29tbWlzc2lvblJhdGU6IDAuMDUsXHJcbiAgICAgIGpvaW5EYXRlOiB1c2VyLmNyZWF0ZWRfYXQsXHJcbiAgICAgIGthc2JvbkJhbGFuY2U6IDAsXHJcbiAgICAgIGthc2JvbkxpbWl0OiAyMDAwMDAwLFxyXG4gICAgICBtb250aGx5UmV2ZW51ZTogXCIwXCIsXHJcbiAgICAgIHBpbjogdXNlci5waW4gfHwgXCJcIixcclxuICAgIH0pKVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBGb3VuZCBhYnNlbnQgZW1wbG95ZWVzOlwiLCB0cmFuc2Zvcm1lZEFic2VudEVtcGxveWVlcy5sZW5ndGgpXHJcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRBYnNlbnRFbXBsb3llZXNcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgaW4gZ2V0QWJzZW50RW1wbG95ZWVzVG9kYXk6XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIFtdXHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBBdHRlbmRhbmNlIE1hbmFnZW1lbnQgRnVuY3Rpb25zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZXRhaWxlZEF0dGVuZGFuY2VSZWNvcmRzKGRhdGU/OiBzdHJpbmcpIHtcclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJhdHRlbmRhbmNlXCIpXHJcbiAgICAuc2VsZWN0KGAqLFxyXG4gICAgICB1c2Vyczp1c2VyX2lkIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgIGJyYW5jaF9pZFxyXG4gICAgICApLFxyXG4gICAgICBicmFuY2hlczpicmFuY2hfaWQgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgYWRkcmVzcyxcclxuICAgICAgICBzaGlmdHNcclxuICAgICAgKVxyXG4gICAgYClcclxuICAgIC5vcmRlcihcImRhdGVcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICBpZiAoZGF0ZSkge1xyXG4gICAgcXVlcnkgPSBxdWVyeS5lcShcImRhdGVcIiwgZGF0ZSlcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgZmV0Y2hpbmcgZGV0YWlsZWQgYXR0ZW5kYW5jZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3IgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZGF0YTogZGF0YSB8fCBbXSwgZXJyb3I6IG51bGwgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBPVVRMRVQgU1RPQ0sgTUFOQUdFTUVOVFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPdXRsZXRTdG9jayB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBvdXRsZXRfaWQ6IHN0cmluZztcclxuICBzZXJ2aWNlX2lkOiBzdHJpbmc7XHJcbiAgc3RvY2tfcXVhbnRpdHk6IG51bWJlcjtcclxuICBtaW5fc3RvY2tfdGhyZXNob2xkOiBudW1iZXI7XHJcbiAgaXNfYWN0aXZlOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcclxuICB1cGRhdGVkX2F0OiBzdHJpbmc7XHJcbiAgc2VydmljZT86IFNlcnZpY2VXaXRoQ2F0ZWdvcnk7XHJcbiAgYnJhbmNoPzogQnJhbmNoO1xyXG59XHJcblxyXG4vLyDwn5SlIEdFVCBzdG9jayBwZXIgb3V0bGV0XHJcbmV4cG9ydCBjb25zdCBnZXRPdXRsZXRTdG9jayA9IGFzeW5jIChvdXRsZXRJZDogc3RyaW5nKTogUHJvbWlzZTx7IGRhdGE6IE91dGxldFN0b2NrW10gfCBudWxsOyBlcnJvcjogYW55IH0+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ291dGxldF9zdG9jaycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ291dGxldF9pZCcsIG91dGxldElkKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG91dGxldCBzdG9jazonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBnZXRPdXRsZXRTdG9jazonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIPCflKUgVVBEQVRFIHN0b2NrIHBlciBvdXRsZXQgKHdpdGggVVBTRVJUKVxyXG5leHBvcnQgY29uc3QgdXBkYXRlT3V0bGV0U3RvY2sgPSBhc3luYyAoXHJcbiAgb3V0bGV0SWQ6IHN0cmluZywgXHJcbiAgc2VydmljZUlkOiBzdHJpbmcsIFxyXG4gIG5ld1N0b2NrOiBudW1iZXJcclxuKTogUHJvbWlzZTx7IGRhdGE6IE91dGxldFN0b2NrIHwgbnVsbDsgZXJyb3I6IGFueSB9PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFVzZSB1cHNlcnQgdG8gY3JlYXRlIGlmIG5vdCBleGlzdHMsIHVwZGF0ZSBpZiBleGlzdHNcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdvdXRsZXRfc3RvY2snKVxyXG4gICAgICAudXBzZXJ0KHsgXHJcbiAgICAgICAgb3V0bGV0X2lkOiBvdXRsZXRJZCxcclxuICAgICAgICBzZXJ2aWNlX2lkOiBzZXJ2aWNlSWQsXHJcbiAgICAgICAgc3RvY2tfcXVhbnRpdHk6IG5ld1N0b2NrLFxyXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBtaW5fc3RvY2tfdGhyZXNob2xkOiA1LCAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBvbkNvbmZsaWN0OiAnb3V0bGV0X2lkLHNlcnZpY2VfaWQnXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIG91dGxldCBzdG9jazonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiB1cGRhdGVPdXRsZXRTdG9jazonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIPCflKUgR0VUIGxvdyBzdG9jayBhbGVydHMgKEZJWEVEIFZFUlNJT04pXHJcbmV4cG9ydCBjb25zdCBnZXRMb3dTdG9ja0FsZXJ0cyA9IGFzeW5jICgpOiBQcm9taXNlPHsgZGF0YTogT3V0bGV0U3RvY2tbXSB8IG51bGw7IGVycm9yOiBhbnkgfT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBHZXQgYWxsIG91dGxldCBzdG9jayAobm8gam9pbnMgbmVlZGVkKVxyXG4gICAgY29uc3QgeyBkYXRhOiBhbGxTdG9jaywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdvdXRsZXRfc3RvY2snKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKTtcclxuXHJcbiAgICBpZiAoZmV0Y2hFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBvdXRsZXQgc3RvY2s6JywgZmV0Y2hFcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBmZXRjaEVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIG1hbnVhbGx5IGZvciBsb3cgc3RvY2tcclxuICAgIGNvbnN0IGxvd1N0b2NrID0gKGFsbFN0b2NrIHx8IFtdKS5maWx0ZXIoaXRlbSA9PiBcclxuICAgICAgaXRlbS5zdG9ja19xdWFudGl0eSA8PSBpdGVtLm1pbl9zdG9ja190aHJlc2hvbGRcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YTogbG93U3RvY2ssIGVycm9yOiBudWxsIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gZ2V0TG93U3RvY2tBbGVydHM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICB9XHJcbn07XHJcblxyXG4vLyDwn5SlIFJFRFVDRSBzdG9jayBrZXRpa2EgdGVyamFkaSB0cmFuc2Frc2lcclxuLy8g8J+UpSBSRURVQ0Ugc3RvY2sga2V0aWthIHRlcmphZGkgdHJhbnNha3NpIChGSVhFRClcclxuZXhwb3J0IGNvbnN0IHJlZHVjZU91dGxldFN0b2NrID0gYXN5bmMgKFxyXG4gIG91dGxldElkOiBzdHJpbmcsXHJcbiAgc2VydmljZUlkOiBzdHJpbmcsXHJcbiAgcXVhbnRpdHk6IG51bWJlclxyXG4pOiBQcm9taXNlPHsgZGF0YTogT3V0bGV0U3RvY2sgfCBudWxsOyBlcnJvcjogYW55IH0+ID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gR2V0IGN1cnJlbnQgc3RvY2tcclxuICAgIGNvbnN0IHsgZGF0YTogY3VycmVudFN0b2NrLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ291dGxldF9zdG9jaycpXHJcbiAgICAgIC5zZWxlY3QoJ3N0b2NrX3F1YW50aXR5JylcclxuICAgICAgLmVxKCdvdXRsZXRfaWQnLCBvdXRsZXRJZClcclxuICAgICAgLmVxKCdzZXJ2aWNlX2lkJywgc2VydmljZUlkKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGZldGNoRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY3VycmVudCBzdG9jazonLCBmZXRjaEVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGZldGNoRXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTdG9jayA9IE1hdGgubWF4KDAsIChjdXJyZW50U3RvY2s/LnN0b2NrX3F1YW50aXR5IHx8IDApIC0gcXVhbnRpdHkpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBzdG9ja1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ291dGxldF9zdG9jaycpXHJcbiAgICAgIC51cGRhdGUoeyBcclxuICAgICAgICBzdG9ja19xdWFudGl0eTogbmV3U3RvY2ssXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5lcSgnb3V0bGV0X2lkJywgb3V0bGV0SWQpXHJcbiAgICAgIC5lcSgnc2VydmljZV9pZCcsIHNlcnZpY2VJZClcclxuICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgKixcclxuICAgICAgICBzZXJ2aWNlOnNlcnZpY2VzKCosIHNlcnZpY2VfY2F0ZWdvcmllcygqKSksXHJcbiAgICAgICAgYnJhbmNoOm91dGxldF9pZCgqKVxyXG4gICAgICBgKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZHVjaW5nIG91dGxldCBzdG9jazonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiByZWR1Y2VPdXRsZXRTdG9jazonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBPUyBIZWxwZXIgRnVuY3Rpb25zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEJyYW5jaGVzRGF0YSA9IGFzeW5jIChzdXBhYmFzZTogYW55LCBzZXRCcmFuY2hlczogYW55LCBzZXRTZWxlY3RlZEJyYW5jaDogYW55KSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImJyYW5jaGVzXCIpLnNlbGVjdChcIipcIilcclxuICBpZiAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGJyYW5jaGVzOlwiLCBlcnJvcilcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBzZXRCcmFuY2hlcyhkYXRhKVxyXG4gIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgIHNldFNlbGVjdGVkQnJhbmNoKGRhdGFbMF0ubmFtZSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQnJhbmNoRGF0YSA9IGFzeW5jIChzdXBhYmFzZTogYW55LCBzZXRSZWNlaXB0VGVtcGxhdGU6IGFueSwgc2V0QnJhbmNoSW5mbzogYW55KSA9PiB7XHJcbiAgY29uc29sZS5sb2coXCJbdjBdIExvYWRpbmcgYnJhbmNoIGFuZCB0ZW1wbGF0ZSBkYXRhLi4uXCIpXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YTogdGVtcGxhdGVEYXRhLCBlcnJvcjogdGVtcGxhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJyZWNlaXB0X3RlbXBsYXRlc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAuZXEoXCJpc19hY3RpdmVcIiwgdHJ1ZSlcclxuICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgaWYgKHRlbXBsYXRlRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgcmVjZWlwdCB0ZW1wbGF0ZTpcIiwgdGVtcGxhdGVFcnJvcilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBMb2FkZWQgYWN0aXZlIHRlbXBsYXRlOlwiLCB0ZW1wbGF0ZURhdGEpXHJcbiAgICAgIHNldFJlY2VpcHRUZW1wbGF0ZSh0ZW1wbGF0ZURhdGEpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJbdjBdIEJyYW5jaCBkYXRhIGxvYWRpbmcgY29tcGxldGVkIHdpdGhvdXQgb3ZlcnJpZGluZyBzZWxlY3RlZEJyYW5jaFwiKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBicmFuY2ggYW5kIHRlbXBsYXRlIGRhdGE6XCIsIGVycm9yKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHByb2Nlc3NUcmFuc2FjdGlvbiA9IGFzeW5jIChcclxuICBzdXBhYmFzZTogYW55LFxyXG4gIGJyYW5jaGVzOiBhbnlbXSxcclxuICBzZWxlY3RlZEJyYW5jaDogc3RyaW5nLFxyXG4gIGNhcnQ6IGFueVtdLFxyXG4gIGN1cnJlbnRVc2VyOiBhbnksXHJcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nLFxyXG4gIGN1c3RvbWVyTmFtZTogc3RyaW5nLFxyXG4gIGRpc2NvdW50UmVhc29uOiBzdHJpbmcsXHJcbiAgZ2V0VG90YWxQcmljZTogKCkgPT4gbnVtYmVyLFxyXG4gIGdldERpc2NvdW50QW1vdW50OiAoKSA9PiBudW1iZXIsXHJcbiAgZ2V0RmluYWxUb3RhbDogKCkgPT4gbnVtYmVyLFxyXG4pID0+IHtcclxuICBjb25zdCBzZWxlY3RlZEJyYW5jaERhdGEgPSBicmFuY2hlcy5maW5kKChiKSA9PiBiLm5hbWUgPT09IHNlbGVjdGVkQnJhbmNoKVxyXG5cclxuICBpZiAoIXNlbGVjdGVkQnJhbmNoRGF0YT8uaWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgY2FiYW5nIHRpZGFrIGRpdGVtdWthblwiKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVjZWlwdE51bWJlciA9IGAke25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0ke1N0cmluZyhuZXcgRGF0ZSgpLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCBcIjBcIil9JHtTdHJpbmcobmV3IERhdGUoKS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke1N0cmluZyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSkucGFkU3RhcnQoMywgXCIwXCIpfWBcclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xyXG4gICAgcmVjZWlwdF9udW1iZXI6IHJlY2VpcHROdW1iZXIsXHJcbiAgICBicmFuY2hfaWQ6IHNlbGVjdGVkQnJhbmNoRGF0YS5pZCxcclxuICAgIHRvdGFsX2Ftb3VudDogZ2V0VG90YWxQcmljZSgpLFxyXG4gICAgZGlzY291bnRfYW1vdW50OiBnZXREaXNjb3VudEFtb3VudCgpLFxyXG4gICAgZmluYWxfYW1vdW50OiBnZXRGaW5hbFRvdGFsKCksXHJcbiAgICBwYXltZW50X21ldGhvZDogcGF5bWVudE1ldGhvZCxcclxuICAgIGN1c3RvbWVyX25hbWU6IGN1c3RvbWVyTmFtZSB8fCBudWxsLFxyXG4gICAgbm90ZXM6IGRpc2NvdW50UmVhc29uIHx8IG51bGwsXHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlt2MF0gQ3JlYXRpbmcgdHJhbnNhY3Rpb24gd2l0aCBjb3JyZWN0IGJyYW5jaF9pZDpcIiwgdHJhbnNhY3Rpb25EYXRhKVxyXG4gIHJldHVybiB0cmFuc2FjdGlvbkRhdGFcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8g8J+UpSBGVU5HU0kgQkFSVTogU2V0dXAgUmVhbHRpbWUgU3Vic2NyaXB0aW9uIHVudHVrIFRyYW5zYWtzaVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgY29uc3Qgc2V0dXBUcmFuc2FjdGlvbnNSZWFsdGltZSA9IChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4ge1xyXG4gIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxyXG4gICAgLmNoYW5uZWwoJ3RyYW5zYWN0aW9ucy1nbG9iYWwnKVxyXG4gICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgXHJcbiAgICAgIHsgXHJcbiAgICAgICAgZXZlbnQ6ICcqJywgXHJcbiAgICAgICAgc2NoZW1hOiAncHVibGljJywgXHJcbiAgICAgICAgdGFibGU6ICd0cmFuc2FjdGlvbnMnIFxyXG4gICAgICB9LCBcclxuICAgICAgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gY2hhbmdlIGRldGVjdGVkOicsIHBheWxvYWQpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsXHJcbiAgICAgIHtcclxuICAgICAgICBldmVudDogJyonLFxyXG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXHJcbiAgICAgICAgdGFibGU6ICd0cmFuc2FjdGlvbl9pdGVtcydcclxuICAgICAgfSxcclxuICAgICAgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaXRlbSBjaGFuZ2UgZGV0ZWN0ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdSZWFsdGltZSBzdWJzY3JpcHRpb24gc3RhdHVzOicsIHN0YXR1cyk7XHJcbiAgICB9KTtcclxuXHJcbiAgcmV0dXJuIGNoYW5uZWw7XHJcbn07XHJcblxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBTZXR1cCBSZWFsdGltZSB1bnR1ayBLb21pc2lcclxuZXhwb3J0IGNvbnN0IHNldHVwS29taXNpUmVhbHRpbWUgPSAoY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHtcclxuICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2VcclxuICAgIC5jaGFubmVsKCdrb21pc2ktZ2xvYmFsJylcclxuICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsXHJcbiAgICAgIHtcclxuICAgICAgICBldmVudDogJyonLFxyXG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXHJcbiAgICAgICAgdGFibGU6ICdjb21taXNzaW9uX3J1bGVzJ1xyXG4gICAgICB9LFxyXG4gICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb21taXNzaW9uIHJ1bGUgY2hhbmdlIGRldGVjdGVkOicsIHBheWxvYWQpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIC5zdWJzY3JpYmUoKHN0YXR1cykgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnS29taXNpIHN1YnNjcmlwdGlvbiBzdGF0dXM6Jywgc3RhdHVzKTtcclxuICAgIH0pO1xyXG5cclxuICByZXR1cm4gY2hhbm5lbDtcclxufTtcclxuXHJcbi8vIPCflKUgRlVOR1NJIEJBUlU6IEJyb2FkY2FzdCBFdmVudCB1bnR1ayBTaW5rcm9uaXNhc2kgR2xvYmFsXHJcbmV4cG9ydCBjb25zdCBicm9hZGNhc3RUcmFuc2FjdGlvbkV2ZW50ID0gYXN5bmMgKGV2ZW50VHlwZTogc3RyaW5nLCBwYXlsb2FkOiBhbnkpID0+IHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgc3VwYWJhc2UuY2hhbm5lbCgnZ2xvYmFsLWV2ZW50cycpLnNlbmQoe1xyXG4gICAgICB0eXBlOiAnYnJvYWRjYXN0JyxcclxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSxcclxuICAgICAgcGF5bG9hZDogcGF5bG9hZFxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhgQnJvYWRjYXN0IGV2ZW50ICcke2V2ZW50VHlwZX0nIHNlbnQgc3VjY2Vzc2Z1bGx5YCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGJyb2FkY2FzdGluZyBldmVudDonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8g8J+UpSBGVU5HU0kgQkFSVTogTGlzdGVuIHVudHVrIEdsb2JhbCBFdmVudHNcclxuZXhwb3J0IGNvbnN0IHNldHVwR2xvYmFsRXZlbnRzTGlzdGVuZXIgPSAoY2FsbGJhY2s6IChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpID0+IHZvaWQpID0+IHtcclxuICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2UuY2hhbm5lbCgnZ2xvYmFsLWV2ZW50cy1saXN0ZW5lcicpXHJcbiAgICAub24oJ2Jyb2FkY2FzdCcsIHsgZXZlbnQ6ICcqJyB9LCAocGF5bG9hZCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnR2xvYmFsIGV2ZW50IHJlY2VpdmVkOicsIHBheWxvYWQpO1xyXG4gICAgICBjYWxsYmFjayhwYXlsb2FkLmV2ZW50LCBwYXlsb2FkLnBheWxvYWQpO1xyXG4gICAgfSlcclxuICAgIC5zdWJzY3JpYmUoKTtcclxuXHJcbiAgcmV0dXJuIGNoYW5uZWw7XHJcbn07XHJcblxyXG4vLyDwn5SlIEZVTkdTSSBCQVJVOiBTdWJzY3JpYmUgdG8gRXZlbnRzXHJcbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVUb0V2ZW50cyA9IChjYWxsYmFjazogKGV2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSkgPT4gdm9pZCkgPT4ge1xyXG4gIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZS5jaGFubmVsKCdnbG9iYWwtZXZlbnRzLWxpc3RlbmVyJylcclxuICAgIC5vbignYnJvYWRjYXN0JywgeyBldmVudDogJyonIH0sIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdHbG9iYWwgZXZlbnQgcmVjZWl2ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgIGNhbGxiYWNrKHBheWxvYWQuZXZlbnQsIHBheWxvYWQucGF5bG9hZCk7XHJcbiAgICB9KVxyXG4gICAgLnN1YnNjcmliZSgpO1xyXG5cclxuICByZXR1cm4gY2hhbm5lbDtcclxufTtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIPCflKUgRlVOR1NJIEJBUlU6IFNldHVwIFJlYWx0aW1lIFN1YnNjcmlwdGlvbiB1bnR1ayBFbXBsb3llZVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgY29uc3Qgc2V0dXBFbXBsb3llZVJlYWx0aW1lID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB7XHJcbiAgY29uc29sZS5sb2coXCJTZXR0aW5nIHVwIGVtcGxveWVlIHJlYWx0aW1lIHN1YnNjcmlwdGlvblwiKTtcclxuXHJcbiAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlXHJcbiAgICAuY2hhbm5lbCgnZW1wbG95ZWVzLWdsb2JhbCcpXHJcbiAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCBcclxuICAgICAgeyBcclxuICAgICAgICBldmVudDogJyonLCBcclxuICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLCBcclxuICAgICAgICB0YWJsZTogJ3VzZXJzJyBcclxuICAgICAgfSwgXHJcbiAgICAgIChwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0VtcGxveWVlIGNoYW5nZSBkZXRlY3RlZDonLCBwYXlsb2FkKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLFxyXG4gICAgICB7XHJcbiAgICAgICAgZXZlbnQ6ICcqJyxcclxuICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLFxyXG4gICAgICAgIHRhYmxlOiAncG9pbnRzJ1xyXG4gICAgICB9LFxyXG4gICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQb2ludHMgY2hhbmdlIGRldGVjdGVkIChhZmZlY3RzIGVtcGxveWVlIHN0YXRzKTonLCBwYXlsb2FkKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLFxyXG4gICAgICB7XHJcbiAgICAgICAgZXZlbnQ6ICcqJyxcclxuICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLFxyXG4gICAgICAgIHRhYmxlOiAnYXR0ZW5kYW5jZSdcclxuICAgICAgfSxcclxuICAgICAgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW5kYW5jZSBjaGFuZ2UgZGV0ZWN0ZWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdFbXBsb3llZSByZWFsdGltZSBzdWJzY3JpcHRpb24gc3RhdHVzOicsIHN0YXR1cyk7XHJcbiAgICB9KTtcclxuXHJcbiAgcmV0dXJuIGNoYW5uZWw7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXBwcm92ZWRFeHBlbnNlcygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coXCLwn5SNIEZldGNoaW5nIGFwcHJvdmVkIGV4cGVuc2VzLi4uXCIpO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnZXhwZW5zZXMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIGJyYW5jaGVzOmJyYW5jaF9pZCAoKilcclxuICAgICAgYClcclxuICAgICAgLmluKCdzdGF0dXMnLCBbJ2FwcHJvdmVkJywgJ3BhaWQnXSlcclxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgYXBwcm92ZWQgZXhwZW5zZXM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBhcHByb3ZlZCBleHBlbnNlczpcIiwgZGF0YT8ubGVuZ3RoKTtcclxuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvciB9O1xyXG4gIH1cclxufVxyXG4vLyDwn5SlIFRBTUJBSEtBTiBmdW5nc2kgaW5pIGRpIHN1cGFiYXNlLnRzXHJcbmV4cG9ydCBjb25zdCBnZXRPd25lclBpbiA9IGFzeW5jICgpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndXNlcnMnKVxyXG4gICAgICAuc2VsZWN0KCdwaW4nKVxyXG4gICAgICAuZXEoJ3Bvc2l0aW9uJywgJ293bmVyJylcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBvd25lciBQSU46JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gJyc7IC8vIFJldHVybiBlbXB0eSBzdHJpbmcgaWYgbm90IGZvdW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGEucGluIHx8ICcnO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGdldE93bmVyUGluOicsIGVycm9yKTtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn07XHJcbi8vIPCflKUgVEFNQkFIS0FOIGZ1bmdzaSBpbmkgZGkgc3VwYWJhc2UudHNcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJQaW4gPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIG5ld1Bpbjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFZhbGlkYXNpIFBJTiA2IGRpZ2l0XHJcbiAgICBpZiAobmV3UGluLmxlbmd0aCAhPT0gNiB8fCAhL15cXGQrJC8udGVzdChuZXdQaW4pKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgUElOIGZvcm1hdCcpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgLnVwZGF0ZSh7IHBpbjogbmV3UGluIH0pXHJcbiAgICAgIC5lcSgnaWQnLCB1c2VySWQpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBQSU46JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gdXBkYXRlVXNlclBpbjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59OyJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIkVycm9yIiwic3VwYWJhc2UiLCJhdXRoIiwicGVyc2lzdFNlc3Npb24iLCJhdXRvUmVmcmVzaFRva2VuIiwicmVhbHRpbWUiLCJwYXJhbXMiLCJldmVudHNQZXJTZWNvbmQiLCJnbG9iYWwiLCJoZWFkZXJzIiwidGVzdFN1cGFiYXNlQ29ubmVjdGlvbiIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJjb25zb2xlIiwibG9nIiwiZ2V0QnVzaW5lc3NEYXlzQ291bnQiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiY291bnQiLCJjdXJEYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJkYXlPZldlZWsiLCJnZXREYXkiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImdldEJyYW5jaFNoaWZ0cyIsImJyYW5jaElkIiwiZXEiLCJvcmRlciIsImxlbmd0aCIsImlkIiwiYnJhbmNoX2lkIiwic2hpZnRfbmFtZSIsInNoaWZ0X3R5cGUiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiLCJpc19hY3RpdmUiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJjcmVhdGVCcmFuY2hTaGlmdCIsInNoaWZ0RGF0YSIsInNoaWZ0VG9JbnNlcnQiLCJpbnNlcnQiLCJzaW5nbGUiLCJ1cGxvYWRQaG90b1RvU3VwYWJhc2UiLCJiYXNlNjQiLCJmaWxlbmFtZSIsImJhc2U2NFRvQmxvYiIsImJhc2U2NERhdGEiLCJjb250ZW50VHlwZSIsImJ5dGVDaGFyYWN0ZXJzIiwiYXRvYiIsInNwbGl0IiwiYnl0ZUFycmF5cyIsIm9mZnNldCIsInNsaWNlIiwiYnl0ZU51bWJlcnMiLCJBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwicHVzaCIsIlVpbnQ4QXJyYXkiLCJCbG9iIiwidHlwZSIsImJsb2IiLCJzdG9yYWdlIiwidXBsb2FkIiwiY2FjaGVDb250cm9sIiwidXBzZXJ0IiwicHVibGljVXJsRGF0YSIsImdldFB1YmxpY1VybCIsInB1YmxpY1VybCIsImNyZWF0ZUF0dGVuZGFuY2VSZWNvcmQiLCJhdHRlbmRhbmNlRGF0YSIsInVwZGF0ZUF0dGVuZGFuY2VSZWNvcmQiLCJ1cGRhdGVzIiwidXBkYXRlIiwidXBkYXRlZF9hdCIsImdldEF0dGVuZGFuY2VCeURhdGUiLCJ1c2VySWQiLCJkYXRlIiwiY29kZSIsImdldEFsbEF0dGVuZGFuY2VSZWNvcmRzIiwicXVlcnkiLCJhc2NlbmRpbmciLCJnZXRTZXJ2aWNlc1dpdGhDYXRlZ29yaWVzIiwiZ2V0U2VydmljZUNhdGVnb3JpZXMiLCJjcmVhdGVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uRGF0YSIsInRyYW5zYWN0aW9uTnVtYmVyIiwiZ2VuZXJhdGVUcmFuc2FjdGlvbk51bWJlciIsImNhc2hpZXJfaWQiLCJzZXJ2ZXJfaWQiLCJjYXNoaWVyTmFtZSIsImJyYW5jaE5hbWUiLCJzZXJ2ZXJOYW1lIiwidXNlcnMiLCJsaW1pdCIsIm5hbWUiLCJjYXNoaWVyIiwiYnJhbmNoZXMiLCJicmFuY2giLCJzZXJ2ZXIiLCJ0cmFuc2FjdGlvblRvSW5zZXJ0IiwidHJhbnNhY3Rpb25fbnVtYmVyIiwicmVjZWlwdF9udW1iZXIiLCJjYXNoaWVyX25hbWUiLCJicmFuY2hfbmFtZSIsInNlcnZlcl9uYW1lIiwic3VidG90YWwiLCJ0b3RhbF9hbW91bnQiLCJwYXltZW50X3N0YXR1cyIsInBheW1lbnRfbWV0aG9kIiwiZGlzY291bnRfYW1vdW50IiwiY3JlYXRlVHJhbnNhY3Rpb25JdGVtcyIsIml0ZW1zIiwiZW5yaWNoZWRJdGVtcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJpdGVtIiwic2VydmljZV9pZCIsInNlcnZpY2UiLCJzZXJ2aWNlX25hbWUiLCJzZXJ2aWNlX3R5cGUiLCJzZXJ2aWNlX2NhdGVnb3J5IiwiaXNBcnJheSIsInNlcnZpY2VfY2F0ZWdvcmllcyIsImdldFJlY2VpcHRUZW1wbGF0ZSIsImdldEFjdGl2ZVJlY2VpcHRUZW1wbGF0ZSIsImFjdGl2ZURhdGEiLCJhY3RpdmVFcnJvciIsImRlZmF1bHRRdWVyeSIsImRlZmF1bHREYXRhIiwiZGVmYXVsdEVycm9yIiwiZ2V0QnJhbmNoZXMiLCJycGMiLCJ0b2RheSIsImRhdGVTdHIiLCJyZXBsYWNlIiwidHJhbnNhY3Rpb25zIiwiZ3RlIiwibHQiLCJjb3VudGVyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm5vdyIsImNoZWNrU2VydmljZVN0b2NrIiwic2VydmljZUlkIiwic3RvY2siLCJyZWR1Y2VTZXJ2aWNlU3RvY2siLCJxdWFudGl0eSIsImN1cnJlbnRTZXJ2aWNlIiwiZmV0Y2hFcnJvciIsImN1cnJlbnRTdG9jayIsIm5ld1N0b2NrIiwiTWF0aCIsIm1heCIsInVwZGF0ZVNlcnZpY2VTdG9jayIsImdldFVzZXJzV2l0aFBvaW50cyIsInVzZXJzUXVlcnkiLCJ1c2Vyc0Vycm9yIiwiYWxsUG9pbnRzIiwicG9pbnRzRXJyb3IiLCJ1c2Vyc1dpdGhDYWxjdWxhdGVkUG9pbnRzIiwidXNlciIsInVzZXJQb2ludHMiLCJmaWx0ZXIiLCJwb2ludCIsInVzZXJfaWQiLCJ0b3RhbFBvaW50cyIsInJlZHVjZSIsInN1bSIsInBvaW50c19lYXJuZWQiLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aGx5UG9pbnRzIiwicG9pbnREYXRlIiwidG90YWxfcG9pbnRzIiwibW9udGhseV9wb2ludHMiLCJzb3J0ZWRVc2VycyIsInNvcnQiLCJhIiwiYiIsImluZGV4IiwicmFuayIsImdldFBvaW50c1N0YXRpc3RpY3MiLCJ0b3RhbEVtcGxveWVlcyIsInRvcFBlcmZvcm1lciIsImF2ZXJhZ2VQb2ludHMiLCJyb3VuZCIsImdldFBvaW50VHJhbnNhY3Rpb25zIiwidXNlcnNJbkJyYW5jaCIsInVzZXJJZHMiLCJ1IiwiaW4iLCJwb2ludHNEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJTZXQiLCJwIiwiQm9vbGVhbiIsInVzZXJzTWFwIiwiYWNjIiwiYnJhbmNoSWRzIiwiT2JqZWN0IiwidmFsdWVzIiwiYnJhbmNoZXNNYXAiLCJlbnJpY2hlZERhdGEiLCJhZGRQb2ludFRyYW5zYWN0aW9uIiwicG9pbnREYXRhIiwiZ2V0VXNlclBvaW50cyIsImdldEthc2JvblJlcXVlc3RzIiwic3RhdHVzRmlsdGVyIiwia2FzYm9uRGF0YSIsImsiLCJhcHByb3ZlcklkcyIsImFwcHJvdmVkX2J5IiwiYXBwcm92ZXJzTWFwIiwiYXBwcm92ZXJzIiwia2FzYm9uIiwiYXBwcm92ZXIiLCJnZXRLYXNib25TdGF0aXN0aWNzIiwicGVuZGluZ0Ftb3VudCIsImFwcHJvdmVkQW1vdW50IiwidG90YWxQYWlkIiwiYWN0aXZlRW1wbG95ZWVzIiwic3RhdHVzIiwiYW1vdW50IiwidXNlcnNEYXRhIiwic3RhdGlzdGljcyIsImdldFVzZXJzV2l0aEthc2JvbiIsImFsbEthc2JvbiIsImthc2JvbkVycm9yIiwidXNlcnNXaXRob3V0S2FzYm9uIiwidG90YWxfa2FzYm9uIiwiYWN0aXZlX2thc2JvbiIsImthc2Jvbl9oaXN0b3J5IiwidXNlcnNXaXRoS2FzYm9uRGF0YSIsInVzZXJLYXNib24iLCJ0b3RhbEthc2JvbiIsImFjdGl2ZUthc2JvbiIsImNyZWF0ZUthc2JvblJlcXVlc3QiLCJ1c2VyRXJyb3IiLCJrYXNib25Ub0luc2VydCIsInVzZXJfbmFtZSIsInJlcXVlc3RfZGF0ZSIsInVwZGF0ZUthc2JvblN0YXR1cyIsImthc2JvbklkIiwiYXBwcm92ZWRCeSIsInVwZGF0ZURhdGEiLCJhcHByb3ZlZF9hdCIsImdldEVtcGxveWVlQWJzZW5jZUluZm8iLCJlbXBsb3llZUlkIiwiZW1wbG95ZWUiLCJlbXBFcnJvciIsIm1heEFic2VudERheXMiLCJjdXJyZW50QWJzZW50RGF5cyIsInJlbWFpbmluZ0RheXMiLCJleGNlc3NEYXlzIiwiY3VycmVudERhdGUiLCJmaXJzdERheU9mTW9udGgiLCJsYXN0RGF5T2ZNb250aCIsImF0dGVuZGFuY2VFcnJvciIsImx0ZSIsIm1heF9hYnNlbnRfZGF5cyIsInJlY29yZCIsInVwZGF0ZU1heEFic2VudERheXMiLCJtYXhEYXlzIiwiZ2V0RW1wbG95ZWVzIiwidXNlcnNDb3VudCIsImhhc0Vycm9yIiwiZmlyc3RVc2VyIiwiZW1wbG95ZWVzIiwiZW1haWwiLCJwaG9uZSIsInBvc2l0aW9uIiwic2FsYXJ5IiwiYmFzZVNhbGFyeSIsImNvbW1pc3Npb25SYXRlIiwiY29tbWlzc2lvbl9yYXRlIiwicGluIiwidG90YWxCb251cyIsInRvdGFsUGVuYWx0eSIsInJhdGluZyIsImF0dGVuZGFuY2VSYXRlIiwiY3VycmVudE1vbnRoQ3VzdG9tZXJzIiwidG90YWxDdXN0b21lcnMiLCJwcmVzZW50RGF5cyIsInRvdGFsV29ya0RheXMiLCJsYXRlRGF5cyIsIm92ZXJ0aW1lSG91cnMiLCJvdmVydGltZVJhdGUiLCJib251c1BvaW50cyIsInBlbmFsdHlQb2ludHMiLCJrYXNib25CYWxhbmNlIiwia2FzYm9uTGltaXQiLCJtb250aGx5UmV2ZW51ZSIsIlN0cmluZyIsImFkZEVtcGxveWVlIiwidXNlckRhdGEiLCJ1cGRhdGVFbXBsb3llZSIsImRlbGV0ZUVtcGxveWVlIiwiZXhpc3RpbmdVc2VyIiwiY2hlY2tFcnJvciIsImUiLCJnZXRFbXBsb3llZVN0YXRzIiwidHJhbnNhY3Rpb25zRXJyb3IiLCJ0b3RhbFRyYW5zYWN0aW9ucyIsInRvdGFsUmV2ZW51ZSIsInQiLCJhdmVyYWdlVHJhbnNhY3Rpb24iLCJ0b3RhbENvbW1pc3Npb24iLCJjb21taXNzaW9uRGF0YSIsImNvbW1pc3Npb25FcnJvciIsImNvbW1pc3Npb25fYW1vdW50IiwiZm9yRWFjaCIsImFicyIsInN0YXRzIiwiZ2V0RW1wbG95ZWVDb21taXNzaW9ucyIsImdldEVtcGxveWVlQXR0ZW5kYW5jZSIsImNoZWNrX2luX3RpbWUiLCJjaGVja0luVGltZSIsInRvdGFsSG91cnMiLCJ0b3RhbF9ob3VycyIsInJlZ3VsYXJIb3VycyIsImdldEVtcGxveWVlUGhvdG9zIiwib3IiLCJhdHRlbmRhbmNlV2l0aERldGFpbHMiLCJjaGVja19vdXRfdGltZSIsImJyZWFrX3N0YXJ0X3RpbWUiLCJicmVha19lbmRfdGltZSIsImJyZWFrX2R1cmF0aW9uIiwiY2hlY2tfaW5fcGhvdG8iLCJjaGVja19vdXRfcGhvdG8iLCJ1bmRlZmluZWQiLCJhZGRyZXNzIiwiZ2V0RW1wbG95ZWVBdHRlbmRhbmNlV2l0aFBob3RvcyIsImRheXMiLCJzdGFydERhdGVTdHIiLCJlbmREYXRlU3RyIiwiZGF0YUxlbmd0aCIsImF0dGVuZGFuY2VSZWNvcmRzIiwiciIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsImdldEF1dGhVc2VyUHJvZmlsZSIsImF1dGhEYXRhIiwiY3JlYXRlVXNlclByb2ZpbGVGcm9tQXV0aCIsImF1dGhFcnJvciIsImFkbWluIiwiZ2V0VXNlckJ5SWQiLCJuZXdVc2VyIiwiaW5zZXJ0RXJyb3IiLCJ1cGRhdGVFeHBlbnNlUmVxdWVzdCIsImV4cGVuc2VJZCIsImV4cGVuc2VEYXRhIiwiZGVsZXRlRXhwZW5zZVJlcXVlc3QiLCJkZWxldGUiLCJnZXRFeHBlbnNlcyIsImdldEV4cGVuc2VTdGF0aXN0aWNzIiwidG90YWxFeHBlbnNlcyIsImF2ZXJhZ2VQZXJUcmFuc2FjdGlvbiIsImV4cGVuc2UiLCJ0cmFuc2FjdGlvbkNvdW50IiwiY3JlYXRlRXhwZW5zZVJlcXVlc3QiLCJleHBlbnNlVG9JbnNlcnQiLCJjYXRlZ29yeSIsImRlc2NyaXB0aW9uIiwibm90ZXMiLCJleHBlbnNlX2RhdGUiLCJnZXRBbGxFeHBlbnNlc1dpdGhEZXRhaWxzIiwidXBkYXRlRXhwZW5zZVN0YXR1cyIsInJlamVjdGlvblJlYXNvbiIsInJlamVjdGlvbl9yZWFzb24iLCJnZXRFeHBlbnNlU3RhdGlzdGljc0J5QnJhbmNoIiwidG90YWwiLCJwZW5kaW5nIiwiYXBwcm92ZWQiLCJyZWplY3RlZCIsInBhaWQiLCJ0b3RhbEFtb3VudCIsInJlamVjdGVkQW1vdW50IiwicGFpZEFtb3VudCIsImdldEV4cGVuc2VzQnlTdGF0dXMiLCJnZXRBYnNlbnRFbXBsb3llZXNUb2RheSIsImVtcGxveWVlc0Vycm9yIiwidG9kYXlBdHRlbmRhbmNlIiwicHJlc2VudEVtcGxveWVlSWRzIiwiYWJzZW50RW1wbG95ZWVzIiwiaGFzIiwidHJhbnNmb3JtZWRBYnNlbnRFbXBsb3llZXMiLCJhdmF0YXIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luRGF0ZSIsImdldERldGFpbGVkQXR0ZW5kYW5jZVJlY29yZHMiLCJnZXRPdXRsZXRTdG9jayIsIm91dGxldElkIiwidXBkYXRlT3V0bGV0U3RvY2siLCJvdXRsZXRfaWQiLCJzdG9ja19xdWFudGl0eSIsIm1pbl9zdG9ja190aHJlc2hvbGQiLCJvbkNvbmZsaWN0IiwiZ2V0TG93U3RvY2tBbGVydHMiLCJhbGxTdG9jayIsImxvd1N0b2NrIiwicmVkdWNlT3V0bGV0U3RvY2siLCJsb2FkQnJhbmNoZXNEYXRhIiwic2V0QnJhbmNoZXMiLCJzZXRTZWxlY3RlZEJyYW5jaCIsImxvYWRCcmFuY2hEYXRhIiwic2V0UmVjZWlwdFRlbXBsYXRlIiwic2V0QnJhbmNoSW5mbyIsInRlbXBsYXRlRGF0YSIsInRlbXBsYXRlRXJyb3IiLCJwcm9jZXNzVHJhbnNhY3Rpb24iLCJzZWxlY3RlZEJyYW5jaCIsImNhcnQiLCJjdXJyZW50VXNlciIsInBheW1lbnRNZXRob2QiLCJjdXN0b21lck5hbWUiLCJkaXNjb3VudFJlYXNvbiIsImdldFRvdGFsUHJpY2UiLCJnZXREaXNjb3VudEFtb3VudCIsImdldEZpbmFsVG90YWwiLCJzZWxlY3RlZEJyYW5jaERhdGEiLCJmaW5kIiwicmVjZWlwdE51bWJlciIsImZsb29yIiwicmFuZG9tIiwiZmluYWxfYW1vdW50IiwiY3VzdG9tZXJfbmFtZSIsInNldHVwVHJhbnNhY3Rpb25zUmVhbHRpbWUiLCJjYWxsYmFjayIsImNoYW5uZWwiLCJvbiIsImV2ZW50Iiwic2NoZW1hIiwidGFibGUiLCJwYXlsb2FkIiwic3Vic2NyaWJlIiwic2V0dXBLb21pc2lSZWFsdGltZSIsImJyb2FkY2FzdFRyYW5zYWN0aW9uRXZlbnQiLCJldmVudFR5cGUiLCJzZW5kIiwic2V0dXBHbG9iYWxFdmVudHNMaXN0ZW5lciIsInN1YnNjcmliZVRvRXZlbnRzIiwic2V0dXBFbXBsb3llZVJlYWx0aW1lIiwiZ2V0QXBwcm92ZWRFeHBlbnNlcyIsImdldE93bmVyUGluIiwidXBkYXRlVXNlclBpbiIsIm5ld1BpbiIsInRlc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.ts\n"));

/***/ })

});